===============================================
PROJECT SNAPSHOT CREATED ON: Mon Jun 23 23:35:08 EEST 2025
===============================================


--- START FILE: backend/src/admin/admin.controller.ts ---

// backend/src/admin/admin.controller.ts

import { Controller, Post, Param, ParseIntPipe, UseGuards, HttpCode, HttpStatus, Body, Patch, Request, Logger } from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { UsersService, PublicUser } from '../users/users.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { User } from '../users/entities/user.entity';
import { AdminUpdateUserDto } from './dto/admin-update-user.dto';
import { SystemRanks } from '../ranks/ranks.service';

@ApiTags('Admin')
@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
@ApiBearerAuth()
export class AdminController {
    private readonly logger = new Logger(AdminController.name);

    constructor(private readonly usersService: UsersService) { }

    @Post('/users/:id/ban')
    @Roles(SystemRanks.MODERATOR.power_level)
    @ApiOperation({ summary: 'Ban a user' })
    @ApiResponse({ status: 200, description: 'User has been banned successfully.', type: User })
    @ApiResponse({ status: 403, description: 'Forbidden.' })
    @ApiResponse({ status: 404, description: 'User not found.' })
    banUser(
        @Param('id', ParseIntPipe) id: number,
        @Request() req,
    ): Promise<PublicUser> {
        const actorId = req.user.userId;
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
        this.logger.warn(`[BAN] üö´ Actor ID: ${actorId} is banning User ID: ${id}`);
        return this.usersService.banUser(id);
    }

    @Post('/users/:id/unban')
    @Roles(SystemRanks.ADMIN.power_level)
    @ApiOperation({ summary: 'Unban a user' })
    @ApiResponse({ status: 200, description: 'User has been unbanned successfully.', type: User })
    @ApiResponse({ status: 403, description: 'Forbidden.' })
    @ApiResponse({ status: 404, description: 'User not found.' })
    unbanUser(
        @Param('id', ParseIntPipe) id: number,
        @Request() req,
    ): Promise<PublicUser> {
        const actorId = req.user.userId;
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
        this.logger.log(`[UNBAN] ‚úÖ Actor ID: ${actorId} is unbanning User ID: ${id}`);
        return this.usersService.unbanUser(id);
    }

    @Patch('/users/:id/update')
    @Roles(SystemRanks.ADMIN.power_level)
    @ApiOperation({ summary: 'Update a user by admin' })
    @ApiResponse({ status: 200, description: 'User has been updated successfully.', type: User })
    @ApiResponse({ status: 403, description: 'Forbidden.' })
    @ApiResponse({ status: 404, description: 'User not found.' })
    updateUser(
        @Param('id', ParseIntPipe) id: number,
        @Body() adminUpdateUserDto: AdminUpdateUserDto,
        @Request() req,
    ): Promise<PublicUser> {
        const actorId = req.user.userId;
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
        this.logger.log(`[UPDATE] üìù Actor ID: ${actorId} is updating User ID: ${id}. Data: ${JSON.stringify(adminUpdateUserDto)}`);
        return this.usersService.adminUpdateUser(id, adminUpdateUserDto, actorId);
    }
}
--- END FILE: backend/src/admin/admin.controller.ts ---



--- START FILE: backend/src/admin/admin.module.ts ---

import { Module } from '@nestjs/common';
import { AdminController } from './admin.controller';
// UsersModule –±–æ–ª—å—à–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ

@Module({
  imports: [], // <-- –¢–µ–ø–µ—Ä—å –º–∞—Å—Å–∏–≤ –∏–º–ø–æ—Ä—Ç–æ–≤ –ø—É—Å—Ç
  controllers: [AdminController]
})
export class AdminModule {}
--- END FILE: backend/src/admin/admin.module.ts ---



--- START FILE: backend/src/admin/admin.service.ts ---

import { Injectable } from '@nestjs/common';


@Injectable()
export class AdminService {

}

--- END FILE: backend/src/admin/admin.service.ts ---



--- START FILE: backend/src/admin/dto/admin-update-user.dto.ts ---

import { IsInt, IsOptional } from 'class-validator';

export class AdminUpdateUserDto {
  @IsOptional()
  @IsInt({ message: 'Rank ID must be an integer.' }) // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —ç—Ç–æ —á–∏—Å–ª–æ
  rank_id?: number;

  @IsOptional()
  @IsInt()
  reputation_count?: number;
}
--- END FILE: backend/src/admin/dto/admin-update-user.dto.ts ---



--- START FILE: backend/src/app.controller.ts ---

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import { AppModule } from './app.module';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

--- END FILE: backend/src/app.controller.ts ---



--- START FILE: backend/src/app.module.ts ---

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { EventEmitterModule } from '@nestjs/event-emitter';

import { User } from './users/entities/user.entity';
import { ShopItem } from './shop/entities/shop-item.entity';
import { Post } from './posts/entities/post.entity';
import { Friendship } from './friendships/entities/friendship.entity';
import { Message } from './messages/entities/message.entity';
import { News } from './news/entities/news.entity';
import { Notification } from './notifications/entities/notification.entity';
import { Comment } from './comments/entities/comment.entity';
import { Purchase } from './purchases/entities/purchase.entity';

import { UsersModule } from './users/users.module';
import { ShopModule } from './shop/shop.module';
import { PostsModule } from './posts/posts.module';
import { FriendshipsModule } from './friendships/friendships.module';
import { MessagesModule } from './messages/messages.module';
import { NewsModule } from './news/news.module';
import { NotificationsModule } from './notifications/notifications.module';
import { CommentsModule } from './comments/comments.module';
import { AuthModule } from './auth/auth.module';
import { AdminModule } from './admin/admin.module';
import { ChatModule } from './chat/chat.module';
// –£–¥–∞–ª–∏–ª–∏: import { ChatGateway } from './chat/chat.gateway';
import { VotesModule } from './votes/votes.module';
import { LinkCode } from './linking/entities/link-code.entity';
import { RanksModule } from './ranks/ranks.module';
import { Rank } from './ranks/entities/rank.entity';
import { PagesModule } from './pages/pages.module';
import { CustomPage } from './pages/entities/page.entity';

@Module({
  imports: [
    // –°–∏—Å—Ç–µ–º–Ω—ã–µ –º–æ–¥—É–ª–∏
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    EventEmitterModule.forRoot({
      global: true,
    }),
    TypeOrmModule.forRootAsync({
      name: 'default',
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get<string>('DB_HOST'),
        port: parseInt(configService.get<string>('DB_PORT') || '5432', 10),
        username: configService.get<string>('DB_USERNAME'),
        password: configService.get<string>('DB_PASSWORD'),
        database: configService.get<string>('DB_DATABASE'),
        entities: [
          User, ShopItem, Post, Friendship, Message, News, Notification, Comment, Purchase, LinkCode, Rank, CustomPage// <-- –î–û–ë–ê–í–õ–Ø–ï–ú –°–Æ–î–ê
        ],
        synchronize: false,
        autoLoadEntities: true,
      }),
    }),

    // –ú–æ–¥—É–ª–∏ –Ω–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    UsersModule,
    AuthModule,
    AdminModule,
    ChatModule,
    ShopModule,
    PostsModule,
    FriendshipsModule,
    MessagesModule,
    NewsModule,
    NotificationsModule,
    CommentsModule,
    VotesModule,
    MessagesModule,
    RanksModule,
    PagesModule
  ],
  controllers: [AppController],
  providers: [AppService], // <-- –£–¥–∞–ª–∏–ª–∏ ChatGateway –æ—Ç—Å—é–¥–∞
})
export class AppModule { }
--- END FILE: backend/src/app.module.ts ---



--- START FILE: backend/src/app.service.ts ---

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World';
  }
}

--- END FILE: backend/src/app.service.ts ---



--- START FILE: backend/src/auth/auth.controller.ts ---

// backend/src/auth/auth.controller.ts

import { Controller, Post, Body, UsePipes, ValidationPipe, Request, UseGuards, Get, HttpCode, HttpStatus, Logger } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto } from '../users/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { UsersService, PublicUser } from '../users/users.service';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { ChangePasswordDto } from './dto/change-password.dto'; // 

@ApiTags('Authentication & Profiles')
@Controller('auth')
export class AuthController {
  // --- –ù–û–í–û–ï: –î–æ–±–∞–≤–ª—è–µ–º Logger ---
  private readonly logger = new Logger(AuthController.name);

  constructor(
      private authService: AuthService,
      private usersService: UsersService, 
    ) {}

  @Post('register')
  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))
  async register(@Body() createUserDto: CreateUserDto) {
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[REGISTER] üìù New registration attempt for email: ${createUserDto.email}`);
    return this.authService.register(createUserDto); // 
  }

  @Post('login')
  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))
  async login(@Body() loginDto: LoginDto) {
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[LOGIN] ‚û°Ô∏è Login attempt for email: ${loginDto.email}`);
    return this.authService.login(loginDto); // 
  }

  @Get('profile') 
  @UseGuards(JwtAuthGuard) // 
  @ApiBearerAuth()
  async getProfile(@Request() req): Promise<PublicUser> {
    const userId = req.user.userId;
    return this.usersService.findOne(userId); // 
  }

  @Post('change-password')
  @UseGuards(JwtAuthGuard) // 
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  async changePassword(@Request() req, @Body() changePasswordDto: ChangePasswordDto) {
    const userId = req.user.userId;
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[PWD-CHANGE] üîë User ID: ${userId} is attempting to change password.`);
    return this.authService.changePassword(req.user.userId, changePasswordDto); // 
  }
}
--- END FILE: backend/src/auth/auth.controller.ts ---



--- START FILE: backend/src/auth/auth.module.ts ---

import { Module, Global } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './jwt.strategy';
// WsAuthGuard —É–¥–∞–ª–µ–Ω –∏–∑ –∏–º–ø–æ—Ä—Ç–æ–≤

@Global()
@Module({
  imports: [
    UsersModule,
    PassportModule,
    ConfigModule, 
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: configService.get<string>('JWT_EXPIRATION_TIME') },
      }),
    }),
  ],
  providers: [AuthService, JwtStrategy], // <-- WsAuthGuard —É–¥–∞–ª–µ–Ω –æ—Ç—Å—é–¥–∞
  controllers: [AuthController],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}
--- END FILE: backend/src/auth/auth.module.ts ---



--- START FILE: backend/src/auth/auth.service.ts ---

// backend/src/auth/auth.service.ts

import { Injectable, UnauthorizedException, ForbiddenException, Logger } from '@nestjs/common';
import { UsersService, PublicUser } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';
import { LoginDto } from './dto/login.dto';
import { CreateUserDto } from '../users/dto/create-user.dto'; 
import { User } from '../users/entities/user.entity';
import { ChangePasswordDto } from './dto/change-password.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  // --- –ù–û–í–û–ï: –î–æ–±–∞–≤–ª—è–µ–º Logger ---
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, pass: string): Promise<PublicUser | null> {
    const user: User | null = await this.usersService.findOneWithPasswordByEmail(email); // 
    
    if (!user) return null;

    if (user.is_banned) { // 
      // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
      this.logger.warn(`[LOGIN-BANNED] üö´ Banned User ID: ${user.id} (${email}) attempted to log in.`);
      throw new ForbiddenException('This account has been banned.'); // 
    }
    
    if (await user.validatePassword(pass)) { // 
      const { password_hash, validatePassword, ...publicData } = user;
      return publicData as PublicUser; // 
    }
    return null;
  }

  async login(loginDto: LoginDto) {
    const userPayload: PublicUser | null = await this.validateUser(loginDto.email, loginDto.password); // 
    
    if (!userPayload) {
      // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
      this.logger.warn(`[LOGIN-FAIL] ‚ùå Failed login attempt for email: ${loginDto.email}. Invalid credentials.`);
      throw new UnauthorizedException('Invalid credentials'); // 
    }
    
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[LOGIN-SUCCESS] ‚úÖ User ${userPayload.username} (ID: ${userPayload.id}) logged in successfully.`);
    
    const jwtTokenPayload = { username: userPayload.username, sub: userPayload.id, rank: userPayload.rank }; // 
    return {
      access_token: this.jwtService.sign(jwtTokenPayload), // 
      user: userPayload 
    };
  }

  async register(createUserDto: CreateUserDto): Promise<PublicUser> {
    const newUser = await this.usersService.create(createUserDto); // 
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[REGISTER-SUCCESS] ‚úÖ User ${newUser.username} successfully registered with ID: ${newUser.id}`);
    return newUser;
  }

  async changePassword(userId: number, changePasswordDto: ChangePasswordDto): Promise<void> {
    const user = await this.usersService.findOneWithPasswordById(userId); // 
    if (!user) {
        this.logger.error(`[PWD-CHANGE-FAIL] ‚ùå Attempted to change password for non-existent User ID: ${userId}`);
        throw new ForbiddenException('User not found.'); // 
    }

    const isPasswordMatching = await bcrypt.compare(
        changePasswordDto.currentPassword,
        user.password_hash,
    ); // 

    if (!isPasswordMatching) {
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
        this.logger.warn(`[PWD-CHANGE-FAIL] ‚ùå User ID: ${userId} failed to change password due to incorrect current password.`);
        throw new UnauthorizedException('Wrong current password.'); // 
    }

    const newHashedPassword = await bcrypt.hash(changePasswordDto.newPassword, 10); // 
    
    await this.usersService.updatePassword(userId, newHashedPassword); // 
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[PWD-CHANGE-SUCCESS] ‚úÖ User ID: ${userId} successfully updated their password.`);
  }
}
--- END FILE: backend/src/auth/auth.service.ts ---



--- START FILE: backend/src/auth/decorators/roles.decorator.ts ---

// backend/src/auth/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'power_level';
export const Roles = (powerLevel: number) => SetMetadata(ROLES_KEY, powerLevel);
--- END FILE: backend/src/auth/decorators/roles.decorator.ts ---



--- START FILE: backend/src/auth/dto/change-password.dto.ts ---

import { IsString, MinLength } from 'class-validator';

export class ChangePasswordDto {
  @IsString()
  @MinLength(8, { message: 'Current password must be at least 8 characters long' })
  currentPassword: string;

  @IsString()
  @MinLength(8, { message: 'New password must be at least 8 characters long' })
  newPassword: string;
}
--- END FILE: backend/src/auth/dto/change-password.dto.ts ---



--- START FILE: backend/src/auth/dto/login.dto.ts ---

import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
  @ApiProperty({ example: 'user@example.com', description: 'User email address for login' })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({ example: 'SecurePassword123!', description: 'User password for login' })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string; 
}
--- END FILE: backend/src/auth/dto/login.dto.ts ---



--- START FILE: backend/src/auth/guards/jwt-auth.guard.ts ---

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
--- END FILE: backend/src/auth/guards/jwt-auth.guard.ts ---



--- START FILE: backend/src/auth/guards/optional-jwt-auth.guard.ts ---

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class OptionalJwtAuthGuard extends AuthGuard('jwt') {
  /**
   * –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ AuthGuard.
   * –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω –µ—Å—Ç—å –∏ –æ–Ω –≤–∞–ª–∏–¥–µ–Ω, `user` –±—É–¥–µ—Ç –æ–±—ä–µ–∫—Ç–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
   * –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω–∞ –Ω–µ—Ç –∏–ª–∏ –æ–Ω –Ω–µ–≤–∞–ª–∏–¥–µ–Ω, –º–µ—Ç–æ–¥ –Ω–µ –±—É–¥–µ—Ç –≤—ã–±—Ä–∞—Å—ã–≤–∞—Ç—å –æ—à–∏–±–∫—É 401,
   * –∞ –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω–µ—Ç `null` (–∏–ª–∏ `false` –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç Passport),
   * –∏ `req.user` –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ –±—É–¥–µ—Ç `undefined`.
   */
  handleRequest(err, user, info, context) {
    return user;
  }
}
--- END FILE: backend/src/auth/guards/optional-jwt-auth.guard.ts ---



--- START FILE: backend/src/auth/guards/plugin-api-key.guard.ts ---

// backend/src/auth/guards/plugin-api-key.guard.ts

import { Injectable, CanActivate, ExecutionContext, UnauthorizedException, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Observable } from 'rxjs';

@Injectable()
export class PluginApiKeyGuard implements CanActivate {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(PluginApiKeyGuard.name);

  constructor(private readonly configService: ConfigService) {}

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    const providedKey = request.headers['x-api-key'];
    const validKey = this.configService.get<string>('PLUGIN_SECRET_KEY');

    if (!providedKey || providedKey !== validKey) {
      // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
      this.logger.warn(`[DENIED] üö´ Plugin access denied from IP: ${request.ip}. Reason: Invalid or missing API key.`);
      throw new UnauthorizedException('Invalid or missing API key for plugin');
    }

    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ (–Ω–∞ —É—Ä–æ–≤–Ω–µ verbose, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å –≤ –∫–æ–Ω—Å–æ–ª–∏) ---
    this.logger.verbose(`[GRANTED] üîå Plugin access granted to IP: ${request.ip}.`);
    return true;
  }
}
--- END FILE: backend/src/auth/guards/plugin-api-key.guard.ts ---



--- START FILE: backend/src/auth/guards/roles.guard.ts ---

// backend/src/auth/guards/roles.guard.ts

import { Injectable, CanActivate, ExecutionContext, Logger } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(RolesGuard.name);

  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPowerLevel = this.reflector.getAllAndOverride<number>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (!requiredPowerLevel) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    const hasPermission = user && user.rank && user.rank.power_level >= requiredPowerLevel;

    if (!hasPermission) {
      // --- –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–∫–∞–∑ –≤ –¥–æ—Å—Ç—É–ø–µ –ø–æ —É—Ä–æ–≤–Ω—é –ø—Ä–∞–≤ ---
      this.logger.warn(`[ROLES-DENIED] üö´ User ID: ${user?.userId} (Power: ${user?.rank?.power_level}) denied access to a resource requiring Power Level: ${requiredPowerLevel}.`);
    }

    return hasPermission;
  }
}
--- END FILE: backend/src/auth/guards/roles.guard.ts ---



--- START FILE: backend/src/auth/guards/ws.guard.ts ---

import { CanActivate, Injectable } from '@nestjs/common';
import { Socket } from 'socket.io';

@Injectable()
export class WsGuard implements CanActivate {
  canActivate(context: any): boolean {
    const client: Socket = context.switchToWs().getClient();
    // –ü—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω –∫ —Å–æ–∫–µ—Ç—É —Ä–∞–Ω–µ–µ
    return !!client['user'];
  }
}
--- END FILE: backend/src/auth/guards/ws.guard.ts ---



--- START FILE: backend/src/auth/jwt.strategy.ts ---

// backend/src/auth/jwt.strategy.ts

import { Injectable, UnauthorizedException, InternalServerErrorException, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService, PublicUser } from '../users/users.service'; 
import { Rank } from '../ranks/entities/rank.entity';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(JwtStrategy.name);

  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
  ) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new InternalServerErrorException('JWT_SECRET is not defined in environment variables. Application cannot start.');
    }

    super({ 
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any): Promise<{ userId: number; username: string; rank: Rank | null }> {
    this.logger.verbose(`[VALIDATE] üïµÔ∏è‚Äç‚ôÇÔ∏è Validating JWT for user sub: ${payload.sub}`);
    const user: PublicUser | null = await this.usersService.findOne(payload.sub);
    
    if (!user) {
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
        this.logger.warn(`[VALIDATE-FAIL] ‚ùå JWT validation failed for user sub: ${payload.sub}. User not found in database.`);
        throw new UnauthorizedException('User not found or token invalid');
    }
    
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.verbose(`[VALIDATE-SUCCESS] ‚úÖ JWT validation successful for User ID: ${user.id} (${user.username}).`);
    return { userId: user.id, username: user.username, rank: user.rank };
  }
}
--- END FILE: backend/src/auth/jwt.strategy.ts ---



--- START FILE: backend/src/chat/chat.gateway.ts ---

// backend/src/chat/chat.gateway.ts

import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UseGuards, ValidationPipe, Inject, forwardRef } from '@nestjs/common';
import { MessagesService } from '../messages/messages.service';
import { WsGuard } from '../auth/guards/ws.guard';
import { User } from '../users/entities/user.entity';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import { Notification } from '../notifications/entities/notification.entity';
import { FriendshipsService } from 'src/friendships/friendships.service';
import { CreateMessageDto } from 'src/messages/dto/create-message.dto';
import { EditMessageDto } from 'src/messages/dto/edit-message.dto';
import { DeleteMessageDto } from 'src/messages/dto/delete-message.dto';
import { LinkingService } from 'src/linking/linking.service';
import { ConfigService } from '@nestjs/config';

// DTOs
class LinkAccountDto {
  code: string;
  minecraftUuid: string;
  minecraftUsername: string;
}

class PlayerStatusDto {
  minecraftUuid: string;
  isOnline: boolean;
}

class InGameMessageDto {
  senderUuid: string;
  recipientUsername: string;
  content: string;
}

@WebSocketGateway({ cors: { origin: '*' } })
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;
  private logger: Logger = new Logger('ChatGateway');
  private onlineUsers = new Map<number, string>();
  private currentlyViewing = new Map<number, number>();
  private readonly pluginSecretKey: string;

  constructor(
    private readonly messagesService: MessagesService,
    @Inject(forwardRef(() => UsersService)) // <-- –ò–ó–ú–ï–ù–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
    private readonly eventEmitter: EventEmitter2, // EventEmitter –Ω—É–∂–µ–Ω –¥–ª—è –¥—Ä—É–≥–æ–π –ª–æ–≥–∏–∫–∏, —Ç–∞–∫ —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º
    private readonly friendshipsService: FriendshipsService,
    private readonly linkingService: LinkingService,
    private readonly configService: ConfigService,
  ) {
    const key = this.configService.get<string>('PLUGIN_SECRET_KEY');
    if (!key) {
      throw new Error('PLUGIN_SECRET_KEY is not defined in .env file!');
    }
    this.pluginSecretKey = key;
  }

  async handleConnection(client: Socket) {
    const apiKey = client.handshake.headers['x-api-key'];
    if (apiKey && apiKey === this.pluginSecretKey) {
      client['isPlugin'] = true;
      client.join('minecraft-plugins');
      this.logger.log(`[CONNECT-PLUGIN] üîå Minecraft Plugin connected. Socket ID: ${client.id}`);
      return;
    }

    const token = client.handshake.auth.token;
    if (!token) {
      this.logger.warn(`[CONNECT-FAIL] üî¥ Client ${client.id} disconnected. Reason: No auth token provided.`);
      return client.disconnect();
    }
    try {
      const payload = this.jwtService.verify(token);
      const user = await this.usersService.findUserEntityById(payload.sub);

      if (!user) {
        this.logger.warn(`[CONNECT-FAIL] üî¥ Client ${client.id} disconnected. Reason: User not found for token sub ${payload.sub}.`);
        return client.disconnect();
      }
      if (user.is_banned) {
        this.logger.warn(`[CONNECT-FAIL] üö´ Banned User ID: ${user.id} (${user.username}) attempted to connect. Disconnecting.`);
        return client.disconnect();
      }

      client['user'] = user;
      client.join(`user-${user.id}`);
      this.onlineUsers.set(user.id, client.id);
      this.logger.log(`[CONNECT-USER] üü¢ User connected: ${user.username} (ID: ${user.id}). Socket ID: ${client.id}`);

    } catch (e) {
      this.logger.warn(`[CONNECT-FAIL] üî¥ Client ${client.id} disconnected. Reason: Invalid auth token. Error: ${e.message}`);
      return client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    if (client['isPlugin']) {
      this.logger.log(`[DISCONNECT-PLUGIN] üîå Minecraft Plugin disconnected. Socket ID: ${client.id}`);
      return;
    }
    const user: User = client['user'];
    if (user) {
      if (this.onlineUsers.get(user.id) === client.id) {
        this.onlineUsers.delete(user.id);
      }
      this.currentlyViewing.delete(user.id);
      this.logger.log(`[DISCONNECT-USER] üî¥ User disconnected: ${user.username} (ID: ${user.id}). Socket ID: ${client.id}`);
    } else {
      this.logger.verbose(`[DISCONNECT] ‚ùì An unknown client disconnected. Socket ID: ${client.id}`);
    }
  }

  @UseGuards(WsGuard)
  @SubscribeMessage('sendMessage')
  async handleMessage(
    @MessageBody(new ValidationPipe()) data: CreateMessageDto & { parentMessageId?: number },
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    const sender: User = client['user'];
    if (!sender) return;

    const recipient = await this.usersService.findUserEntityById(data.recipientId);
    if (!recipient) {
      this.logger.warn(`[MSG-FAIL] ‚ùå User ID ${sender.id} tried to message non-existent User ID ${data.recipientId}`);
      return;
    }

    this.logger.verbose(`[MSG-WEB] üí¨ Message attempt from web: User ID ${sender.id} -> User ID ${recipient.id}`);
    const areFriends = await this.friendshipsService.areTheyFriends(sender.id, recipient.id);
    if (!areFriends) {
      this.logger.warn(`[MSG-DENIED] üö´ Message denied between non-friends: ${sender.id} and ${recipient.id}.`);
      return;
    }

    const savedMessage = await this.messagesService.createMessage(sender, recipient, data.content, data.parentMessageId);
    if (!savedMessage) return;

    const recipientIsViewing = this.currentlyViewing.get(recipient.id) === sender.id;
    if (recipientIsViewing) {
      this.logger.verbose(`Recipient ${recipient.id} is viewing chat with ${sender.id}, skipping notification.`);
    } else if (sender.id !== recipient.id) {
      this.eventEmitter.emit('message.sent', { sender, recipient });
    }

    this.server.to(`user-${recipient.id}`).emit('newMessage', savedMessage);
    if (sender.id !== recipient.id) {
      this.server.to(`user-${sender.id}`).emit('newMessage', savedMessage);
    }

    if (recipient.is_minecraft_online && recipient.minecraft_uuid) {
      this.logger.verbose(`[MSG-FORWARD-GAME] üéÆ Forwarding message from web to in-game player ${recipient.minecraft_username}`);
      this.server.to('minecraft-plugins').emit('webPrivateMessage', {
        recipientUuid: recipient.minecraft_uuid,
        senderUsername: sender.minecraft_username || sender.username,
        content: data.content,
      });
    }
  }

  @SubscribeMessage('inGamePrivateMessage')
  async handleInGameMessage(
    @MessageBody() data: InGameMessageDto,
    @ConnectedSocket() client: Socket
  ): Promise<void> {
    if (!client['isPlugin']) return;
    this.logger.verbose(`[MSG-GAME] üéÆ Received in-game message: ${data.senderUuid} -> ${data.recipientUsername}`);

    const sender = await this.usersService.findUserByMinecraftUuid(data.senderUuid);
    const recipient = await this.usersService.findOneByMinecraftUsername(data.recipientUsername);

    if (!sender || !recipient) {
      this.logger.warn(`[MSG-GAME-FAIL] ‚ùå Could not deliver message from MC UUID ${data.senderUuid}. Sender or recipient not found.`);
      return;
    }

    const savedMessage = await this.messagesService.createMessage(sender, recipient, data.content);
    if (savedMessage) {
      const recipientIsViewing = this.currentlyViewing.get(recipient.id) === sender.id;
      if (!recipientIsViewing && sender.id !== recipient.id) {
        this.eventEmitter.emit('message.sent', { sender, recipient });
      }

      this.server.to(`user-${sender.id}`).emit('newMessage', savedMessage);
      this.server.to(`user-${recipient.id}`).emit('newMessage', savedMessage);

      if (recipient.is_minecraft_online && recipient.minecraft_uuid) {
        this.logger.verbose(`[MSG-FORWARD-GAME] üéÆ Forwarding message from ${sender.username} back to in-game player ${recipient.minecraft_username}`);
        this.server.to('minecraft-plugins').emit('webPrivateMessage', {
          recipientUuid: recipient.minecraft_uuid,
          senderUsername: sender.minecraft_username || sender.username,
          content: data.content,
        });
      }
    }
  }

  @UseGuards(WsGuard)
  @SubscribeMessage('editMessage')
  async handleEditMessage(
    @MessageBody(new ValidationPipe()) data: EditMessageDto,
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    const sender: User = client['user'];
    this.logger.verbose(`[MSG-EDIT] üìù User ID: ${sender.id} is editing message ID: ${data.messageId}`);
    try {
      const updatedMessage = await this.messagesService.updateMessage(sender.id, data.messageId, data.content);
      this.server.to(`user-${updatedMessage.sender_id}`).emit('messageEdited', updatedMessage);
      this.server.to(`user-${updatedMessage.receiver_id}`).emit('messageEdited', updatedMessage);
    } catch (error) {
      this.logger.error(`[MSG-EDIT-FAIL] ‚ùå User ID: ${sender.id} failed to edit message ID: ${data.messageId}`, error.stack);
      client.emit('error', { message: 'Failed to edit message.' });
    }
  }

  @UseGuards(WsGuard)
  @SubscribeMessage('deleteMessage')
  async handleDeleteMessage(
    @MessageBody(new ValidationPipe()) data: DeleteMessageDto,
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    const sender: User = client['user'];
    this.logger.log(`[MSG-DELETE] üóëÔ∏è User ID: ${sender.id} is deleting message ID: ${data.messageId}`);
    try {
      const deletedMessage = await this.messagesService.deleteMessage(sender.id, data.messageId);
      const payload = { messageId: deletedMessage.id };
      this.server.to(`user-${deletedMessage.sender_id}`).emit('messageDeleted', payload);
      this.server.to(`user-${deletedMessage.receiver_id}`).emit('messageDeleted', payload);
    } catch (error) {
      this.logger.error(`[MSG-DELETE-FAIL] ‚ùå User ID: ${sender.id} failed to delete message ID: ${data.messageId}`, error.stack);
      client.emit('error', { message: 'Failed to delete message.' });
    }
  }

  @UseGuards(WsGuard)
  @SubscribeMessage('startViewingChat')
  handleStartViewingChat(@MessageBody() data: { otherUserId: number }, @ConnectedSocket() client: Socket): void {
    const currentUser: User = client['user'];
    if (currentUser && data.otherUserId) {
      this.currentlyViewing.set(currentUser.id, data.otherUserId);
      this.logger.verbose(`[VIEW-START] üëÄ User ID: ${currentUser.id} started viewing chat with User ID: ${data.otherUserId}`);
    }
  }

  @UseGuards(WsGuard)
  @SubscribeMessage('stopViewingChat')
  handleStopViewingChat(@ConnectedSocket() client: Socket): void {
    const currentUser: User = client['user'];
    if (currentUser && this.currentlyViewing.has(currentUser.id)) {
      this.logger.verbose(`[VIEW-STOP] üôà User ID: ${currentUser.id} stopped viewing a chat.`);
      this.currentlyViewing.delete(currentUser.id);
    }
  }

  @SubscribeMessage('minecraftPlayerStatus')
  async handlePlayerStatus(
    @MessageBody() data: { minecraftUuid: string; isOnline: boolean },
    @ConnectedSocket() client: Socket
  ): Promise<void> {
    if (!client['isPlugin']) return;
    this.logger.log(`[MC-STATUS] üö¶ Player status update: UUID ${data.minecraftUuid} is now ${data.isOnline ? 'ONLINE' : 'OFFLINE'}`);
    await this.usersService.updateOnlineStatus(data.minecraftUuid, data.isOnline);
    this.server.emit('playerStatusUpdate', {
      uuid: data.minecraftUuid,
      isOnline: data.isOnline,
    });
  }

  @SubscribeMessage('linkAccount')
  async handleLinkAccount(@MessageBody() data: LinkAccountDto, @ConnectedSocket() client: Socket): Promise<void> {
    try {
      const linkedUser = await this.linkingService.verifyCodeAndLinkAccount(
        data.code,
        data.minecraftUuid,
        data.minecraftUsername,
      );
      this.logger.log(`[LINK-SUCCESS] ‚úÖ User ${linkedUser.username} (ID: ${linkedUser.id}) linked to MC Account: ${linkedUser.minecraft_username} (UUID: ${data.minecraftUuid})`);
      client.emit('linkStatus', { success: true, minecraftUuid: linkedUser.minecraft_uuid, websiteUsername: linkedUser.username });
      this.server.to(`user-${linkedUser.id}`).emit('linkStatus', { success: true, minecraftUsername: linkedUser.minecraft_username });
    } catch (error) {
      this.logger.warn(`[LINK-FAIL] ‚ùå Failed link attempt for MC UUID: ${data.minecraftUuid} with code: ${data.code}. Reason: ${error.message}`);
      client.emit('linkStatus', { success: false, minecraftUuid: data.minecraftUuid, error: error.message });
    }
  }

  @OnEvent('notification.created')
  handleNotificationCreated(payload: Notification) {
    if (payload && payload.user && payload.user.id) {
      const room = `user-${payload.user.id}`;
      this.logger.verbose(`[NOTIFY-PUSH] ‚ú® Pushing notification (Type: '${payload.type}') to User ID: ${payload.user.id}`);
      this.server.to(room).emit('newNotification', payload);
    } else {
      this.logger.warn(`[NOTIFY-FAIL] ‚ö†Ô∏è Received malformed notification event payload.`);
    }
  }

  @SubscribeMessage('player:sync-rank')
  async handleRankSync(
    @MessageBody() data: { minecraftUuid: string; rankName: string },
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    if (!client['isPlugin']) return;
    this.logger.log(`[RANK-SYNC] üîÑ Received rank sync from plugin. UUID: ${data.minecraftUuid}, Rank: ${data.rankName}`);
    await this.usersService.syncRankFromPlugin(data.minecraftUuid, data.rankName);
  }

  @OnEvent('friendship.requested.ingame')
  async handleFriendRequestIngame(payload: { requester: User, receiver: User, requestId: number }) {
    const { requester, receiver, requestId } = payload;
    const freshReceiver = await this.usersService.findById(receiver.id);

    if (!freshReceiver) {
      this.logger.error(`[FRIEND-REQ-FATAL] üî• User with ID ${receiver.id} NOT FOUND in friendship.requested.ingame event.`);
      return;
    }
    if (freshReceiver && freshReceiver.is_minecraft_online && freshReceiver.minecraft_uuid) {
      this.logger.log(`[FRIEND-REQ-GAME] üíå Pushing friend request from ${requester.username} to in-game player ${freshReceiver.username}`);
      this.server.to('minecraft-plugins').emit('incomingFriendRequest', {
        requesterName: requester.username,
        receiverUuid: freshReceiver.minecraft_uuid,
        requestId: requestId,
      });
    } else {
      this.logger.verbose(`[FRIEND-REQ-GAME] ‚û°Ô∏è Receiver ${receiver.username} is offline. Skipping in-game notification.`);
    }
  }
  @OnEvent('command.queued')
  handleCommandQueued() {
    this.logger.log(`[EVENT-GATEWAY] Caught 'command.queued' event. Pushing 'shop:new-command' to plugin...`);
    this.server.to('minecraft-plugins').emit('shop:new-command');
  }

  @SubscribeMessage('player:rank-changed-ingame')
  async handleRankChangedInGame(
    @MessageBody() data: { minecraftUuid: string; newRankSystemName: string },
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    if (!client['isPlugin']) return;
    this.logger.log(`[RANK-CHANGED-INGAME] üîÑ Plugin reported a manual rank change for UUID: ${data.minecraftUuid} to "${data.newRankSystemName}"`);
    // –ü–µ—Ä–µ–¥–∞—ë–º –¥–∞–Ω–Ω—ã–µ –≤ UsersService –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ë–î —Å–∞–π—Ç–∞
    await this.usersService.updateRankFromGameEvent(data.minecraftUuid, data.newRankSystemName);
  }

  
}
--- END FILE: backend/src/chat/chat.gateway.ts ---



--- START FILE: backend/src/chat/chat.module.ts ---

import { Module } from '@nestjs/common';
import { ChatGateway } from './chat.gateway';
import { MessagesModule } from '../messages/messages.module';
import { AuthModule } from '../auth/auth.module';
import { UsersModule } from '../users/users.module';
import { WsGuard } from '../auth/guards/ws.guard';
import { FriendshipsModule } from '../friendships/friendships.module';
import { LinkingModule } from '../linking/linking.module';

@Module({
  imports: [
    MessagesModule,
    AuthModule,
    UsersModule,
    FriendshipsModule,
    LinkingModule,
  ],
  providers: [ChatGateway, WsGuard],
  exports: [ChatGateway],
})
export class ChatModule {}
--- END FILE: backend/src/chat/chat.module.ts ---



--- START FILE: backend/src/chat/connection-lock.ts ---

// –≠—Ç–æ—Ç Set –±—É–¥–µ—Ç –æ–±—â–∏–º –¥–ª—è –≤—Å–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ –±—É–¥–µ—Ç –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—Ç—å –¥–≤–æ–π–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
export const processedSockets = new Set<string>();

// –≠—Ç–æ—Ç Set –±—É–¥–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å "–æ—Ç–ø–µ—á–∞—Ç–∫–∏" —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –∏—Ö –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
export const recentMessageSignatures = new Set<string>();
--- END FILE: backend/src/chat/connection-lock.ts ---



--- START FILE: backend/src/comments/comments.controller.ts ---

// backend/src/comments/comments.controller.ts

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Request,
  UseGuards,
  ParseIntPipe,
  Logger,
} from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { Comment } from './entities/comment.entity';

@ApiTags('Comments')
@Controller()
export class CommentsController {
  private readonly logger = new Logger(CommentsController.name);

  constructor(private readonly commentsService: CommentsService) {}

  @Post('posts/:postId/comments')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Add a comment to a post' })
  create(
    @Param('postId', ParseIntPipe) postId: number,
    @Body() createCommentDto: CreateCommentDto,
    @Request() req,
  ) {
    const authorId = req.user.userId;
    this.logger.log(`[CREATE] üí¨ User ID: ${authorId} is creating a comment on Post ID: ${postId}`);
    return this.commentsService.create(createCommentDto, authorId, postId);
  }

  @Get('posts/:postId/comments')
  @ApiOperation({ summary: 'Get all comments for a post' })
  findAllForPost(@Param('postId', ParseIntPipe) postId: number) {
    this.logger.verbose(`[GET-ALL] üîé Fetching all comments for Post ID: ${postId}`);
    return this.commentsService.findAllForPost(postId);
  }

  @Patch('comments/:id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update a comment' })
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommentDto: UpdateCommentDto,
    @Request() req,
  ) {
    const userId = req.user.userId;
    this.logger.log(`[UPDATE] üìù User ID: ${userId} is attempting to update Comment ID: ${id}`);
    return this.commentsService.update(id, updateCommentDto, userId);
  }

  @Delete('comments/:id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Delete a comment' })
  remove(@Param('id', ParseIntPipe) id: number, @Request() req) {
    const userId = req.user.userId;
    this.logger.warn(`[DELETE] üóëÔ∏è User ID: ${userId} is attempting to delete Comment ID: ${id}`);
    return this.commentsService.remove(id, userId);
  }
}
--- END FILE: backend/src/comments/comments.controller.ts ---



--- START FILE: backend/src/comments/comments.module.ts ---

import { Module } from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { Post } from '../posts/entities/post.entity';
import { User } from '../users/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Comment, Post, User])],
  controllers: [CommentsController],
  providers: [CommentsService],
})
export class CommentsModule {}
--- END FILE: backend/src/comments/comments.module.ts ---



--- START FILE: backend/src/comments/comments.service.ts ---

// backend/src/comments/comments.service.ts

import { Injectable, NotFoundException, ForbiddenException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Comment } from './entities/comment.entity';
import { Post } from '../posts/entities/post.entity';
import { User } from '../users/entities/user.entity';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { SystemRanks } from '../ranks/ranks.service';

@Injectable()
export class CommentsService {
  private readonly logger = new Logger(CommentsService.name);

  constructor(
    @InjectRepository(Comment)
    private commentsRepository: Repository<Comment>,
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async create(createCommentDto: CreateCommentDto, authorId: number, postId: number): Promise<Comment> {
    const author = await this.usersRepository.findOneBy({ id: authorId });
    if (!author) {
      this.logger.error(`[CREATE-FAIL] ‚ùå User with ID: ${authorId} not found. Cannot create comment.`);
      throw new ForbiddenException('User not found or not authorized.');
    }

    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      this.logger.warn(`[CREATE-FAIL] ‚ö†Ô∏è User ID: ${authorId} failed to comment. Reason: Post ID ${postId} not found.`);
      throw new NotFoundException(`Post with ID ${postId} not found.`);
    }

    const comment = this.commentsRepository.create({ ...createCommentDto, author, post });
    const savedComment = await this.commentsRepository.save(comment);
    this.logger.log(`[CREATE-SUCCESS] ‚úÖ User ID: ${authorId} created Comment ID: ${savedComment.id} on Post ID: ${postId}`);
    return savedComment;
  }

  async findAllForPost(postId: number): Promise<Comment[]> {
    return this.commentsRepository.find({
      where: { post_id: postId },
      relations: ['author'],
      order: { created_at: 'ASC' },
    });
  }

  async findOne(id: number): Promise<Comment> {
    const comment = await this.commentsRepository.findOneBy({ id });
    if (!comment) {
      this.logger.warn(`[GET-FAIL] ‚ö†Ô∏è Comment with ID ${id} not found.`);
      throw new NotFoundException(`Comment with ID ${id} not found.`);
    }
    return comment;
  }

  async update(id: number, updateCommentDto: UpdateCommentDto, userId: number): Promise<Comment> {
    const comment = await this.commentsRepository.findOne({ where: { id }, relations: ['author', 'author.rank'] });
    if (!comment) {
      this.logger.warn(`[UPDATE-FAIL] ‚ö†Ô∏è Attempt to update non-existent Comment ID: ${id} by User ID: ${userId}.`);
      throw new NotFoundException(`Comment with ID ${id} not found.`);
    }
    
    const user = await this.usersRepository.findOne({ where: { id: userId }, relations: ['rank'] });
    if (!user) {
      this.logger.error(`[UPDATE-FAIL] ‚ùå User performing update action not found. User ID: ${userId}`);
      throw new ForbiddenException('User performing the action not found.');
    }
    
    const isAuthor = comment.author_id === userId;
    const canManage = user.rank && user.rank.power_level >= SystemRanks.MODERATOR.power_level;

    if (!isAuthor && !canManage) {
      this.logger.warn(`[UPDATE-FORBIDDEN] üö´ User ID: ${userId} (Rank: ${user.rank?.name}) failed to update Comment ID: ${id}. Reason: Not author or moderator.`);
      throw new ForbiddenException('You are not authorized to update this comment.');
    }

    Object.assign(comment, updateCommentDto);
    const updatedComment = await this.commentsRepository.save(comment);
    this.logger.log(`[UPDATE-SUCCESS] ‚úÖ Comment ID: ${id} updated by User ID: ${userId}.`);
    return updatedComment;
  }

  async remove(id: number, userId: number): Promise<void> {
    const comment = await this.commentsRepository.findOne({ where: { id }, relations: ['author', 'author.rank'] });
    if (!comment) {
      this.logger.warn(`[DELETE-FAIL] ‚ö†Ô∏è Attempt to delete non-existent Comment ID: ${id} by User ID: ${userId}.`);
      throw new NotFoundException(`Comment with ID ${id} not found.`);
    }

    const user = await this.usersRepository.findOne({ where: { id: userId }, relations: ['rank'] });
    if (!user) {
      this.logger.error(`[DELETE-FAIL] ‚ùå User performing delete action not found. User ID: ${userId}`);
      throw new ForbiddenException('User performing the action not found.');
    }

    const isAuthor = comment.author_id === userId;
    const canManage = user.rank && user.rank.power_level >= SystemRanks.MODERATOR.power_level;

    if (!isAuthor && !canManage) {
      this.logger.warn(`[DELETE-FORBIDDEN] üö´ User ID: ${userId} (Rank: ${user.rank?.name}) failed to delete Comment ID: ${id}. Reason: Not author or moderator.`);
      throw new ForbiddenException('You are not authorized to delete this comment.');
    }

    await this.commentsRepository.remove(comment);
    this.logger.warn(`[DELETE-SUCCESS] üóëÔ∏è Comment ID: ${id} was deleted by User ID: ${userId}.`);
  }
}
--- END FILE: backend/src/comments/comments.service.ts ---



--- START FILE: backend/src/comments/dto/create-comment.dto.ts ---

import { IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateCommentDto {
  @ApiProperty({
    example: 'Great post! I totally agree.',
    description: 'The content of the comment',
    minLength: 1,
    maxLength: 1000,
  })
  @IsNotEmpty({ message: 'Comment content cannot be empty.' })
  @IsString()
  @MinLength(1)
  @MaxLength(1000)
  content: string;
}
--- END FILE: backend/src/comments/dto/create-comment.dto.ts ---



--- START FILE: backend/src/comments/dto/update-comment.dto.ts ---

import { IsOptional, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';

export class UpdateCommentDto {
  @ApiPropertyOptional({
    example: 'Actually, I changed my mind. Great post!',
    description: 'The updated content of the comment',
    minLength: 1,
    maxLength: 1000,
  })
  @IsOptional()
  @IsString()
  @MinLength(1)
  @MaxLength(1000)
  content?: string;
}
--- END FILE: backend/src/comments/dto/update-comment.dto.ts ---



--- START FILE: backend/src/comments/entities/comment.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany, // <-- –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ OneToMany –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
// --- –î–û–ë–ê–í–õ–ï–ù–û: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Å—É—â–Ω–æ—Å—Ç—å Vote ---
import { Vote } from '../../votes/entities/vote.entity';

@Entity('comments')
export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 1000 })
  content: string;

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updated_at: Date;

  @Column({ name: 'author_id', nullable: true })
  author_id: number | null;

  @ManyToOne(() => User, (user) => user.comments, {
    onDelete: 'SET NULL',
    nullable: true,
  })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Column({ name: 'post_id' })
  post_id: number;

  @ManyToOne(() => Post, (post) => post.comments, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'post_id' })
  post: Post;

  // --- –î–û–ë–ê–í–õ–ï–ù–û: –°–≤—è–∑—å —Å –≥–æ–ª–æ—Å–∞–º–∏, –æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –∑–∞ —ç—Ç–æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π ---
  @OneToMany(() => Vote, (vote) => vote.comment)
  votes: Vote[];
}
--- END FILE: backend/src/comments/entities/comment.entity.ts ---



--- START FILE: backend/src/common/enums/friend-statuses.enum.ts ---

export enum FriendStatuses {
  PENDING = 'PENDING',
  ACCEPTED = 'ACCEPTED',
  BLOCKED = 'BLOCKED',
}
--- END FILE: backend/src/common/enums/friend-statuses.enum.ts ---



--- START FILE: backend/src/common/enums/ranks.enum.ts ---

export enum Ranks {
  DEFAULT = 'DEFAULT',
  MOON = 'MOON',
  NOVA = 'NOVA',
  SUPERNOVA = 'SUPERNOVA',
  QUASAR = 'QUASAR',
  MODERATOR = 'MODERATOR',
  ADMIN = 'ADMIN',
  OWNER = 'OWNER',
}
--- END FILE: backend/src/common/enums/ranks.enum.ts ---



--- START FILE: backend/src/data-source.ts ---

import 'reflect-metadata';
import { DataSource } from 'typeorm';
import * as dotenv from 'dotenv';
import { User } from './users/entities/user.entity';
import { ShopItem } from './shop/entities/shop-item.entity';
import { Post } from './posts/entities/post.entity';
import { Friendship } from './friendships/entities/friendship.entity';
import { Message } from './messages/entities/message.entity';
import { News } from './news/entities/news.entity';
import { Notification } from './notifications/entities/notification.entity';
import { Comment } from './comments/entities/comment.entity';
import { Purchase } from './purchases/entities/purchase.entity';
import { LinkCode } from './linking/entities/link-code.entity';
import { Rank } from './ranks/entities/rank.entity';
import { Vote } from './votes/entities/vote.entity';
import { PendingCommand } from './shop/entities/pending-command.entity';

dotenv.config({ path: '.env' });

export const AppDataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432', 10),
    username: process.env.DB_USERNAME,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE,
    synchronize: false,
    logging: true,
    entities: [__dirname + '/**/*.entity{.ts,.js}'], // –£–ª—É—á—à–∏–º –∏ –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–µ–π
    migrations: [__dirname + '/migrations/*{.ts,.js}'],
    subscribers: [],
});
--- END FILE: backend/src/data-source.ts ---



--- START FILE: backend/src/friendships/dto/create-friend-request.dto.ts ---

import { IsInt, IsNotEmpty, IsPositive } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateFriendRequestDto {
  @ApiProperty({
    example: 5,
    description: 'The ID of the user to whom the friend request is being sent',
  })
  @IsNotEmpty()
  @IsInt()
  @IsPositive()
  receiverId: number;
}
--- END FILE: backend/src/friendships/dto/create-friend-request.dto.ts ---



--- START FILE: backend/src/friendships/dto/from-plugin-add-friend.dto.ts ---

import { IsString, IsUUID } from 'class-validator';

export class FromPluginAddFriendDto {
  @IsUUID()
  requesterUuid: string;

  @IsString()
  receiverName: string;
}
--- END FILE: backend/src/friendships/dto/from-plugin-add-friend.dto.ts ---



--- START FILE: backend/src/friendships/dto/from-plugin-remove-friend.dto.ts ---

import { IsString, IsUUID } from 'class-validator';

export class FromPluginRemoveFriendDto {
  @IsUUID()
  removerUuid: string;

  @IsString()
  friendToRemoveName: string;
}
--- END FILE: backend/src/friendships/dto/from-plugin-remove-friend.dto.ts ---



--- START FILE: backend/src/friendships/dto/from-plugin-respond-request.dto.ts ---

import { IsInt, IsNotEmpty, IsUUID } from 'class-validator';

export class FromPluginRespondRequestDto {
  @IsUUID()
  @IsNotEmpty()
  responderUuid: string; // UUID —Ç–æ–≥–æ, –∫—Ç–æ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å

  @IsInt()
  @IsNotEmpty()
  requestId: number; // ID —Å–∞–º–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –¥—Ä—É–∂–±—É
}
--- END FILE: backend/src/friendships/dto/from-plugin-respond-request.dto.ts ---



--- START FILE: backend/src/friendships/entities/friendship.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { FriendStatuses } from '../../common/enums/friend-statuses.enum';

@Entity('friendships')
@Index(['requester_id', 'receiver_id'], { unique: true }) 
export class Friendship {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'requester_id' })
  requester_id: number;

  @ManyToOne(() => User, (user) => user.sent_friend_requests, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'requester_id' })
  requester: User;

  @Column({ name: 'receiver_id' })
  receiver_id: number;

  @ManyToOne(() => User, (user) => user.received_friend_requests, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'receiver_id' })
  receiver: User;

  @Column({
    type: 'enum',
    enum: FriendStatuses,
    default: FriendStatuses.PENDING,
  })
  status: FriendStatuses;

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updated_at: Date;
}
--- END FILE: backend/src/friendships/entities/friendship.entity.ts ---



--- START FILE: backend/src/friendships/friendships.controller.ts ---

// backend/src/friendships/friendships.controller.ts

import { Controller, Get, Post, Body, Param, Delete, UseGuards, Request, ParseIntPipe, Patch, Logger } from '@nestjs/common';
import { FriendshipsService } from './friendships.service';
import { CreateFriendRequestDto } from './dto/create-friend-request.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';

@ApiTags('Friendships')
@Controller('friendships')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class FriendshipsController {
  private readonly logger = new Logger(FriendshipsController.name);

  constructor(private readonly friendshipsService: FriendshipsService) { }

  @Post('requests')
  @ApiOperation({ summary: 'Send a friend request' })
  sendRequest(@Body() createDto: CreateFriendRequestDto, @Request() req) {
    const actorId = req.user.userId;
    this.logger.log(`[REQ-SEND] üíå User ID: ${actorId} is sending a friend request to Receiver ID: ${createDto.receiverId}`);
    return this.friendshipsService.sendRequest(actorId, createDto.receiverId);
  }

  @Get('requests/pending')
  @ApiOperation({ summary: 'Get my pending incoming friend requests' })
  getPendingRequests(@Request() req) {
    this.logger.verbose(`[GET] üîé User ID: ${req.user.userId} is fetching pending requests.`);
    return this.friendshipsService.getPendingRequests(req.user.userId);
  }

  @Patch('requests/:id/accept')
  @ApiOperation({ summary: 'Accept a friend request' })
  acceptRequest(@Param('id', ParseIntPipe) id: number, @Request() req) {
    const actorId = req.user.userId;
    this.logger.log(`[REQ-ACCEPT] ‚úÖ User ID: ${actorId} is accepting friend request ID: ${id}`);
    return this.friendshipsService.acceptRequest(id, actorId);
  }

  @Delete('requests/:id')
  @ApiOperation({ summary: 'Reject an incoming request or cancel an outgoing request' })
  rejectOrCancelRequest(@Param('id', ParseIntPipe) id: number, @Request() req) {
    const actorId = req.user.userId;
    this.logger.warn(`[REQ-REJECT/CANCEL] ‚ùå User ID: ${actorId} is rejecting/canceling request ID: ${id}`);
    return this.friendshipsService.rejectOrCancelRequest(id, actorId);
  }

  @Get()
  @ApiOperation({ summary: 'Get my friends list' })
  listFriends(@Request() req) {
    this.logger.verbose(`[GET] üîé User ID: ${req.user.userId} is fetching their friends list.`);
    return this.friendshipsService.listFriends(req.user.userId);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Remove a friend by friendship ID' })
  removeFriend(@Param('id', ParseIntPipe) id: number, @Request() req) {
    const actorId = req.user.userId;
    this.logger.warn(`[REMOVE] üóëÔ∏è User ID: ${actorId} is removing friendship ID: ${id}`);
    return this.friendshipsService.removeFriend(id, actorId);
  }

  @Get('status/:identifier')
  @ApiOperation({ summary: 'Check friendship status with another user' })
  getFriendshipStatus(@Param('identifier') identifier: string, @Request() req) {
    return this.friendshipsService.getFriendshipStatus(req.user.userId, identifier);
  }

  @Post('block/:userToBlockId')
  @ApiOperation({ summary: 'Block a user' })
  blockUser(@Param('userToBlockId', ParseIntPipe) userToBlockId: number, @Request() req) {
    const actorId = req.user.userId;
    this.logger.warn(`[BLOCK] üö´ User ID: ${actorId} is blocking User ID: ${userToBlockId}`);
    return this.friendshipsService.blockUser(actorId, userToBlockId);
  }

  @Delete('block/:userToUnblockId')
  @ApiOperation({ summary: 'Unblock a user' })
  unblockUser(@Param('userToUnblockId', ParseIntPipe) userToUnblockId: number, @Request() req) {
    const actorId = req.user.userId;
    this.logger.log(`[UNBLOCK] ‚úÖ User ID: ${actorId} is unblocking User ID: ${userToUnblockId}`);
    return this.friendshipsService.unblockUser(actorId, userToUnblockId);
  }

  @Get('requests/outgoing')
  @ApiOperation({ summary: 'Get my pending outgoing friend requests' })
  getOutgoingRequests(@Request() req) {
    return this.friendshipsService.getOutgoingRequests(req.user.userId);
  }

  @Get('blocked')
  @ApiOperation({ summary: 'Get my blocked users list' })
  listBlockedUsers(@Request() req) {
    return this.friendshipsService.listBlockedUsers(req.user.userId);
  }
}
--- END FILE: backend/src/friendships/friendships.controller.ts ---



--- START FILE: backend/src/friendships/friendships.module.ts ---

// backend/friendships/friendships.module.ts
import { Module } from '@nestjs/common';
import { FriendshipsService } from './friendships.service';
import { FriendshipsController } from './friendships.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Friendship } from './entities/friendship.entity';
import { User } from '../users/entities/user.entity';
import { FriendshipsPluginController } from './friendships.plugin.controller';
import { PluginApiKeyGuard } from '../auth/guards/plugin-api-key.guard';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([Friendship, User]),
    UsersModule,
  ],
  controllers: [FriendshipsController, FriendshipsPluginController],
  providers: [FriendshipsService, PluginApiKeyGuard],
  exports: [FriendshipsService],
})
export class FriendshipsModule {}
--- END FILE: backend/src/friendships/friendships.module.ts ---



--- START FILE: backend/src/friendships/friendships.plugin.controller.ts ---

// backend/src/friendships/friendships.plugin.controller.ts

import { Controller, Post, Body, UseGuards, Delete, Get, Param, ValidationPipe, Logger } from '@nestjs/common';
import { ApiTags, ApiHeader } from '@nestjs/swagger';
import { FriendshipsService } from './friendships.service';
import { PluginApiKeyGuard } from '../auth/guards/plugin-api-key.guard';
import { FromPluginAddFriendDto } from './dto/from-plugin-add-friend.dto';
import { FromPluginRemoveFriendDto } from './dto/from-plugin-remove-friend.dto';
import { FromPluginRespondRequestDto } from './dto/from-plugin-respond-request.dto';

@ApiTags('Plugin Bridge')
@Controller('friendships/from-plugin')
@UseGuards(PluginApiKeyGuard)
@ApiHeader({
  name: 'x-api-key',
  description: 'The secret API key for the Minecraft plugin',
  required: true,
})
export class FriendshipsPluginController {
  private readonly logger = new Logger(FriendshipsPluginController.name);

  constructor(private readonly friendshipsService: FriendshipsService) {}

  @Post('add')
  addFriendFromPlugin(@Body(new ValidationPipe()) dto: FromPluginAddFriendDto) {
    this.logger.log(`[PLUGIN-REQ-SEND] üîå Plugin initiated friend request from UUID: ${dto.requesterUuid} to Receiver Name: ${dto.receiverName}`);
    return this.friendshipsService.sendRequestFromPlugin(dto.requesterUuid, dto.receiverName);
  }

  @Delete('remove')
  removeFriendFromPlugin(@Body(new ValidationPipe()) dto: FromPluginRemoveFriendDto) {
    this.logger.warn(`[PLUGIN-REMOVE] üîå Plugin initiated friend removal by UUID: ${dto.removerUuid} of friend: ${dto.friendToRemoveName}`);
    return this.friendshipsService.removeFriendFromPlugin(dto.removerUuid, dto.friendToRemoveName);
  }

  @Get('list/:uuid')
  listFriendsForPlugin(@Param('uuid') uuid: string): Promise<string[]> {
    this.logger.verbose(`[PLUGIN-LIST] üîå Plugin requested friend list for UUID: ${uuid}`);
    return this.friendshipsService.listFriendsForPlugin(uuid);
  }

  @Post('accept')
  acceptRequestFromPlugin(@Body(new ValidationPipe()) dto: FromPluginRespondRequestDto) {
    this.logger.log(`[PLUGIN-REQ-ACCEPT] üîå Plugin initiated request acceptance by UUID: ${dto.responderUuid} for request ID: ${dto.requestId}`);
    return this.friendshipsService.acceptRequestFromPlugin(dto.responderUuid, dto.requestId);
  }

  @Post('deny')
  denyRequestFromPlugin(@Body(new ValidationPipe()) dto: FromPluginRespondRequestDto) {
    this.logger.warn(`[PLUGIN-REQ-DENY] üîå Plugin initiated request denial by UUID: ${dto.responderUuid} for request ID: ${dto.requestId}`);
    return this.friendshipsService.rejectRequestFromPlugin(dto.responderUuid, dto.requestId);
  }
}
--- END FILE: backend/src/friendships/friendships.plugin.controller.ts ---



--- START FILE: backend/src/friendships/friendships.service.ts ---

// backend/src/friendships/friendships.service.ts

import { Injectable, NotFoundException, ForbiddenException, ConflictException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, Repository, Not } from 'typeorm';
import { Friendship } from './entities/friendship.entity';
import { User } from '../users/entities/user.entity';
import { FriendStatuses } from '../common/enums/friend-statuses.enum';
import { PublicUser, UsersService } from '../users/users.service';
import { EventEmitter2 } from '@nestjs/event-emitter';

export type FriendWithFriendshipId = {
  friendshipId: number;
  user: PublicUser;
}

@Injectable()
export class FriendshipsService {
  private readonly logger = new Logger(FriendshipsService.name);

  constructor(
    @InjectRepository(Friendship)
    private friendshipsRepository: Repository<Friendship>,
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    private eventEmitter: EventEmitter2,
  //  private readonly usersService: UsersService,
  ) { }

  async sendRequest(requesterId: number, receiverId: number): Promise<Friendship> {
    if (requesterId === receiverId) {
      this.logger.warn(`[REQ-SEND-FAIL] ‚ö†Ô∏è User ID: ${requesterId} tried to send a friend request to themselves.`);
      throw new ForbiddenException('You cannot send a friend request to yourself.');
    }

    const [requester, receiver] = await Promise.all([
      this.usersRepository.findOneBy({ id: requesterId }),
      this.usersRepository.findOneBy({ id: receiverId }),
    ]);

    if (!receiver || !requester) {
      this.logger.error(`[REQ-SEND-FAIL] ‚ùå User not found. Requester: ${requesterId}, Receiver: ${receiverId}`);
      throw new NotFoundException(`User not found.`);
    }

    const existingFriendship = await this.friendshipsRepository.findOne({
      where: [
        { requester_id: requesterId, receiver_id: receiverId },
        { requester_id: receiverId, receiver_id: requesterId },
      ],
    });

    if (existingFriendship) {
      this.logger.warn(`[REQ-SEND-FAIL] ‚ö†Ô∏è Conflict: Friendship/request already exists between User ID: ${requesterId} and User ID: ${receiverId}.`);
      throw new ConflictException('A friendship request already exists or you are already friends.');
    }

    const newRequest = this.friendshipsRepository.create({ requester_id: requesterId, receiver_id: receiverId, status: FriendStatuses.PENDING });
    const savedRequest = await this.friendshipsRepository.save(newRequest);

    this.logger.log(`[REQ-SEND-SUCCESS] ‚úÖ User ID: ${requesterId} sent a friend request to User ID: ${receiverId}. Friendship ID: ${savedRequest.id}`);
    this.eventEmitter.emit('friendship.requested.ingame', { requester: requester, receiver: receiver, requestId: savedRequest.id } );
    
    return savedRequest;
  }

  async getPendingRequests(userId: number): Promise<Friendship[]> {
    this.logger.verbose(`[GET] üîé Fetching pending friend requests for User ID: ${userId}`);
    return this.friendshipsRepository.find({
      where: { receiver_id: userId, status: FriendStatuses.PENDING },
      relations: ['requester'],
    });
  }

  async acceptRequest(requestId: number, currentUserId: number): Promise<Friendship> {
    const request = await this.friendshipsRepository.findOne({
      where: { id: requestId, receiver_id: currentUserId, status: FriendStatuses.PENDING },
      relations: ['requester', 'receiver'],
    });

    if (!request) {
      this.logger.warn(`[REQ-ACCEPT-FAIL] ‚ö†Ô∏è User ID: ${currentUserId} tried to accept non-existent or invalid request ID: ${requestId}.`);
      throw new NotFoundException(`Pending request with ID ${requestId} not found for you.`);
    }

    request.status = FriendStatuses.ACCEPTED;
    this.logger.log(`[REQ-ACCEPT-SUCCESS] ‚úÖ User ID: ${currentUserId} accepted request ID: ${requestId} from User ID: ${request.requester_id}.`);
    this.eventEmitter.emit('friendship.accepted', { requester: request.requester, receiver: request.receiver } );
    
    return this.friendshipsRepository.save(request);
  }

  async rejectOrCancelRequest(requestId: number, currentUserId: number): Promise<void> {
    const request = await this.friendshipsRepository.findOne({ where: { id: requestId }});
    if (!request) { 
        this.logger.warn(`[REJECT/CANCEL-FAIL] ‚ö†Ô∏è Request ID: ${requestId} not found for User ID: ${currentUserId}.`);
        throw new NotFoundException(`Request with ID ${requestId} not found.`);
    }
    if (request.receiver_id !== currentUserId && request.requester_id !== currentUserId) { 
        this.logger.error(`[REJECT/CANCEL-FORBIDDEN] üö´ User ID: ${currentUserId} is not authorized to manage request ID: ${requestId}.`);
        throw new ForbiddenException('You are not authorized to manage this request.');
    }
    await this.friendshipsRepository.remove(request);
    this.logger.warn(`[REJECT/CANCEL-SUCCESS] üóëÔ∏è Request ID: ${requestId} was removed by User ID: ${currentUserId}.`);
  }

  async removeFriend(friendshipId: number, currentUserId: number): Promise<void> {
    const friendship = await this.friendshipsRepository.findOneBy({ id: friendshipId, status: FriendStatuses.ACCEPTED });
    if (!friendship) { 
        this.logger.warn(`[REMOVE-FAIL] ‚ö†Ô∏è Friendship ID ${friendshipId} not found or not in ACCEPTED state for User ID: ${currentUserId}.`);
        throw new NotFoundException(`Friendship with ID ${friendshipId} not found.`);
    }
    if (friendship.receiver_id !== currentUserId && friendship.requester_id !== currentUserId) { 
        this.logger.error(`[REMOVE-FORBIDDEN] üö´ User ID: ${currentUserId} is not part of friendship ID: ${friendshipId}.`);
        throw new ForbiddenException('You are not part of this friendship.');
    }
    await this.friendshipsRepository.remove(friendship);
    this.logger.warn(`[REMOVE-SUCCESS] üóëÔ∏è Friendship ID: ${friendshipId} was removed by User ID: ${currentUserId}.`);
  }

  async listFriends(userId: number): Promise<FriendWithFriendshipId[]> {
    this.logger.verbose(`[GET] üîé Fetching friends list for User ID: ${userId}`);
    const friendships = await this.friendshipsRepository.find({ where: [{ requester_id: userId, status: FriendStatuses.ACCEPTED }, { receiver_id: userId, status: FriendStatuses.ACCEPTED }], relations: ['requester', 'receiver'] });
    return friendships.map(friendship => {
      const friendUserEntity = friendship.requester_id === userId ? friendship.receiver : friendship.requester;
      const { password_hash, validatePassword, deleted_at, ...publicFriendData } = friendUserEntity;
      return { friendshipId: friendship.id, user: publicFriendData as PublicUser };
    });
  }

  async getFriendshipStatus(currentUserId: number, otherUserIdentifier: string | number) {
    this.logger.verbose(`[CHECK] üïµÔ∏è Checking friendship status between User ID: ${currentUserId} and Identifier: ${otherUserIdentifier}`);
      // –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ê–ï–ú –õ–û–ì–ò–ö–£, –ó–ê–í–ò–°–Ø–©–£–Æ –û–¢ USERSERVICE
    /*
    const otherUser = await this.usersService.findOne(otherUserIdentifier);
    if (!otherUser) {
      this.logger.warn(`[STATUS-FAIL] ‚ö†Ô∏è Could not check status. User with identifier '${otherUserIdentifier}' not found.`);
      throw new NotFoundException(`User with identifier '${otherUserIdentifier}' not found.`);
    }
    const otherUserId = otherUser.id;
    */
    // –í–ú–ï–°–¢–û –ù–ï–Å –í–†–ï–ú–ï–ù–ù–ê–Ø –ó–ê–ì–õ–£–®–ö–ê, –ß–¢–û–ë–´ –ö–û–î –ö–û–ú–ü–ò–õ–ò–†–û–í–ê–õ–°–Ø
    const otherUserId = typeof otherUserIdentifier === 'number' ? otherUserIdentifier : parseInt(otherUserIdentifier, 10);
    if(isNaN(otherUserId)) throw new NotFoundException('Identifier is not a valid user ID for this test.');
  
    const friendship = await this.friendshipsRepository.findOne({
      where: [
        { requester_id: currentUserId, receiver_id: otherUserId },
        { requester_id: otherUserId, receiver_id: currentUserId }
      ]
    });
    
    if (!friendship) return { status: 'none' };
    if (friendship.status === FriendStatuses.PENDING) {
      return friendship.requester_id === currentUserId 
        ? { status: 'pending_outgoing', requestId: friendship.id } 
        : { status: 'pending_incoming', requestId: friendship.id };
    }
    return { status: friendship.status, friendshipId: friendship.id };
  }

  async blockUser(requesterId: number, userToBlockId: number): Promise<Friendship> {
    if (requesterId === userToBlockId) { 
        this.logger.warn(`[BLOCK-FAIL] ‚ö†Ô∏è User ID: ${requesterId} tried to block themselves.`);
        throw new ForbiddenException('You cannot block yourself.'); 
    }
    let friendship = await this.friendshipsRepository.findOne({ where: [{ requester_id: requesterId, receiver_id: userToBlockId }, { requester_id: userToBlockId, receiver_id: requesterId }] });
    
    if (friendship) {
      this.logger.log(`[BLOCK] üìù Updating existing friendship between ${requesterId} and ${userToBlockId} to BLOCKED.`);
      friendship.requester_id = requesterId;
      friendship.receiver_id = userToBlockId;
      friendship.status = FriendStatuses.BLOCKED;
    } else {
      this.logger.log(`[BLOCK] üìù Creating new friendship entry to block User ID ${userToBlockId} by ${requesterId}.`);
      friendship = this.friendshipsRepository.create({ requester_id: requesterId, receiver_id: userToBlockId, status: FriendStatuses.BLOCKED });
    }
    const saved = await this.friendshipsRepository.save(friendship);
    this.logger.warn(`[BLOCK-SUCCESS] üö´ User ID: ${requesterId} blocked User ID: ${userToBlockId}. Friendship ID: ${saved.id}`);
    return saved;
  }

  async unblockUser(requesterId: number, userToUnblockId: number): Promise<void> {
    const friendship = await this.friendshipsRepository.findOne({ where: { requester_id: requesterId, receiver_id: userToUnblockId, status: FriendStatuses.BLOCKED } });
    if (!friendship) { 
        this.logger.warn(`[UNBLOCK-FAIL] ‚ö†Ô∏è User ID: ${requesterId} tried to unblock User ID: ${userToUnblockId}, but no block was found.`);
        throw new NotFoundException('You have not blocked this user.'); 
    }
    await this.friendshipsRepository.remove(friendship);
    this.logger.log(`[UNBLOCK-SUCCESS] ‚úÖ User ID: ${requesterId} unblocked User ID: ${userToUnblockId}.`);
  }

  async getOutgoingRequests(userId: number): Promise<Friendship[]> {
    this.logger.verbose(`[GET] üîé Fetching outgoing friend requests for User ID: ${userId}`);
    return this.friendshipsRepository.find({ where: { requester_id: userId, status: FriendStatuses.PENDING }, relations: ['receiver'] });
  }

  async listBlockedUsers(userId: number): Promise<Friendship[]> {
    this.logger.verbose(`[GET] üîé Fetching blocked users list for User ID: ${userId}`);
    return this.friendshipsRepository.find({ where: { requester_id: userId, status: FriendStatuses.BLOCKED }, relations: ['receiver'] });
  }

  async areTheyFriends(userId1: number, userId2: number): Promise<boolean> {
    if (userId1 === userId2) return true;
    this.logger.verbose(`[CHECK] üïµÔ∏è Checking friendship status between User ID ${userId1} and ${userId2}`);
    const friendship = await this.friendshipsRepository.findOne({
      where: [
        { requester_id: userId1, receiver_id: userId2, status: FriendStatuses.ACCEPTED },
        { requester_id: userId2, receiver_id: userId1, status: FriendStatuses.ACCEPTED },
      ],
    });
    return !!friendship;
  }

   async sendRequestFromPlugin(requesterUuid: string, receiverName: string): Promise<Friendship> {
    const requester = await this.usersRepository.findOneBy({ minecraft_uuid: requesterUuid });
    const receiver = await this.usersRepository.findOneBy({ minecraft_username: receiverName });
    if (!requester || !receiver) {
      this.logger.warn(`[PLUGIN-REQ-FAIL] ‚ö†Ô∏è One of the players is not linked. Requester UUID: ${requesterUuid}, Receiver Name: ${receiverName}`);
      throw new NotFoundException('One of the players is not linked to a website account.');
    }
    return this.sendRequest(requester.id, receiver.id);
  }

  async removeFriendFromPlugin(removerUuid: string, friendToRemoveName: string): Promise<void> {
    const remover = await this.usersRepository.findOneBy({ minecraft_uuid: removerUuid });
    const friendToRemove = await this.usersRepository.findOneBy({ minecraft_username: friendToRemoveName });
    if (!remover || !friendToRemove) {
      this.logger.warn(`[PLUGIN-REMOVE-FAIL] ‚ö†Ô∏è One of the players is not linked. Remover UUID: ${removerUuid}, Friend Name: ${friendToRemoveName}`);
      throw new NotFoundException('One of the players is not linked to a website account.');
    }
    const friendship = await this.friendshipsRepository.findOne({
        where: [
            { requester_id: remover.id, receiver_id: friendToRemove.id, status: FriendStatuses.ACCEPTED },
            { requester_id: friendToRemove.id, receiver_id: remover.id, status: FriendStatuses.ACCEPTED },
        ]
    });
    if (!friendship) {
        this.logger.warn(`[PLUGIN-REMOVE-FAIL] ‚ö†Ô∏è Friendship not found between ${remover.username} and ${friendToRemove.username}.`);
        throw new NotFoundException('Friendship not found.');
    }
    return this.removeFriend(friendship.id, remover.id);
  }

  async listFriendsForPlugin(playerUuid: string): Promise<string[]> {
    const user = await this.usersRepository.findOneBy({ minecraft_uuid: playerUuid });
    if (!user) {
      this.logger.warn(`[PLUGIN-LIST-FAIL] ‚ö†Ô∏è Player with UUID: ${playerUuid} is not linked to a website account.`);
      throw new NotFoundException('Player is not linked to a website account.');
    }
    const friendsWithData = await this.listFriends(user.id);
    return friendsWithData.map(f => f.user.minecraft_username || f.user.username);
  }

  async acceptRequestFromPlugin(responderUuid: string, requestId: number): Promise<Friendship> {
    const responder = await this.usersRepository.findOneBy({ minecraft_uuid: responderUuid });
    if (!responder) {
      this.logger.warn(`[PLUGIN-ACCEPT-FAIL] ‚ö†Ô∏è Responding player with UUID: ${responderUuid} is not linked.`);
      throw new NotFoundException('Responding player is not linked to a website account.');
    }
    return this.acceptRequest(requestId, responder.id);
  }

  async rejectRequestFromPlugin(responderUuid: string, requestId: number): Promise<void> {
    const responder = await this.usersRepository.findOneBy({ minecraft_uuid: responderUuid });
    if (!responder) {
      this.logger.warn(`[PLUGIN-DENY-FAIL] ‚ö†Ô∏è Responding player with UUID: ${responderUuid} is not linked.`);
      throw new NotFoundException('Responding player is not linked to a website account.');
    }
    return this.rejectOrCancelRequest(requestId, responder.id);
  }
}
--- END FILE: backend/src/friendships/friendships.service.ts ---



--- START FILE: backend/src/linking/entities/link-code.entity.ts ---

// backend/src/linking/entities/link-code.entity.ts

import { User } from '../../users/entities/user.entity';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  Index,
} from 'typeorm';

@Entity('link_codes')
export class LinkCode {
  @PrimaryGeneratedColumn()
  id: number;

  @Index({ unique: true })
  @Column({ type: 'varchar', length: 10 })
  code: string;

  @Column({ name: 'user_id' })
  userId: number;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'user_id' })
  user: User;

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date;

  @Column({ name: 'expires_at', type: 'timestamp' })
  expires_at: Date;
}
--- END FILE: backend/src/linking/entities/link-code.entity.ts ---



--- START FILE: backend/src/linking/linking.controller.ts ---

// backend/src/linking/linking.controller.ts

import { Controller, Post, UseGuards, Request, HttpCode, HttpStatus, Logger } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { LinkingService } from './linking.service';
import { ApiBearerAuth, ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';

@ApiTags('Account Linking')
@Controller('linking')
export class LinkingController {
  private readonly logger = new Logger(LinkingController.name);

  constructor(private readonly linkingService: LinkingService) {}

  @Post('generate-code')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Generate a one-time code to link a Minecraft account' })
  @ApiResponse({ status: 200, description: 'Returns the generated code.', schema: { type: 'object', properties: { code: { type: 'string' } } }})
  async generateCode(@Request() req): Promise<{ code: string }> {
    const userId = req.user.userId;
    this.logger.log(`[CODE-GEN] üîë User ID: ${userId} is generating a new link code.`);
    const code = await this.linkingService.generateCodeForUser(userId);
    return { code };
  }
}
--- END FILE: backend/src/linking/linking.controller.ts ---



--- START FILE: backend/src/linking/linking.module.ts ---

// backend/src/linking/linking.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { LinkingService } from './linking.service';
import { LinkingController } from './linking.controller';
import { LinkCode } from './entities/link-code.entity';
import { User } from '../users/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([LinkCode, User])],
  providers: [LinkingService],
  controllers: [LinkingController],
  exports: [LinkingService], // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –¥–ª—è ChatGateway
})
export class LinkingModule {}
--- END FILE: backend/src/linking/linking.module.ts ---



--- START FILE: backend/src/linking/linking.service.ts ---

// backend/src/linking/linking.service.ts

import { Injectable, NotFoundException, ConflictException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { LinkCode } from './entities/link-code.entity';
import { randomBytes } from 'crypto';

@Injectable()
export class LinkingService {
  private readonly logger = new Logger(LinkingService.name);

  constructor(
    @InjectRepository(LinkCode)
    private linkCodeRepository: Repository<LinkCode>,
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async generateCodeForUser(userId: number): Promise<string> {
    await this.linkCodeRepository.delete({ userId });
    
    const user = await this.usersRepository.findOneBy({ id: userId });

    if (!user) {
      this.logger.error(`[CODE-GEN-FAIL] ‚ùå Attempted to generate code for a non-existent User ID: ${userId}.`);
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }

    if (user.minecraft_uuid) {
      this.logger.warn(`[CODE-GEN-FAIL] ‚ö†Ô∏è User ID: ${userId} (${user.username}) attempted to generate a code but already has a linked account.`);
      throw new ConflictException('This website account is already linked to a Minecraft account.');
    }

    const code = randomBytes(3).toString('hex').toUpperCase();
    const expires_at = new Date(Date.now() + 5 * 60 * 1000);

    const newLinkCode = this.linkCodeRepository.create({ code, userId, expires_at });
    
    await this.linkCodeRepository.save(newLinkCode);
    this.logger.log(`[CODE-GEN-SUCCESS] ‚úÖ Generated new link code '${code}' for User ID: ${userId}.`);
    return code;
  }

  async verifyCodeAndLinkAccount(code: string, minecraftUuid: string, minecraftUsername: string): Promise<User> {
    this.logger.log(`[VERIFY-LINK] üîó Verifying code '${code}' for MC UUID: ${minecraftUuid} (${minecraftUsername}).`);
    const linkCode = await this.linkCodeRepository.findOne({ where: { code } });

    if (!linkCode || linkCode.expires_at < new Date()) {
      this.logger.warn(`[VERIFY-FAIL] ‚ö†Ô∏è Invalid or expired link code '${code}' used by MC UUID: ${minecraftUuid}.`);
      throw new NotFoundException('Invalid or expired link code.');
    }
    
    const [userToUpdate, existingLinkedUser] = await Promise.all([
        this.usersRepository.findOneBy({ id: linkCode.userId }),
        this.usersRepository.findOneBy({ minecraft_uuid: minecraftUuid })
    ]);

    if (existingLinkedUser) {
        this.logger.warn(`[VERIFY-FAIL] ‚ö†Ô∏è Conflict. MC UUID ${minecraftUuid} is already linked to User ID: ${existingLinkedUser.id} (${existingLinkedUser.username}).`);
        throw new ConflictException('This Minecraft account is already linked to another website account.');
    }

    if (!userToUpdate) {
      this.logger.error(`[VERIFY-FAIL] ‚ùå User account associated with code '${code}' (User ID: ${linkCode.userId}) not found.`);
      await this.linkCodeRepository.remove(linkCode);
      throw new NotFoundException('User associated with this code not found.');
    }

    userToUpdate.minecraft_uuid = minecraftUuid;
    userToUpdate.minecraft_username = minecraftUsername;

    const savedUser = await this.usersRepository.save(userToUpdate);
    await this.linkCodeRepository.remove(linkCode);
    
    this.logger.log(`[VERIFY-SUCCESS] ‚úÖ Successfully linked User ID: ${savedUser.id} (${savedUser.username}) with MC UUID: ${minecraftUuid}.`);
    return savedUser;
  }
}
--- END FILE: backend/src/linking/linking.service.ts ---



--- START FILE: backend/src/main.ts ---

// backend/src/main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { ValidationPipe, Logger } from '@nestjs/common'; // <-- –î–æ–±–∞–≤–ª—è–µ–º Logger
import { ConfigService } from '@nestjs/config';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  // --- –ù–û–í–û–ï: –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –ª–æ–≥–≥–µ—Ä–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ Bootstrap ---
  const logger = new Logger('Bootstrap'); 
  const configService = app.get(ConfigService);

  app.setGlobalPrefix('api');
  app.enableCors();
  app.useStaticAssets(join(__dirname, '..', 'uploads'), {
    prefix: '/uploads',
  });
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }));
  const config = new DocumentBuilder()
    .setTitle('Flamewall API')
    .setDescription('API documentation for the Flamewall Minecraft server website')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api-docs', app, document);

  const port = configService.get<number>('API_PORT', 3000);
  await app.listen(port, '0.0.0.0');

  // --- –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º Logger –≤–º–µ—Å—Ç–æ console.log ---
  logger.log(`üöÄ Application is running on port: ${port}`);
  logger.log(`üìö Swagger documentation is available at: /api-docs`);
}
bootstrap(); 
--- END FILE: backend/src/main.ts ---



--- START FILE: backend/src/messages/dto/create-message.dto.ts ---

import { IsInt, IsNotEmpty, IsPositive, IsString, MaxLength, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateMessageDto {
  @ApiProperty({
    description: 'The ID of the user who will receive the message',
    example: 1,
  })
  @IsInt()
  @IsPositive()
  @IsNotEmpty()
  recipientId: number;

  @ApiProperty({
    description: 'The content of the message',
    example: 'Hello there!',
    minLength: 1,
    maxLength: 1000,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(1)
  @MaxLength(1000) // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
  content: string;
}
--- END FILE: backend/src/messages/dto/create-message.dto.ts ---



--- START FILE: backend/src/messages/dto/delete-message.dto.ts ---

import { IsInt, IsNotEmpty } from 'class-validator';

export class DeleteMessageDto {
  @IsNotEmpty()
  @IsInt()
  messageId: number;
}
--- END FILE: backend/src/messages/dto/delete-message.dto.ts ---



--- START FILE: backend/src/messages/dto/edit-message.dto.ts ---

import { IsInt, IsNotEmpty, IsString, MaxLength } from 'class-validator';

export class EditMessageDto {
  @IsNotEmpty()
  @IsInt()
  messageId: number;

  @IsNotEmpty()
  @IsString()
  @MaxLength(5000) // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
  content: string;
}
--- END FILE: backend/src/messages/dto/edit-message.dto.ts ---



--- START FILE: backend/src/messages/entities/message.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

@Entity('messages')
export class Message {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'text' })
  content: string;

  @CreateDateColumn({ type: 'timestamp', name: 'sent_at', default: () => 'CURRENT_TIMESTAMP' })
  sent_at: Date;

  @UpdateDateColumn({ type: 'timestamp', name: 'updated_at' })
  updated_at: Date;

  @Column({ type: 'timestamp', name: 'viewed_at', nullable: true, default: null })
  viewed_at: Date | null;

  @Column({ name: 'is_deleted', type: 'boolean', default: false })
  is_deleted: boolean;

  @Column({ name: 'sender_id' })
  sender_id: number;

  @ManyToOne(() => User, (user) => user.sent_messages, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'sender_id' })
  sender: User;

  @Column({ name: 'receiver_id' })
  receiver_id: number;

  @ManyToOne(() => User, (user) => user.received_messages, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'receiver_id' })
  receiver: User;

  @ManyToOne(() => Message, (message) => message.replies, {
    nullable: true,
    onDelete: 'SET NULL',
  })
  @JoinColumn({ name: 'parent_message_id' })
  parentMessage: Message | null;

  @Column({ name: 'parent_message_id', nullable: true })
  parentMessageId: number | null;

  @OneToMany(() => Message, (message) => message.parentMessage)
  replies: Message[];
}
--- END FILE: backend/src/messages/entities/message.entity.ts ---



--- START FILE: backend/src/messages/messages.controller.ts ---

// backend/src/messages/messages.controller.ts

import { Controller, Get, Param, ParseIntPipe, Request, UseGuards, Logger } from '@nestjs/common';
import { MessagesService } from './messages.service';
import { ApiBearerAuth, ApiOperation, ApiTags } from '@nestjs/swagger';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@ApiTags('Messages')
@Controller('messages')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class MessagesController {
  private readonly logger = new Logger(MessagesController.name);

  constructor(private readonly messagesService: MessagesService) {}

  @Get('conversation/:otherUserId')
  @ApiOperation({ summary: 'Get conversation history with another user' })
  getConversation(
    @Request() req,
    @Param('otherUserId', ParseIntPipe) otherUserId: number
  ) {
    const currentUserId = req.user.userId;
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
    this.logger.log(`[GET-CONVO] üí¨ User ID: ${currentUserId} is fetching conversation with User ID: ${otherUserId}`);
    return this.messagesService.getConversation(currentUserId, otherUserId);
  }
}
--- END FILE: backend/src/messages/messages.controller.ts ---



--- START FILE: backend/src/messages/messages.module.ts ---

import { Module } from '@nestjs/common';
import { MessagesService } from './messages.service';
import { MessagesController } from './messages.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Message } from './entities/message.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Message])],
  controllers: [MessagesController],
  providers: [MessagesService],
  exports: [MessagesService] // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ ChatGateway
})
export class MessagesModule {}
--- END FILE: backend/src/messages/messages.module.ts ---



--- START FILE: backend/src/messages/messages.service.ts ---

// backend/src/messages/messages.service.ts

import { Injectable, Logger, ForbiddenException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Message } from './entities/message.entity';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { recentMessageSignatures } from '../chat/connection-lock';

@Injectable()
export class MessagesService {
  private logger: Logger = new Logger('MessagesService');

  constructor(
    @InjectRepository(Message)
    private messagesRepository: Repository<Message>,
  ) {}

  async createMessage(sender: User, receiver: User, content: string, parentMessageId?: number): Promise<Message | null> {
    const signature = `${sender.id}-${receiver.id}-${content}`;
    if (recentMessageSignatures.has(signature)) {
      // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
      this.logger.warn(`[MSG-DUPLICATE] ‚ö†Ô∏è Duplicate message blocked from User ID: ${sender.id} to User ID: ${receiver.id}.`);
      return null;
    }
    recentMessageSignatures.add(signature);
    setTimeout(() => {
      recentMessageSignatures.delete(signature);
    }, 2000);

    const message = this.messagesRepository.create({ sender, receiver, content, parentMessageId });
    try {
      const savedMessage = await this.messagesRepository.save(message);
      this.logger.verbose(`[MSG-CREATE-SUCCESS] ‚úÖ Message created (ID: ${savedMessage.id}) between User ID: ${sender.id} and User ID: ${receiver.id}.`);
      return this.findMessageById(savedMessage.id);
    } catch (error) {
      // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω —ç–º–æ–¥–∑–∏ ---
      this.logger.error(`[MSG-CREATE-FAIL] ‚ùå Failed to save message from User ID: ${sender.id} to User ID: ${receiver.id}.`, error.stack);
      recentMessageSignatures.delete(signature);
      return null;
    }
  }

  async updateMessage(userId: number, messageId: number, content: string): Promise<Message> {
    const message = await this.findMessageById(messageId);
    if (!message) {
      this.logger.warn(`[MSG-UPDATE-FAIL] ‚ö†Ô∏è Attempt to update non-existent Message ID: ${messageId} by User ID: ${userId}.`);
      throw new NotFoundException('Message not found.');
    }
    if (message.sender_id !== userId) {
      this.logger.warn(`[MSG-UPDATE-FORBIDDEN] üö´ User ID: ${userId} failed to update Message ID: ${messageId}. Reason: Not the sender.`);
      throw new ForbiddenException('You can only edit your own messages.');
    }
    message.content = content;
    const updatedMessage = await this.messagesRepository.save(message);
    this.logger.log(`[MSG-UPDATE-SUCCESS] üìù Message ID: ${messageId} was updated by User ID: ${userId}.`);
    return updatedMessage;
  }

  async deleteMessage(userId: number, messageId: number): Promise<Message> {
    const message = await this.findMessageById(messageId);
    if (!message) {
      this.logger.warn(`[MSG-DELETE-FAIL] ‚ö†Ô∏è Attempt to delete non-existent Message ID: ${messageId} by User ID: ${userId}.`);
      throw new NotFoundException('Message not found.');
    }
    if (message.sender_id !== userId) {
      this.logger.warn(`[MSG-DELETE-FORBIDDEN] üö´ User ID: ${userId} failed to delete Message ID: ${messageId}. Reason: Not the sender.`);
      throw new ForbiddenException('You can only delete your own messages.');
    }
    message.is_deleted = true;
    message.content = 'Message has been deleted.';
    this.logger.warn(`[MSG-DELETE-SUCCESS] üóëÔ∏è Message ID: ${messageId} was soft-deleted by User ID: ${userId}.`);
    return this.messagesRepository.save(message);
  }

  async getConversation(userId1: number, userId2: number): Promise<Message[]> {
    this.logger.verbose(`[DB-GET-CONVO] üíæ Fetching conversation from DB between User ID: ${userId1} and User ID: ${userId2}`);
    return this.messagesRepository.find({
      where: [
        { sender_id: userId1, receiver_id: userId2 },
        { sender_id: userId2, receiver_id: userId1 },
      ],
      relations: ['sender', 'receiver', 'parentMessage', 'parentMessage.sender'],
      order: { sent_at: 'ASC' },
    });
  }
  
  async findMessageById(id: number): Promise<Message | null> {
    return this.messagesRepository.findOne({
      where: { id },
      relations: ['sender', 'receiver', 'parentMessage', 'parentMessage.sender'],
    });
  }
}
--- END FILE: backend/src/messages/messages.service.ts ---



--- START FILE: backend/src/migrations/1750536828010-InitialSchema.ts ---

import { MigrationInterface, QueryRunner } from "typeorm";

export class InitialSchema1750536828010 implements MigrationInterface {
    name = 'InitialSchema1750536828010'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "votes" ("id" SERIAL NOT NULL, "value" integer NOT NULL, "voter_id" integer NOT NULL, "post_id" integer, "comment_id" integer, CONSTRAINT "CHK_9531a3f9e2c935050189b1bdae" CHECK (("post_id" IS NOT NULL AND "comment_id" IS NULL) OR ("post_id" IS NULL AND "comment_id" IS NOT NULL)), CONSTRAINT "PK_f3d9fd4a0af865152c3f59db8ff" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_cebd183f3909b522b32784acf2" ON "votes" ("voter_id", "comment_id") WHERE "comment_id" IS NOT NULL`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_c6f5e47300a8016ff8abdb67c9" ON "votes" ("voter_id", "post_id") WHERE "post_id" IS NOT NULL`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" SERIAL NOT NULL, "content" character varying(1000) NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), "author_id" integer, "post_id" integer NOT NULL, CONSTRAINT "PK_8bf68bc960f2b69e818bdb90dcb" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" SERIAL NOT NULL, "author_id" integer, "title" character varying(100) NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "content" text NOT NULL, "updated_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_2829ac61eff60fcec60d7274b9e" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "news" ("id" SERIAL NOT NULL, "author_id" integer NOT NULL, "name" character varying(50) NOT NULL, "desc" text NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_39a43dfcb6007180f04aff2357e" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TYPE "public"."friendships_status_enum" AS ENUM('PENDING', 'ACCEPTED', 'BLOCKED')`);
        await queryRunner.query(`CREATE TABLE "friendships" ("id" SERIAL NOT NULL, "requester_id" integer NOT NULL, "receiver_id" integer NOT NULL, "status" "public"."friendships_status_enum" NOT NULL DEFAULT 'PENDING', "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_08af97d0be72942681757f07bc8" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_9a08c92f69d812b680e938a078" ON "friendships" ("requester_id", "receiver_id") `);
        await queryRunner.query(`CREATE TABLE "messages" ("id" SERIAL NOT NULL, "content" text NOT NULL, "sent_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), "viewed_at" TIMESTAMP, "is_deleted" boolean NOT NULL DEFAULT false, "sender_id" integer NOT NULL, "receiver_id" integer NOT NULL, "parent_message_id" integer, CONSTRAINT "PK_18325f38ae6de43878487eff986" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "notifications" ("notification_id" SERIAL NOT NULL, "user_id" integer NOT NULL, "title" character varying(100) NOT NULL, "message" character varying(255) NOT NULL, "type" character varying(50), "link" character varying(255), "read" boolean NOT NULL DEFAULT false, "created_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_eaedfe19f0f765d26afafa85956" PRIMARY KEY ("notification_id"))`);
        await queryRunner.query(`CREATE TABLE "shop_items" ("item_id" SERIAL NOT NULL, "name" character varying(100) NOT NULL, "description" text, "price" integer NOT NULL, "image_url" character varying(255), "ingame_command" character varying(255) NOT NULL, "is_active" boolean NOT NULL DEFAULT true, "category" character varying(50) NOT NULL DEFAULT 'items', "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_bebbea41754288ba74c82d5c4f4" PRIMARY KEY ("item_id"))`);
        await queryRunner.query(`CREATE TABLE "purchases" ("purchase_id" SERIAL NOT NULL, "user_id" integer NOT NULL, "item_id" integer NOT NULL, "purchase_price" integer NOT NULL, "purchased_at" TIMESTAMP NOT NULL DEFAULT now(), "status" character varying(20) NOT NULL DEFAULT 'COMPLETED', CONSTRAINT "PK_b2ebfeff06ca4de4b541e52cf70" PRIMARY KEY ("purchase_id"))`);
        await queryRunner.query(`CREATE TABLE "ranks" ("id" SERIAL NOT NULL, "name" character varying(50) NOT NULL, "system_name" character varying(50) NOT NULL, "power_level" integer NOT NULL, "display_color" character varying(7) NOT NULL DEFAULT '#808080', "is_removable" boolean NOT NULL DEFAULT true, CONSTRAINT "PK_7620a297228c6e9ed28e9fd07e4" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_1e525c9bb1a236277376344d89" ON "ranks" ("name") `);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_9394a51fa9aa1405b05f9f8be8" ON "ranks" ("system_name") `);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_764d04403bcecc31ac112f679d" ON "ranks" ("power_level") `);
        await queryRunner.query(`CREATE TABLE "users" ("id" SERIAL NOT NULL, "username" character varying(50) NOT NULL, "minecraft_username" character varying(16), "profile_slug" character varying(50), "minecraft_uuid" character varying(36), "first_login" TIMESTAMP NOT NULL DEFAULT now(), "description" character varying(70), "pfp_url" character varying(100), "banner_url" character varying(100), "is_banned" boolean NOT NULL DEFAULT false, "balance" integer NOT NULL DEFAULT '0', "password_hash" character varying(255) NOT NULL, "email" character varying(255) NOT NULL, "email_verified_at" TIMESTAMP, "last_login" TIMESTAMP, "reputation_count" integer NOT NULL DEFAULT '0', "is_minecraft_online" boolean NOT NULL DEFAULT false, "updated_at" TIMESTAMP NOT NULL DEFAULT now(), "deleted_at" TIMESTAMP, "rank_id" integer, CONSTRAINT "UQ_7166d1a63d45160e5e73b692543" UNIQUE ("profile_slug"), CONSTRAINT "UQ_427ce47b56e04782619404f41cb" UNIQUE ("minecraft_uuid"), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"), CONSTRAINT "PK_a3ffb1c0c8416b9fc6f907b7433" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_303a4166462928f0f3b0a444e7" ON "users" ("profile_slug") WHERE "profile_slug" IS NOT NULL`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f825c33d570c3fc72458ca21f" ON "users" ("minecraft_uuid") WHERE "minecraft_uuid" IS NOT NULL`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_97672ac88f789774dd47f7c8be" ON "users" ("email") `);
        await queryRunner.query(`CREATE TABLE "link_codes" ("id" SERIAL NOT NULL, "code" character varying(10) NOT NULL, "user_id" integer NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "expires_at" TIMESTAMP NOT NULL, CONSTRAINT "PK_8ffedf36354a3f1445282b48ac2" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_6e5743f84fbf9e5e34ea56170f" ON "link_codes" ("code") `);
        await queryRunner.query(`CREATE TABLE "pending_commands" ("id" SERIAL NOT NULL, "command" character varying(255) NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_100b81018a3c8b328d6bca5e8f9" PRIMARY KEY ("id"))`);
        await queryRunner.query(`ALTER TABLE "votes" ADD CONSTRAINT "FK_907ed58b724f8debe4200e51af3" FOREIGN KEY ("voter_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "votes" ADD CONSTRAINT "FK_18499a5b9b4cf71093f7b7f79f8" FOREIGN KEY ("post_id") REFERENCES "posts"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "votes" ADD CONSTRAINT "FK_edd21a11cce9afc9a6b990a1be1" FOREIGN KEY ("comment_id") REFERENCES "comments"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "comments" ADD CONSTRAINT "FK_e6d38899c31997c45d128a8973b" FOREIGN KEY ("author_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "comments" ADD CONSTRAINT "FK_259bf9825d9d198608d1b46b0b5" FOREIGN KEY ("post_id") REFERENCES "posts"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "posts" ADD CONSTRAINT "FK_312c63be865c81b922e39c2475e" FOREIGN KEY ("author_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "news" ADD CONSTRAINT "FK_173d93468ebf142bb3424c2fd63" FOREIGN KEY ("author_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "friendships" ADD CONSTRAINT "FK_4cf3c68ed4a5a9fde8d4c2b7319" FOREIGN KEY ("requester_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "friendships" ADD CONSTRAINT "FK_e6f5aea2073c03cb60231b0b4e8" FOREIGN KEY ("receiver_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "messages" ADD CONSTRAINT "FK_22133395bd13b970ccd0c34ab22" FOREIGN KEY ("sender_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "messages" ADD CONSTRAINT "FK_b561864743d235f44e70addc1f5" FOREIGN KEY ("receiver_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "messages" ADD CONSTRAINT "FK_72ffa22d68b72a09d5700e4463f" FOREIGN KEY ("parent_message_id") REFERENCES "messages"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "notifications" ADD CONSTRAINT "FK_9a8a82462cab47c73d25f49261f" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "purchases" ADD CONSTRAINT "FK_024ddf7e04177a07fcb9806a90a" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "purchases" ADD CONSTRAINT "FK_1064c04bd5a56289865700b2403" FOREIGN KEY ("item_id") REFERENCES "shop_items"("item_id") ON DELETE CASCADE ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "users" ADD CONSTRAINT "FK_5488721c37882b6107fe23f10be" FOREIGN KEY ("rank_id") REFERENCES "ranks"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "link_codes" ADD CONSTRAINT "FK_466de43d0ca94349972dc8657d5" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "link_codes" DROP CONSTRAINT "FK_466de43d0ca94349972dc8657d5"`);
        await queryRunner.query(`ALTER TABLE "users" DROP CONSTRAINT "FK_5488721c37882b6107fe23f10be"`);
        await queryRunner.query(`ALTER TABLE "purchases" DROP CONSTRAINT "FK_1064c04bd5a56289865700b2403"`);
        await queryRunner.query(`ALTER TABLE "purchases" DROP CONSTRAINT "FK_024ddf7e04177a07fcb9806a90a"`);
        await queryRunner.query(`ALTER TABLE "notifications" DROP CONSTRAINT "FK_9a8a82462cab47c73d25f49261f"`);
        await queryRunner.query(`ALTER TABLE "messages" DROP CONSTRAINT "FK_72ffa22d68b72a09d5700e4463f"`);
        await queryRunner.query(`ALTER TABLE "messages" DROP CONSTRAINT "FK_b561864743d235f44e70addc1f5"`);
        await queryRunner.query(`ALTER TABLE "messages" DROP CONSTRAINT "FK_22133395bd13b970ccd0c34ab22"`);
        await queryRunner.query(`ALTER TABLE "friendships" DROP CONSTRAINT "FK_e6f5aea2073c03cb60231b0b4e8"`);
        await queryRunner.query(`ALTER TABLE "friendships" DROP CONSTRAINT "FK_4cf3c68ed4a5a9fde8d4c2b7319"`);
        await queryRunner.query(`ALTER TABLE "news" DROP CONSTRAINT "FK_173d93468ebf142bb3424c2fd63"`);
        await queryRunner.query(`ALTER TABLE "posts" DROP CONSTRAINT "FK_312c63be865c81b922e39c2475e"`);
        await queryRunner.query(`ALTER TABLE "comments" DROP CONSTRAINT "FK_259bf9825d9d198608d1b46b0b5"`);
        await queryRunner.query(`ALTER TABLE "comments" DROP CONSTRAINT "FK_e6d38899c31997c45d128a8973b"`);
        await queryRunner.query(`ALTER TABLE "votes" DROP CONSTRAINT "FK_edd21a11cce9afc9a6b990a1be1"`);
        await queryRunner.query(`ALTER TABLE "votes" DROP CONSTRAINT "FK_18499a5b9b4cf71093f7b7f79f8"`);
        await queryRunner.query(`ALTER TABLE "votes" DROP CONSTRAINT "FK_907ed58b724f8debe4200e51af3"`);
        await queryRunner.query(`DROP TABLE "pending_commands"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_6e5743f84fbf9e5e34ea56170f"`);
        await queryRunner.query(`DROP TABLE "link_codes"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_97672ac88f789774dd47f7c8be"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_4f825c33d570c3fc72458ca21f"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_303a4166462928f0f3b0a444e7"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_764d04403bcecc31ac112f679d"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_9394a51fa9aa1405b05f9f8be8"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_1e525c9bb1a236277376344d89"`);
        await queryRunner.query(`DROP TABLE "ranks"`);
        await queryRunner.query(`DROP TABLE "purchases"`);
        await queryRunner.query(`DROP TABLE "shop_items"`);
        await queryRunner.query(`DROP TABLE "notifications"`);
        await queryRunner.query(`DROP TABLE "messages"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_9a08c92f69d812b680e938a078"`);
        await queryRunner.query(`DROP TABLE "friendships"`);
        await queryRunner.query(`DROP TYPE "public"."friendships_status_enum"`);
        await queryRunner.query(`DROP TABLE "news"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_c6f5e47300a8016ff8abdb67c9"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_cebd183f3909b522b32784acf2"`);
        await queryRunner.query(`DROP TABLE "votes"`);
    }

}

--- END FILE: backend/src/migrations/1750536828010-InitialSchema.ts ---



--- START FILE: backend/src/migrations/1750613617027-AddRankCommandTemplates.ts ---

import { MigrationInterface, QueryRunner } from "typeorm";

export class AddRankCommandTemplates1750613617027 implements MigrationInterface {
    name = 'AddRankCommandTemplates1750613617027'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ranks" ADD "command_template" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "ranks" ADD "command_template_remove" character varying(255)`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ranks" DROP COLUMN "command_template_remove"`);
        await queryRunner.query(`ALTER TABLE "ranks" DROP COLUMN "command_template"`);
    }

}

--- END FILE: backend/src/migrations/1750613617027-AddRankCommandTemplates.ts ---



--- START FILE: backend/src/migrations/1750691690126-CreatePagesTable.ts ---

import { MigrationInterface, QueryRunner } from "typeorm";

export class CreatePagesTable1750691690126 implements MigrationInterface {
    name = 'CreatePagesTable1750691690126'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "custom_pages" ("id" SERIAL NOT NULL, "title" character varying(255) NOT NULL, "slug" character varying(255) NOT NULL, "content" text NOT NULL, "is_published" boolean NOT NULL DEFAULT false, "author_id" integer NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "UQ_24ff72a94da2290c8a791a030ef" UNIQUE ("slug"), CONSTRAINT "PK_9bbf7c05420c7434f117c934345" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_24ff72a94da2290c8a791a030e" ON "custom_pages" ("slug") `);
        await queryRunner.query(`ALTER TABLE "custom_pages" ADD CONSTRAINT "FK_6e6edd09635b73b1326136f3f1a" FOREIGN KEY ("author_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE NO ACTION`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "custom_pages" DROP CONSTRAINT "FK_6e6edd09635b73b1326136f3f1a"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_24ff72a94da2290c8a791a030e"`);
        await queryRunner.query(`DROP TABLE "custom_pages"`);
    }

}

--- END FILE: backend/src/migrations/1750691690126-CreatePagesTable.ts ---



--- START FILE: backend/src/news/dto/create-news.dto.ts ---

import { IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateNewsDto {
  @ApiProperty({ 
    example: 'Server Maintenance Announcement', 
    description: 'Title of the news article', 
    minLength: 3, 
    maxLength: 50 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  name: string;

  @ApiProperty({ 
    example: 'We will be performing server maintenance on Sunday at 10 PM UTC.', 
    description: 'Main content of the news article', 
    minLength: 10 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(10)
  desc: string;
}
--- END FILE: backend/src/news/dto/create-news.dto.ts ---



--- START FILE: backend/src/news/dto/update-news.dto.ts ---

import { IsOptional, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';

export class UpdateNewsDto {
  @ApiPropertyOptional({ 
    example: 'Important Server Update', 
    description: 'The updated title of the news article (optional)', 
    minLength: 3, 
    maxLength: 50 
  })
  @IsOptional()
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  name?: string;

  @ApiPropertyOptional({ 
    example: 'The maintenance has been rescheduled to Monday.', 
    description: 'The updated main content of the news article (optional)', 
    minLength: 10 
  })
  @IsOptional()
  @IsString()
  @MinLength(10)
  desc?: string;
}
--- END FILE: backend/src/news/dto/update-news.dto.ts ---



--- START FILE: backend/src/news/entities/news.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

@Entity('news')
export class News {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'author_id' })
  author_id: number;

  @ManyToOne(() => User, (user) => user.news, { onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Column({ type: 'varchar', length: 50 })
  name: string;

  @Column({ type: 'text' })
  desc: string;

  @CreateDateColumn({ type: 'timestamp', name: 'created_at', default: () => 'CURRENT_TIMESTAMP' })
  created_at: Date;

  @UpdateDateColumn({ type: 'timestamp', name: 'updated_at', default: () => 'CURRENT_TIMESTAMP', onUpdate: 'CURRENT_TIMESTAMP' })
  updated_at: Date;
}
--- END FILE: backend/src/news/entities/news.entity.ts ---



--- START FILE: backend/src/news/news.controller.ts ---

// backend/src/news/news.controller.ts

import { 
  Controller, 
  Get, 
  Post, 
  Body, 
  Param, 
  ParseIntPipe, 
  UsePipes, 
  ValidationPipe, 
  UseGuards, 
  Request,
  Patch,
  Delete,
  Logger,
} from '@nestjs/common';
import { NewsService } from './news.service';
import { CreateNewsDto } from './dto/create-news.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { News as NewsEntity } from './entities/news.entity';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { UpdateNewsDto } from './dto/update-news.dto';
import { SystemRanks } from '../ranks/ranks.service';

@ApiTags('News')
@Controller('news')
export class NewsController {
  private readonly logger = new Logger(NewsController.name);

  constructor(private readonly newsService: NewsService) {}

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.MODERATOR.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Create a new news article (Admins/Mods only)' })
  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))
  create(@Body() createNewsDto: CreateNewsDto, @Request() req): Promise<NewsEntity> {
    const actorId = req.user.userId;
    this.logger.log(`[CREATE] üì∞ User ID: ${actorId} is creating a news article titled: "${createNewsDto.name}"`);
    return this.newsService.create(createNewsDto, actorId);
  }

  @Get()
  @ApiOperation({ summary: 'Get all news articles' })
  findAll(): Promise<NewsEntity[]> {
    this.logger.verbose(`[GET-ALL] üîé Fetching all news articles.`);
    return this.newsService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a specific news article by ID' })
  findOne(@Param('id', ParseIntPipe) id: number): Promise<NewsEntity> {
    this.logger.verbose(`[GET-ONE] üîé Fetching news article with ID: ${id}`);
    return this.newsService.findOne(id);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.MODERATOR.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update a news article (Admins/Mods only)' })
  @UsePipes(new ValidationPipe({ whitelist: true, skipMissingProperties: true, forbidNonWhitelisted: true }))
  update(@Param('id', ParseIntPipe) id: number, @Body() updateNewsDto: UpdateNewsDto, @Request() req): Promise<NewsEntity> {
    this.logger.log(`[UPDATE] üìù User ID: ${req.user.userId} is attempting to update news article ID: ${id}.`);
    return this.newsService.update(id, updateNewsDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.MODERATOR.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Delete a news article (Admins/Mods only)' })
  remove(@Param('id', ParseIntPipe) id: number, @Request() req): Promise<void> {
    this.logger.warn(`[DELETE] üóëÔ∏è User ID: ${req.user.userId} is attempting to delete news article ID: ${id}.`);
    return this.newsService.remove(id);
  }
}
--- END FILE: backend/src/news/news.controller.ts ---



--- START FILE: backend/src/news/news.module.ts ---

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { News } from './entities/news.entity';
import { NewsService } from './news.service';
import { NewsController } from './news.controller';
import { User } from '../users/entities/user.entity';
import { UsersModule } from '../users/users.module'; 

@Module({
  imports: [TypeOrmModule.forFeature([News, User]), UsersModule], 
  providers: [NewsService],
  controllers: [NewsController],
})
export class NewsModule {}
--- END FILE: backend/src/news/news.module.ts ---



--- START FILE: backend/src/news/news.service.ts ---

// backend/src/news/news.service.ts

import { Injectable, NotFoundException, ForbiddenException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { News } from './entities/news.entity';
import { CreateNewsDto } from './dto/create-news.dto';
import { User } from '../users/entities/user.entity';
import { UpdateNewsDto } from './dto/update-news.dto';

@Injectable()
export class NewsService {
  private readonly logger = new Logger(NewsService.name);

  constructor(
    @InjectRepository(News)
    private newsRepository: Repository<News>,
    @InjectRepository(User) 
    private usersRepository: Repository<User>,
  ) {}

  async create(createNewsDto: CreateNewsDto, authorId: number): Promise<News> {
    const author = await this.usersRepository.findOne({ where: { id: authorId } });
    if (!author) {
      this.logger.error(`[CREATE-FAIL] ‚ùå Author with ID ${authorId} not found. Cannot create news.`);
      throw new ForbiddenException('Authenticated user not found.');
    }

    const newsItem = this.newsRepository.create({
      ...createNewsDto,
      author: author,
    });
    const savedNews = await this.newsRepository.save(newsItem);
    this.logger.log(`[CREATE-SUCCESS] ‚úÖ User ID: ${authorId} created News ID: ${savedNews.id} titled: "${savedNews.name}"`);
    return savedNews;
  }

  async findAll(): Promise<News[]> {
    return this.newsRepository.find({ 
      relations: ['author'],
      order: {
        created_at: 'DESC',
      }
    });
  }

  async findOne(id: number): Promise<News> {
    const newsItem = await this.newsRepository.findOne({ 
      where: { id },
      relations: ['author'] 
    });
    if (!newsItem) {
      this.logger.warn(`[GET-ONE-FAIL] ‚ö†Ô∏è News item with ID ${id} not found.`);
      throw new NotFoundException(`News item with ID ${id} not found`);
    }
    return newsItem;
  }

  async update(id: number, updateNewsDto: UpdateNewsDto): Promise<News> {
    const newsItem = await this.findOne(id);
    
    Object.assign(newsItem, updateNewsDto);

    const updatedNews = await this.newsRepository.save(newsItem);
    this.logger.log(`[UPDATE-SUCCESS] ‚úÖ News article ID: ${id} was successfully updated.`);
    return updatedNews;
  }

  async remove(id: number): Promise<void> {
    const newsItem = await this.findOne(id);
    await this.newsRepository.remove(newsItem);
    this.logger.warn(`[DELETE-SUCCESS] üóëÔ∏è News article ID: ${id} was successfully deleted.`);
  }
}
--- END FILE: backend/src/news/news.service.ts ---



--- START FILE: backend/src/notifications/dto/mark-as-read-by-link.dto.ts ---

import { IsNotEmpty, IsString } from 'class-validator';

export class MarkAsReadByLinkDto {
  @IsString()
  @IsNotEmpty()
  link: string;
}
--- END FILE: backend/src/notifications/dto/mark-as-read-by-link.dto.ts ---



--- START FILE: backend/src/notifications/entities/notification.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

@Entity('notifications')
export class Notification {
  @PrimaryGeneratedColumn({ name: 'notification_id' })
  notification_id: number;

  // –°–≤—è–∑—å —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  @ManyToOne(() => User, (user) => user.notifications, { 
    onDelete: 'CASCADE'
  })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'user_id' })
  user_id: number;
  
  @Column({ type: 'varchar', length: 100 })
  title: string;

  @Column({ type: 'varchar', length: 255 })
  message: string;

  // –¢–∏–ø —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä 'friend_request_accepted', 'new_comment'
  @Column({ type: 'varchar', length: 50, nullable: true })
  type: string | null;

  // –°—Å—ã–ª–∫–∞ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  @Column({ type: 'varchar', length: 255, nullable: true })
  link: string | null;

  // –ü—Ä–æ—á–∏—Ç–∞–Ω–æ –ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  @Column({ type: 'boolean', default: false })
  read: boolean;

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date;
}
--- END FILE: backend/src/notifications/entities/notification.entity.ts ---



--- START FILE: backend/src/notifications/notifications.controller.ts ---

// backend/src/notifications/notifications.controller.ts

import { Controller, Get, Param, ParseIntPipe, UseGuards, Post, HttpCode, HttpStatus, Request, Body, Logger } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiBearerAuth, ApiOperation, ApiTags, ApiResponse } from '@nestjs/swagger';
import { NotificationsService } from './notifications.service';
import { Notification } from './entities/notification.entity';
import { MarkAsReadByLinkDto } from './dto/mark-as-read-by-link.dto';

@ApiTags('Notifications')
@Controller('notifications')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class NotificationsController {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(NotificationsController.name);

  constructor(private readonly notificationsService: NotificationsService) {}

  @Get()
  @ApiOperation({ summary: "Get current user's notifications" })
  @ApiResponse({ status: 200, description: 'A list of notifications', type: [Notification] })
  getNotifications(@Request() req) {
    this.logger.verbose(`[GET-ALL] User ID: ${req.user.userId} is fetching their notifications.`);
    return this.notificationsService.getForUser(req.user.userId);
  }

  @Post(':id/read')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Mark a specific notification as read' })
  @ApiResponse({ status: 200, description: 'Notification marked as read', type: Notification })
  @ApiResponse({ status: 404, description: 'Notification not found.' })
  markAsRead(@Request() req, @Param('id', ParseIntPipe) id: number) {
    this.logger.log(`[MARK-READ] User ID: ${req.user.userId} is marking notification ID: ${id} as read.`);
    return this.notificationsService.markAsRead(id, req.user.userId);
  }

  @Post('read-all')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Mark all notifications as read' })
  @ApiResponse({ status: 200, description: 'All notifications marked as read.' })
  markAllAsRead(@Request() req) {
    this.logger.log(`[MARK-ALL-READ] User ID: ${req.user.userId} is marking all their notifications as read.`);
    return this.notificationsService.markAllAsRead(req.user.userId);
  }

  @Post('read-by-link')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Mark notifications as read by link' })
  @ApiResponse({ status: 200, description: 'Notifications marked as read.' })
  markAsReadByLink(@Request() req, @Body() dto: MarkAsReadByLinkDto) {
    this.logger.log(`[MARK-READ-LINK] User ID: ${req.user.userId} is marking notifications with link '${dto.link}' as read.`);
    return this.notificationsService.markAsReadByLink(req.user.userId, dto.link);
  }
}
--- END FILE: backend/src/notifications/notifications.controller.ts ---



--- START FILE: backend/src/notifications/notifications.module.ts ---

import { Module } from '@nestjs/common';
import { NotificationsService } from './notifications.service';
import { NotificationsController } from './notifications.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Notification } from './entities/notification.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Notification])],
  controllers: [NotificationsController],
  providers: [NotificationsService],
})
export class NotificationsModule {}
--- END FILE: backend/src/notifications/notifications.module.ts ---



--- START FILE: backend/src/notifications/notifications.service.ts ---

// backend/src/notifications/notifications.service.ts

import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Notification } from './entities/notification.entity';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { OnEvent } from '@nestjs/event-emitter';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class NotificationsService {
  // Logger —É–∂–µ –±—ã–ª, –æ—Ç–ª–∏—á–Ω–æ!
  private readonly logger = new Logger(NotificationsService.name);

  constructor(
    @InjectRepository(Notification)
    private notificationsRepository: Repository<Notification>,
    private eventEmitter: EventEmitter2,
  ) {}

  private async create(user: User, title: string, message: string, type: string, link: string | null = null): Promise<void> {
    try {
      const notification = this.notificationsRepository.create({
        user,
        title,
        message,
        type,
        link,
      });
      const savedNotification = await this.notificationsRepository.save(notification);
      
      const populatedNotification = await this.notificationsRepository.findOne({
          where: { notification_id: savedNotification.notification_id },
          relations: ['user']
      });

      // --- –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫—É —Å–æ–±—ã—Ç–∏—è ---
      this.logger.log(`[CREATE-SUCCESS] Created notification (ID: ${savedNotification.notification_id}, Type: ${type}) for User ID: ${user.id}.`);
      this.eventEmitter.emit('notification.created', populatedNotification);
      
    } catch (error) {
      // --- –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å ---
      this.logger.error(`[CREATE-FAIL] Failed to create notification for User ID: ${user.id}. Title: ${title}`, error.stack);
    }
  }

  @OnEvent('friendship.accepted', { async: true })
  async handleFriendshipAccepted(payload: { requester: User, receiver: User }) {
    const { requester, receiver } = payload;
    // --- –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è ---
    this.logger.verbose(`[EVENT] Received 'friendship.accepted' for requester ID: ${requester.id} and receiver ID: ${receiver.id}.`);
    const title = 'Friend Request Accepted';
    const message = `${receiver.username} is now your friend.`;
    const link = `/users/${receiver.profile_slug || receiver.id}`; // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞
    await this.create(requester, title, message, 'friendship.accepted', link);
  }

  @OnEvent('friendship.requested', { async: true })
  async handleFriendshipRequested(payload: { requester: User, receiver: User }) {
    const { requester, receiver } = payload;
    this.logger.verbose(`[EVENT] Received 'friendship.requested' from User ID: ${requester.id} to User ID: ${receiver.id}.`);
    const title = 'New Friend Request';
    const message = `${requester.username} wants to be your friend.`;
    const link = `/friends`;
    await this.create(receiver, title, message, 'friendship.requested', link);
  }

  @OnEvent('message.sent', { async: true })
  async handleMessageSent(payload: { sender: User, recipient: User }) {
    const { sender, recipient } = payload;
    this.logger.verbose(`[EVENT] Received 'message.sent' from User ID: ${sender.id} to User ID: ${recipient.id}.`);
    const title = 'New Message';
    const message = `You have a new message from ${sender.username}.`;
    const link = `/messages/${sender.id}`;
    await this.create(recipient, title, message, 'message.sent', link);
  }

  async getForUser(userId: number): Promise<Notification[]> {
    return this.notificationsRepository.find({
      where: { user_id: userId },
      order: { created_at: 'DESC' },
      take: 30, // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—ã–±–æ—Ä–∫—É –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    });
  }

  async markAsRead(notificationId: number, userId: number): Promise<Notification> {
    const notification = await this.notificationsRepository.findOneBy({ 
      notification_id: notificationId, 
      user_id: userId
    });
    if (!notification) {
      this.logger.warn(`[MARK-READ-FAIL] User ID: ${userId} failed to mark notification ID: ${notificationId} as read. Reason: Not found or no permission.`);
      throw new NotFoundException('Notification not found or you do not have permission to access it.');
    }
    notification.read = true;
    this.logger.log(`[MARK-READ-SUCCESS] Notification ID: ${notificationId} was marked as read by User ID: ${userId}.`);
    return this.notificationsRepository.save(notification);
  }

  async markAllAsRead(userId: number): Promise<{ affected?: number }> {
    const result = await this.notificationsRepository.update(
      { user_id: userId, read: false },
      { read: true },
    );
    this.logger.log(`[MARK-ALL-READ-SUCCESS] Marked ${result.affected || 0} notification(s) as read for User ID: ${userId}.`);
    return { affected: result.affected };
  }

  async markAsReadByLink(userId: number, link: string): Promise<{ affected?: number }> {
      const result = await this.notificationsRepository.update(
          { user_id: userId, link: link, read: false },
          { read: true },
      );
      this.logger.log(`[MARK-READ-LINK-SUCCESS] Marked ${result.affected || 0} notification(s) as read for User ID: ${userId} with link: ${link}.`);
      return { affected: result.affected };
  }
}
--- END FILE: backend/src/notifications/notifications.service.ts ---



--- START FILE: backend/src/pages/dto/create-page.dto.ts ---

// backend/src/pages/dto/create-page.dto.ts
import { IsString, IsNotEmpty, MinLength, MaxLength } from 'class-validator';

export class CreatePageDto {
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  @MaxLength(255)
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;
}
--- END FILE: backend/src/pages/dto/create-page.dto.ts ---



--- START FILE: backend/src/pages/dto/update-page.dto.ts ---

// backend/src/pages/dto/update-page.dto.ts
import { IsString, IsOptional, MinLength, MaxLength, IsBoolean } from 'class-validator';
import { Matches } from 'class-validator';

export class UpdatePageDto {
  @IsOptional()
  @IsString()
  @MinLength(3)
  @MaxLength(255)
  title?: string;

  @IsOptional()
  @IsString()
  content?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  @Matches(/^[a-z0-9-]+$/, {
    message: 'Slug can only contain lowercase letters, numbers, and hyphens.',
  })
  slug?: string;

  @IsOptional()
  @IsBoolean()
  is_published?: boolean;
}
--- END FILE: backend/src/pages/dto/update-page.dto.ts ---



--- START FILE: backend/src/pages/entities/page.entity.ts ---

// backend/src/pages/entities/page.entity.ts
import { User } from '../../users/entities/user.entity';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  Index,
} from 'typeorm';

@Entity('custom_pages')
export class CustomPage {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 255 })
  title: string;

  @Index({ unique: true }) // –£–Ω–∏–∫–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–≤—É—Ö —Å—Ç—Ä–∞–Ω–∏—Ü —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –∞–¥—Ä–µ—Å–æ–º
  @Column({ type: 'varchar', length: 255, unique: true })
  slug: string;

  @Column({ type: 'text' }) // –ó–¥–µ—Å—å –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è HTML-–∫–æ–¥ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  content: string;

  @Column({ type: 'boolean', default: false })
  is_published: boolean;

  @Column({ name: 'author_id' })
  author_id: number;

  @ManyToOne(() => User, { onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updated_at: Date;
}
--- END FILE: backend/src/pages/entities/page.entity.ts ---



--- START FILE: backend/src/pages/pages.controller.ts ---

// backend/src/pages/pages.controller.ts
import { Controller, Get, Post, Body, Patch, Param, Delete, ParseIntPipe, UseGuards, Request, Logger, UseInterceptors, UploadedFile } from '@nestjs/common'; // [!code ++]
import { FileInterceptor } from '@nestjs/platform-express'; // [!code ++]
import { diskStorage } from 'multer'; // [!code ++]
import { extname } from 'path'; // [!code ++]
import { PagesService } from './pages.service';
import { CreatePageDto } from './dto/create-page.dto';
import { UpdatePageDto } from './dto/update-page.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { SystemRanks } from '../ranks/ranks.service';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';

const generateUniqueFilename = (req, file, callback) => {
  const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
  const extension = extname(file.originalname);
  callback(null, `${uniqueSuffix}${extension}`);
};

@ApiTags('Custom Pages')
@Controller()
export class PagesController {
  private readonly logger = new Logger(PagesController.name);
  constructor(private readonly pagesService: PagesService) {}

  @Get('p/:slug')
  @ApiOperation({ summary: 'Get a single published custom page by its slug' })
  findOnePublic(@Param('slug') slug: string) {
    this.logger.verbose(`[PUBLIC-REQ] üó£Ô∏è Request for public page /p/${slug}`);
    return this.pagesService.findOnePublic(slug);
  }

  @Post('admin/pages')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Create a new custom page (Admin only)' })
  create(@Body() createPageDto: CreatePageDto, @Request() req) {
    this.logger.log(`[ADMIN-REQ] ‚ú® User ID ${req.user.userId} is creating a new page.`);
    return this.pagesService.create(createPageDto, req.user.userId);
  }

  @Get('admin/pages')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get a list of all custom pages (Admin only)' })
  findAllForAdmin() {
    this.logger.verbose(`[ADMIN-REQ]  Î™©Î°ù Fetching all pages for admin panel.`);
    return this.pagesService.findAllForAdmin();
  }
  
  @Get('admin/pages/:id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get a single page by ID for editing (Admin only)' })
  findOneForAdmin(@Param('id', ParseIntPipe) id: number) {
    this.logger.verbose(`[ADMIN-REQ] üì• Fetching page ${id} for editing.`);
    return this.pagesService.findOneForAdmin(id);
  }

  @Patch('admin/pages/:id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update a custom page (Admin only)' })
  update(@Param('id', ParseIntPipe) id: number, @Body() updatePageDto: UpdatePageDto) {
    this.logger.log(`[ADMIN-REQ] ‚úèÔ∏è Updating page ${id}.`);
    return this.pagesService.update(id, updatePageDto);
  }

  @Delete('admin/pages/:id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Delete a custom page (Admin only)' })
  remove(@Param('id', ParseIntPipe) id: number) {
    this.logger.warn(`[ADMIN-REQ] ‚ùå Deleting page ${id}.`);
    return this.pagesService.remove(id);
  }

   @Post('admin/pages/upload-image')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiBearerAuth()
  @UseInterceptors(FileInterceptor('file', {
      storage: diskStorage({
          destination: './uploads/pages', // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫–∏ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é –ø–∞–ø–∫—É
          filename: generateUniqueFilename,
      }),
  }))
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    this.logger.log(`[PAGE-IMAGE-UPLOAD] üñºÔ∏è Uploaded image ${file.filename} for custom pages.`);
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π URL, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –∫–∞—Ä—Ç–∏–Ω–∫–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞
    return { url: `/uploads/pages/${file.filename}` };
  }
}
--- END FILE: backend/src/pages/pages.controller.ts ---



--- START FILE: backend/src/pages/pages.module.ts ---

// backend/src/pages/pages.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CustomPage } from './entities/page.entity';
import { User } from '../users/entities/user.entity';
import { PagesService } from './pages.service';
import { PagesController } from './pages.controller';

@Module({
  imports: [TypeOrmModule.forFeature([CustomPage, User])],
  providers: [PagesService],
  controllers: [PagesController],
})
export class PagesModule {}
--- END FILE: backend/src/pages/pages.module.ts ---



--- START FILE: backend/src/pages/pages.service.ts ---

// backend/src/pages/pages.service.ts
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CustomPage } from './entities/page.entity';
import { CreatePageDto } from './dto/create-page.dto';
import { UpdatePageDto } from './dto/update-page.dto';
import * as DOMPurify from 'dompurify';
import { JSDOM } from 'jsdom';

@Injectable()
export class PagesService {
  private readonly logger = new Logger(PagesService.name);
  private domPurify;

  constructor(
    @InjectRepository(CustomPage)
    private pagesRepository: Repository<CustomPage>,
  ) {
    const window = new JSDOM('').window;
    this.domPurify = DOMPurify(window);
  }

  async create(createPageDto: CreatePageDto, authorId: number): Promise<CustomPage> {
    const { title, content } = createPageDto;
    this.logger.log(`[CREATE] üìÑ User ID: ${authorId} is creating a new page titled: "${title}"`);

    const sanitizedContent = this.domPurify.sanitize(content);
    const slug = title.toLowerCase().trim().replace(/[^\w\s-]/g, '').replace(/[\s_-]+/g, '-').replace(/^-+|-+$/g, '');

    const newPage = this.pagesRepository.create({
      title,
      slug,
      content: sanitizedContent,
      author_id: authorId,
      is_published: false,
    });
    return this.pagesRepository.save(newPage);
  }

  findAllForAdmin(): Promise<CustomPage[]> {
    this.logger.verbose('[GET-ALL-ADMIN] üîé Fetching all custom pages for admin panel.');
    return this.pagesRepository.find({ order: { updated_at: 'DESC' } });
  }
  
  async findOneForAdmin(id: number): Promise<CustomPage> {
    this.logger.verbose(`[GET-ONE-ADMIN] üîé Fetching page ID: ${id} for admin panel.`);
    const page = await this.pagesRepository.findOneBy({ id });
    if (!page) throw new NotFoundException(`Page with ID ${id} not found.`);
    return page;
  }

  async update(id: number, updatePageDto: UpdatePageDto): Promise<CustomPage> {
    this.logger.log(`[UPDATE] üìù Updating page ID: ${id}`);
    const page = await this.findOneForAdmin(id);
    if (updatePageDto.content) {
      updatePageDto.content = this.domPurify.sanitize(updatePageDto.content);
    }
    Object.assign(page, updatePageDto);
    return this.pagesRepository.save(page);
  }

  async remove(id: number): Promise<void> {
    this.logger.warn(`[DELETE] üóëÔ∏è Deleting page ID: ${id}`);
    const result = await this.pagesRepository.delete(id);
    if (result.affected === 0) throw new NotFoundException(`Page with ID ${id} not found.`);
  }

  async findOnePublic(slug: string): Promise<CustomPage> {
    this.logger.verbose(`[GET-PUBLIC] üîé Public request for page with slug: ${slug}`);
    const page = await this.pagesRepository.findOne({ where: { slug, is_published: true } });
    if (!page) throw new NotFoundException('This page does not exist or is not published.');
    return page;
  }
}
--- END FILE: backend/src/pages/pages.service.ts ---



--- START FILE: backend/src/posts/dto/create-post.dto.ts ---

import { IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreatePostDto {
  @ApiProperty({ 
    example: 'My First Amazing Post!', 
    description: 'The title of the post', 
    minLength: 5, 
    maxLength: 100 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(5)
  @MaxLength(100)
  title: string;

  @ApiProperty({ 
    example: 'This is the detailed content of my first amazing post. It can be quite long and support markdown in the future!', 
    description: 'The main content of the post', 
    minLength: 10 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(10)
  content: string;
}
--- END FILE: backend/src/posts/dto/create-post.dto.ts ---



--- START FILE: backend/src/posts/dto/find-all-posts.ts ---

// backend/src/posts/dto/find-all-posts.ts

// --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º IsInt, Min, Max –∏ Type ---
import { IsEnum, IsOptional, IsString, IsInt, Min, Max } from 'class-validator';
import { Type } from 'class-transformer';

export class FindAllPostsDto {
  @IsOptional()
  @IsEnum(['created_at', 'score'])
  sortBy?: 'created_at' | 'score' = 'created_at';

  @IsOptional()
  @IsEnum(['ASC', 'DESC'])
  order?: 'ASC' | 'DESC' = 'DESC';

  @IsOptional()
  @IsString()
  search?: string;

  // --- –ù–û–í–´–ï –ü–û–õ–Ø –î–õ–Ø –ü–ê–ì–ò–ù–ê–¶–ò–ò ---
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 10;
}
--- END FILE: backend/src/posts/dto/find-all-posts.ts ---



--- START FILE: backend/src/posts/dto/update-post.dto.ts ---

import { IsOptional, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';

export class UpdatePostDto {
  @ApiPropertyOptional({ 
    example: 'My Updated Post Title', 
    description: 'The updated title of the post (optional)', 
    minLength: 5, 
    maxLength: 100 
  })
  @IsOptional()
  @IsString()
  @MinLength(5)
  @MaxLength(100)
  title?: string;

  @ApiPropertyOptional({ 
    example: 'This is the updated detailed content.', 
    description: 'The updated main content of the post (optional)', 
    minLength: 10 
  })
  @IsOptional()
  @IsString()
  @MinLength(10)
  content?: string;
}
--- END FILE: backend/src/posts/dto/update-post.dto.ts ---



--- START FILE: backend/src/posts/entities/post.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { Vote } from '../../votes/entities/vote.entity';

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'author_id', nullable: true })
  author_id: number | null;

  @ManyToOne(() => User, (user) => user.posts, { onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'author_id' })
  author: User | null;

  @Column({ type: 'varchar', length: 100 }) 
  title: string;

  @CreateDateColumn({ type: 'timestamp', name: 'created_at', default: () => 'CURRENT_TIMESTAMP' })
  created_at: Date;

  @Column({ type: 'text' })
  content: string;

  @UpdateDateColumn({ type: 'timestamp', name: 'updated_at', default: () => 'CURRENT_TIMESTAMP', onUpdate: 'CURRENT_TIMESTAMP' })
  updated_at: Date;

  @OneToMany(() => Comment, (comment) => comment.post)
  comments: Comment[];

  @OneToMany(() => Vote, (vote) => vote.post)
  votes: Vote[];
}
--- END FILE: backend/src/posts/entities/post.entity.ts ---



--- START FILE: backend/src/posts/posts.controller.ts ---

// backend/src/posts/posts.controller.ts

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Request,
  ParseIntPipe,
  UsePipes,
  ValidationPipe,
  Query,
  Logger, // <-- –î–æ–±–∞–≤–ª–µ–Ω–æ
} from '@nestjs/common';
import { PostsService } from './posts.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { Post as PostEntity } from './entities/post.entity';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';
import { FindAllPostsDto } from './dto/find-all-posts';

@ApiTags('Posts') 
@Controller('posts')
export class PostsController {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(PostsController.name);

  constructor(private readonly postsService: PostsService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth() 
  @ApiOperation({ summary: 'Create a new post' })
  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))
  create(@Body() createPostDto: CreatePostDto, @Request() req): Promise<PostEntity> {
    const authorId = req.user.userId;
    this.logger.log(`[CREATE] üí¨ User ID: ${authorId} is creating a new post titled "${createPostDto.title}"`);
    return this.postsService.create(createPostDto, authorId);
  }

  @Get()
  @ApiOperation({ summary: 'Get all posts' })
  findAll(@Query(new ValidationPipe({ transform: true, forbidNonWhitelisted: true })) query: FindAllPostsDto) {
    this.logger.verbose(`[GET-ALL] üîé Fetching all posts with query: ${JSON.stringify(query)}`);
    return this.postsService.findAll(query);
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  @ApiOperation({ summary: 'Get a specific post by ID' })
  findOne(@Param('id', ParseIntPipe) id: number, @Request() req) {
    const userId = req.user ? req.user.userId : null;
    this.logger.verbose(`[GET-ONE] üîé Fetching post ID: ${id} for User ID: ${userId || 'Guest'}`);
    return this.postsService.findOne(id, userId);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth() 
  @ApiOperation({ summary: 'Update a post' })
  @UsePipes(new ValidationPipe({ whitelist: true, skipMissingProperties: true, forbidNonWhitelisted: true }))
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updatePostDto: UpdatePostDto,
    @Request() req,
  ): Promise<PostEntity> {
    const userId = req.user.userId;
    this.logger.log(`[UPDATE] üìù User ID: ${userId} is attempting to update Post ID: ${id}`);
    return this.postsService.update(id, updatePostDto, userId);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth() 
  @ApiOperation({ summary: 'Delete a post' })
  remove(@Param('id', ParseIntPipe) id: number, @Request() req): Promise<void> {
    const userId = req.user.userId;
    this.logger.warn(`[DELETE] üóëÔ∏è User ID: ${userId} is attempting to delete Post ID: ${id}`);
    return this.postsService.remove(id, userId);
  }
}
--- END FILE: backend/src/posts/posts.controller.ts ---



--- START FILE: backend/src/posts/posts.module.ts ---

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PostsService } from './posts.service';
import { PostsController } from './posts.controller';
import { Post } from './entities/post.entity';
// User –±–æ–ª—å—à–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ UsersModule –≥–ª–æ–±–∞–ª—å–Ω—ã–π
// –ù–æ TypeOrmModule.forFeature([User]) –Ω—É–∂–µ–Ω, –µ—Å–ª–∏ –º—ã –µ–≥–æ –∑–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ–º.
// –í –Ω–∞—à–µ–º PostsService –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º UserRepository, —Ç–∞–∫ —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º.
import { User } from '../users/entities/user.entity';


@Module({
  imports: [
    TypeOrmModule.forFeature([Post, User])
  ],
  controllers: [PostsController],
  providers: [PostsService],
})
export class PostsModule {}
--- END FILE: backend/src/posts/posts.module.ts ---



--- START FILE: backend/src/posts/posts.service.ts ---

// backend/src/posts/posts.service.ts

import { Injectable, NotFoundException, ForbiddenException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from './entities/post.entity';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { User } from '../users/entities/user.entity';
import { FindAllPostsDto } from './dto/find-all-posts';
import { SystemRanks } from '../ranks/ranks.service';

@Injectable()
export class PostsService {
  // --- –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Logger ---
  private readonly logger = new Logger(PostsService.name);

  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) { }

  async create(createPostDto: CreatePostDto, authorId: number): Promise<Post> {
    const author = await this.usersRepository.findOne({ where: { id: authorId } });
    if (!author) {
      this.logger.error(`[CREATE-FAIL] ‚ùå Author with ID ${authorId} not found. Cannot create post.`);
      throw new ForbiddenException('User not found or not authorized to create a post.');
    }

    const post = this.postsRepository.create({ ...createPostDto, author });
    const savedPost = await this.postsRepository.save(post);
    this.logger.log(`[CREATE-SUCCESS] ‚úÖ User ID: ${authorId} created Post ID: ${savedPost.id}.`);
    return savedPost;
  }

  async findAll(queryDto: FindAllPostsDto): Promise<{ data: any[], total: number }> {
    const { sortBy, order, search, page = 1, limit = 10 } = queryDto;
    this.logger.verbose(`[DB-QUERY] üíæ Executing findAll with page: ${page}, limit: ${limit}, sortBy: ${sortBy}, order: ${order}, search: ${search || 'none'}`);
    
    const queryBuilder = this.postsRepository.createQueryBuilder('post');

    queryBuilder
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('author.rank', 'rank')
      .addSelect('COALESCE(SUM(votes.value), 0)', 'score')
      .leftJoin('post.votes', 'votes')
      .groupBy('post.id, author.id, rank.id');

    if (search) {
      queryBuilder.where('post.title ILIKE :search', { search: `%${search}%` });
    }

    queryBuilder.orderBy(sortBy === 'score' ? 'score' : `post.${sortBy}`, order as 'ASC' | 'DESC');
    
    queryBuilder.take(limit).skip((page - 1) * limit);

    const [entities, total] = await queryBuilder.getManyAndCount();
    const rawEntities = await queryBuilder.getRawMany();
    
    const postsWithScores = entities.map(post => {
        const rawPost = rawEntities.find(raw => raw.post_id === post.id);
        return { ...post, score: rawPost ? parseInt(rawPost.score, 10) : 0 };
    });

    this.logger.verbose(`[DB-RESULT] üíæ Found ${total} total posts, returning ${postsWithScores.length}.`);
    return { data: postsWithScores, total };
  }


  async findOne(id: number, userId?: number): Promise<any> {
    const post = await this.postsRepository.findOne({
      where: { id },
      relations: ['author', 'author.rank', 'comments', 'comments.author', 'comments.author.rank', 'votes', 'comments.votes', 'votes.voter', 'comments.votes.voter'],
      order: { comments: { created_at: "ASC" } },
    });
    if (!post) {
      this.logger.warn(`[GET-ONE-FAIL] ‚ö†Ô∏è Post with ID ${id} not found.`);
      throw new NotFoundException(`Post with ID ${id} not found.`);
    }

    const mapVotes = (entity: any, currentUserId?: number) => {
      if (!entity.votes) return { ...entity, likes: 0, dislikes: 0, currentUserVote: 0 };
      const likes = entity.votes.filter(v => v.value === 1).length;
      const dislikes = entity.votes.filter(v => v.value === -1).length;
      const vote = currentUserId ? entity.votes.find(v => v.voter.id === currentUserId) : null;
      const { votes, ...restOfEntity } = entity;
      return { ...restOfEntity, likes, dislikes, currentUserVote: vote ? vote.value : 0 };
    };

    const postWithVotes = mapVotes(post, userId);
    if (post.comments) {
      postWithVotes.comments = post.comments.map(comment => mapVotes(comment, userId));
    }

    return postWithVotes;
  }

  async update(id: number, updatePostDto: UpdatePostDto, userId: number): Promise<Post> {
    const post = await this.postsRepository.findOne({ where: { id }, relations: ['author'] });
    if (!post) {
      this.logger.warn(`[UPDATE-FAIL] ‚ö†Ô∏è Post with ID: ${id} not found for update attempt by User ID: ${userId}.`);
      throw new NotFoundException(`Post with ID ${id} not found.`);
    }

    const user = await this.usersRepository.findOne({ where: { id: userId }, relations: ['rank'] });
    if (!user) {
      this.logger.error(`[UPDATE-FAIL] ‚ùå User performing update action not found. User ID: ${userId}`);
      throw new ForbiddenException('User performing the action not found.');
    }

    const isAuthor = post.author_id === userId;
    const canManagePosts = user.rank && user.rank.power_level >= SystemRanks.MODERATOR.power_level;

    if (!isAuthor && !canManagePosts) {
      this.logger.warn(`[UPDATE-FORBIDDEN] üö´ User ID: ${userId} (Rank: ${user.rank?.name}) failed to update Post ID: ${id}. Reason: Not author or moderator.`);
      throw new ForbiddenException('You are not authorized to update this post.');
    }
    
    await this.postsRepository.update(id, updatePostDto);
    this.logger.log(`[UPDATE-SUCCESS] ‚úÖ Post ID: ${id} updated by User ID: ${userId}.`);
    return this.findOne(id, userId);
  }

  async remove(id: number, userId: number): Promise<void> {
    const post = await this.postsRepository.findOne({ where: { id }, relations: ['author'] });
    if (!post) {
      this.logger.warn(`[DELETE-FAIL] ‚ö†Ô∏è Post with ID: ${id} not found for delete attempt by User ID: ${userId}.`);
      throw new NotFoundException(`Post with ID ${id} not found.`);
    }

    const user = await this.usersRepository.findOne({ where: { id: userId }, relations: ['rank'] });
    if (!user) {
      this.logger.error(`[DELETE-FAIL] ‚ùå User performing delete action not found. User ID: ${userId}`);
      throw new ForbiddenException('User performing the action not found.');
    }

    const isAuthor = post.author_id === userId;
    const canManagePosts = user.rank && user.rank.power_level >= SystemRanks.MODERATOR.power_level;

    if (!isAuthor && !canManagePosts) {
      this.logger.warn(`[DELETE-FORBIDDEN] üö´ User ID: ${userId} (Rank: ${user.rank?.name}) failed to delete Post ID: ${id}. Reason: Not author or moderator.`);
      throw new ForbiddenException('You are not authorized to delete this post.');
    }
    
    await this.postsRepository.remove(post);
    this.logger.warn(`[DELETE-SUCCESS] ‚úÖ Post ID: ${id} was deleted by User ID: ${userId}.`);
  }
}
--- END FILE: backend/src/posts/posts.service.ts ---



--- START FILE: backend/src/purchases/dto/update-purchase.dto.ts ---


--- END FILE: backend/src/purchases/dto/update-purchase.dto.ts ---



--- START FILE: backend/src/purchases/entities/purchase.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { ShopItem } from '../../shop/entities/shop-item.entity';

@Entity('purchases')
export class Purchase {
  @PrimaryGeneratedColumn({ name: 'purchase_id' })
  purchase_id: number;

  @Column({ name: 'user_id' })
  user_id: number;

  @ManyToOne(() => User, (user) => user.purchases, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'item_id' })
  item_id: number;

  @ManyToOne(() => ShopItem, (item) => item.purchases, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'item_id' })
  item: ShopItem;

  @Column({ type: 'integer', name: 'purchase_price' })
  purchase_price: number;

  @CreateDateColumn({ type: 'timestamp', name: 'purchased_at', default: () => 'CURRENT_TIMESTAMP' })
  purchased_at: Date;

  @Column({ type: 'varchar', length: 20, default: 'COMPLETED' })
  status: string;
}
--- END FILE: backend/src/purchases/entities/purchase.entity.ts ---



--- START FILE: backend/src/purchases/purchases.controller.ts ---


--- END FILE: backend/src/purchases/purchases.controller.ts ---



--- START FILE: backend/src/purchases/purchases.module.ts ---


--- END FILE: backend/src/purchases/purchases.module.ts ---



--- START FILE: backend/src/purchases/purchases.service.ts ---


--- END FILE: backend/src/purchases/purchases.service.ts ---



--- START FILE: backend/src/ranks/dto/create-rank.dto.ts ---

// backend/src/ranks/dto/create-rank.dto.ts
import { IsString, IsNotEmpty, MaxLength, Matches, IsInt, Min, Max, IsOptional } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateRankDto {
  @ApiProperty({ example: 'Super VIP', description: 'The display name of the rank' })
  @IsString()
  @IsNotEmpty()
  @MaxLength(50)
  name: string;

  @ApiProperty({ example: 'supervip', description: 'The system name for in-game matching (no spaces, lowercase)' })
  @IsString()
  @IsNotEmpty()
  @MaxLength(50)
  @Matches(/^[a-z0-9_-]+$/, { message: 'System name can only contain lowercase letters, numbers, hyphens, and underscores.' })
  system_name: string;

  @ApiProperty({ example: 999, description: 'Power level (1-999)' })
  @IsInt()
  @Min(1)
  @Max(999) // <-- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º –¥–æ 999
  power_level: number;

  @ApiProperty({ example: '#FFD700', description: 'Hex color code for display' })
  @IsString()
  @Matches(/^#[0-9a-fA-F]{6}$/, { message: 'Color must be a valid hex code (e.g., #RRGGBB)' })
  display_color: string;

  // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –î–û–ë–ê–í–õ–Ø–ï–ú –ù–û–í–´–ï –ü–û–õ–Ø ---
  @ApiPropertyOptional({ example: 'lp user {username} parent set owner', description: 'Command template for issuing the rank.' })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  command_template?: string;

  @ApiPropertyOptional({ example: 'lp user {username} parent remove owner', description: 'Command template for removing the rank.' })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  command_template_remove?: string;
}
--- END FILE: backend/src/ranks/dto/create-rank.dto.ts ---



--- START FILE: backend/src/ranks/dto/update-rank.dto.ts ---

import { PartialType } from '@nestjs/swagger';
import { CreateRankDto } from './create-rank.dto';

export class UpdateRankDto extends PartialType(CreateRankDto) {}
--- END FILE: backend/src/ranks/dto/update-rank.dto.ts ---



--- START FILE: backend/src/ranks/entities/rank.entity.ts ---

// backend/src/ranks/entities/rank.entity.ts

import { User } from '../../users/entities/user.entity';
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, Index } from 'typeorm';

@Entity('ranks')
export class Rank {
  @PrimaryGeneratedColumn()
  id: number;

  @Index({ unique: true })
  @Column({ type: 'varchar', length: 50 })
  name: string; // –≠—Ç–æ —Ç–µ–ø–µ—Ä—å –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è

  @Index({ unique: true })
  @Column({ type: 'varchar', length: 50, name: 'system_name' })
  system_name: string; 

  @Index({ unique: true })
  @Column({ type: 'int' })
  power_level: number;

  @Column({ type: 'varchar', length: 7, default: '#808080' })
  display_color: string;

  @Column({ type: 'boolean', default: true })
  is_removable: boolean;

    @Column({ type: 'varchar', length: 255, name: 'command_template', nullable: true })
  command_template: string | null;

  @Column({ type: 'varchar', length: 255, name: 'command_template_remove', nullable: true })
  command_template_remove: string | null;
  
  @OneToMany(() => User, (user) => user.rank)
  users: User[]; 
}
--- END FILE: backend/src/ranks/entities/rank.entity.ts ---



--- START FILE: backend/src/ranks/ranks.controller.ts ---

// backend/src/ranks/ranks.controller.ts

import { Controller, Get, Post, Body, Patch, Param, Delete, ParseIntPipe, UseGuards, Logger } from '@nestjs/common';
import { RanksService, SystemRanks } from './ranks.service';
import { CreateRankDto } from './dto/create-rank.dto';
import { UpdateRankDto } from './dto/update-rank.dto';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';

@ApiTags('Ranks')
@Controller('ranks')
@UseGuards(JwtAuthGuard, RolesGuard)
@ApiBearerAuth()
export class RanksController {
  private readonly logger = new Logger(RanksController.name);

  constructor(private readonly ranksService: RanksService) {}

  @Post()
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiOperation({ summary: 'Create a new rank (Admin only)' })
  create(@Body() createRankDto: CreateRankDto) {
    this.logger.log(`[CREATE] üéñÔ∏è Admin is creating a new rank: ${JSON.stringify(createRankDto)}`);
    return this.ranksService.create(createRankDto);
  }

  @Get()
  @Roles(SystemRanks.MODERATOR.power_level)
  @ApiOperation({ summary: 'Get all ranks (Mods+)' })
  findAll() {
    this.logger.verbose(`[GET-ALL] üîé Fetching all ranks.`);
    return this.ranksService.findAll();
  }

  @Patch(':id')
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiOperation({ summary: 'Update a rank (Admin only)' })
  update(@Param('id', ParseIntPipe) id: number, @Body() updateRankDto: UpdateRankDto) {
    this.logger.log(`[UPDATE] üìù Admin is attempting to update Rank ID: ${id} with data: ${JSON.stringify(updateRankDto)}`);
    return this.ranksService.update(id, updateRankDto);
  }

  @Delete(':id')
  @Roles(SystemRanks.ADMIN.power_level)
  @ApiOperation({ summary: 'Delete a rank (Admin only)' })
  remove(
    @Param('id', ParseIntPipe) id: number,
    @Body('migrationRankId') migrationRankId?: number
  ) {
    this.logger.warn(`[DELETE] üóëÔ∏è Admin is attempting to delete Rank ID: ${id}. Migration Target ID: ${migrationRankId || 'N/A'}`);
    return this.ranksService.remove(id, migrationRankId);
  }
}
--- END FILE: backend/src/ranks/ranks.controller.ts ---



--- START FILE: backend/src/ranks/ranks.module.ts ---

// backend/src/ranks/ranks.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { RanksService } from './ranks.service';
import { RanksController } from './ranks.controller';
import { Rank } from './entities/rank.entity';
import { User } from 'src/users/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Rank, User])],
  controllers: [RanksController],
  providers: [RanksService],
  exports: [RanksService] // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
})
export class RanksModule {}
--- END FILE: backend/src/ranks/ranks.module.ts ---



--- START FILE: backend/src/ranks/ranks.service.ts ---

// backend/src/ranks/ranks.service.ts

import { Injectable, OnModuleInit, NotFoundException, ConflictException, InternalServerErrorException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, ILike, Repository } from 'typeorm';
import { Rank } from './entities/rank.entity';
import { CreateRankDto } from './dto/create-rank.dto';
import { UpdateRankDto } from './dto/update-rank.dto';
import { User } from 'src/users/entities/user.entity';

export const SystemRanks = {
  OWNER: { id: 1, name: 'Owner', system_name: 'owner', power_level: 999, display_color: '#AA0000', is_removable: false },
  ADMIN: { id: 2, name: 'Admin', system_name: 'admin', power_level: 900, display_color: '#FF5555', is_removable: false },
  MODERATOR: { id: 3, name: 'Moderator', system_name: 'moderator', power_level: 800, display_color: '#5555FF', is_removable: false },
  DEFAULT: { id: 4, name: 'Default', system_name: 'default', power_level: 1, display_color: '#AAAAAA', is_removable: false },
};

@Injectable()
export class RanksService implements OnModuleInit {
  private readonly logger = new Logger(RanksService.name);

  constructor(
    @InjectRepository(Rank)
    private ranksRepository: Repository<Rank>,
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    private dataSource: DataSource,
  ) { }

  async onModuleInit() {

    if (process.env.NODE_ENV === 'migration') {
      this.logger.log('Migration mode detected. Skipping initial rank seeding.');
      return;
    }

    this.logger.log(`[SEED] üå± Checking for initial system ranks on module initialization...`);
    await this.seedInitialRanks();
  }

  private async seedInitialRanks() {
    for (const rankDetails of Object.values(SystemRanks)) {
      const rankExists = await this.ranksRepository.findOneBy({ id: rankDetails.id });
      if (!rankExists) {
        this.logger.log(`[SEED] üå± System rank "${rankDetails.name}" not found. Seeding now...`);
        const newRank = this.ranksRepository.create(rankDetails);
        await this.ranksRepository.save(newRank);
      } else {
        this.logger.verbose(`[SEED] üå± System rank "${rankDetails.name}" already exists. Skipping.`);
      }
    }
  }

  async create(createRankDto: CreateRankDto): Promise<Rank> {
    const existingRank = await this.ranksRepository.findOne({
      where: [{ name: createRankDto.name }, { power_level: createRankDto.power_level }, { system_name: createRankDto.system_name }]
    });
    if (existingRank) {
      this.logger.warn(`[CREATE-FAIL] ‚ö†Ô∏è Conflict: Rank with this name, system_name, or power level already exists. Input: ${JSON.stringify(createRankDto)}`);
      throw new ConflictException('Rank with this name, system_name, or power level already exists.');
    }

    const rank = this.ranksRepository.create(createRankDto);
    const savedRank = await this.ranksRepository.save(rank);
    this.logger.log(`[CREATE-SUCCESS] ‚úÖ Successfully created rank "${savedRank.name}" with ID: ${savedRank.id}`);
    return savedRank;
  }

  findAll(): Promise<Rank[]> {
    return this.ranksRepository.find({ order: { power_level: 'DESC' } });
  }

  async findOne(id: number): Promise<Rank> {
    const rank = await this.ranksRepository.findOneBy({ id });
    if (!rank) {
      this.logger.warn(`[GET-ONE-FAIL] ‚ö†Ô∏è Rank with ID ${id} not found.`);
      throw new NotFoundException(`Rank with ID ${id} not found.`);
    }
    return rank;
  }

  async update(id: number, updateRankDto: UpdateRankDto): Promise<Rank> {
    const rank = await this.findOne(id);
    if (!rank.is_removable) {
      if (updateRankDto.power_level || updateRankDto.system_name) {
        this.logger.warn(`[UPDATE-DENIED] üö´ Attempt to change power_level or system_name of a non-removable system rank (ID: ${id}) was prevented.`);
      }
      delete updateRankDto.power_level;
      delete updateRankDto.system_name;
    }

    Object.assign(rank, updateRankDto);
    const updatedRank = await this.ranksRepository.save(rank);
    this.logger.log(`[UPDATE-SUCCESS] ‚úÖ Rank ID: ${id} ("${updatedRank.name}") was successfully updated.`);
    return updatedRank;
  }

  async remove(id: number, migrationRankId?: number): Promise<void> {
    this.logger.log(`[DELETE-TX-START] üóëÔ∏è Starting transaction to delete Rank ID: ${id}.`);
    return this.dataSource.transaction(async (manager) => {
      const rankToRemove = await manager.findOneBy(Rank, { id });

      if (!rankToRemove) {
        throw new NotFoundException(`Rank with ID ${id} not found.`);
      }
      if (!rankToRemove.is_removable) {
        this.logger.error(`[DELETE-FAIL] üö´ Attempt to delete a non-removable system rank (ID: ${id}).`);
        throw new ConflictException('Cannot delete a system rank.');
      }

      const usersWithRank = await manager.find(User, { where: { rank_id: id } });

      if (usersWithRank.length > 0) {
        if (!migrationRankId) {
          this.logger.warn(`[DELETE-CONFLICT] ‚ö†Ô∏è Rank ID ${id} is assigned to ${usersWithRank.length} user(s). Migration rank ID is required.`);
          throw new ConflictException(`Rank is currently assigned to ${usersWithRank.length} user(s). Please provide a migration rank.`);
        }
        if (migrationRankId === id) {
          this.logger.error(`[DELETE-FAIL] ‚ùå Cannot migrate users to the same rank that is being deleted (ID: ${id}).`);
          throw new ConflictException('Cannot migrate users to the same rank that is being deleted.');
        }
        const migrationRank = await manager.findOneBy(Rank, { id: migrationRankId });
        if (!migrationRank) {
          this.logger.error(`[DELETE-FAIL] ‚ùå Migration target rank with ID ${migrationRankId} not found.`);
          throw new NotFoundException(`Migration rank with ID ${migrationRankId} not found.`);
        }

        const userIdsToUpdate = usersWithRank.map(user => user.id);
        this.logger.log(`[DELETE-MIGRATE] ‚û°Ô∏è Migrating ${userIdsToUpdate.length} user(s) to Rank ID: ${migrationRankId} ("${migrationRank.name}")...`);
        await manager.update(User, userIdsToUpdate, { rank_id: migrationRankId });
      } else {
        this.logger.log(`[DELETE] ‚û°Ô∏è No users assigned to Rank ID ${id}. Proceeding with simple deletion.`);
      }

      await manager.remove(Rank, rankToRemove);
      this.logger.warn(`[DELETE-SUCCESS] ‚úÖ Successfully deleted Rank ID: ${id} ("${rankToRemove.name}") and migrated users (if any).`);
    });
  }

  // –î—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ä–∞–Ω–≥–æ–≤
  async findDefaultRank(): Promise<Rank> {
    const rank = await this.ranksRepository.findOneBy({ id: SystemRanks.DEFAULT.id });
    if (!rank) throw new InternalServerErrorException('Default rank not found in database.');
    return rank;
  }

  async findRankBySystemName(systemName: string): Promise<Rank | null> {
    this.logger.verbose(`[DB-QUERY] üíæ Finding rank by system_name: ${systemName}`);
    return this.ranksRepository.findOne({ where: { system_name: ILike(systemName) } });
  }

  async findOwnerRank(): Promise<Rank> {
    const rank = await this.ranksRepository.findOneBy({ id: SystemRanks.OWNER.id });
    if (!rank) throw new InternalServerErrorException('Owner rank not found in database.');
    return rank;
  }
}
--- END FILE: backend/src/ranks/ranks.service.ts ---



--- START FILE: backend/src/shop/dto/admin-shop.dto.ts ---

// backend/src/shop/dto/admin-shop.dto.ts
import { IsString, IsInt, IsBoolean, IsOptional, IsUrl, Min, MaxLength, IsNotEmpty } from 'class-validator';

export class CreateShopDto {
  @IsString({ message: 'Name must be a string.' })
  @IsNotEmpty({ message: 'Name should not be empty.' })
  @MaxLength(100)
  name: string;

  @IsString()
  @IsOptional() // –î–µ–ª–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º
  @MaxLength(500)
  description: string;

  @IsInt({ message: 'Price must be an integer.' })
  @Min(0, { message: 'Price cannot be negative.' })
  price: number;

  @IsOptional()
  @IsUrl({}, { message: 'Image URL must be a valid URL.' })
  @MaxLength(255)
  image_url?: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  ingame_command: string;

  @IsBoolean()
  is_active: boolean;

  @IsString()
  @IsNotEmpty()
  @MaxLength(50)
  category: string;
}

// DTO –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è, –≥–¥–µ –≤—Å–µ –ø–æ–ª—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
export class UpdateShopDto {
  @IsOptional() @IsString() @MaxLength(100) name?: string;
  @IsOptional() @IsString() @MaxLength(500) description?: string;
  @IsOptional() @IsInt() @Min(0) price?: number;
  @IsOptional() @IsUrl() @MaxLength(255) image_url?: string;
  @IsOptional() @IsString() @MaxLength(255) ingame_command?: string;
  @IsOptional() @IsBoolean() is_active?: boolean;
  @IsOptional() @IsString() @MaxLength(50) category?: string;
}
--- END FILE: backend/src/shop/dto/admin-shop.dto.ts ---



--- START FILE: backend/src/shop/dto/purchase.dto.ts ---

import { IsInt, IsOptional, IsString, MinLength } from 'class-validator';
export class PurchaseDto {
  @IsInt()
  itemId: number;

  @IsOptional()
  @IsString()
  @MinLength(3)
  targetUsername?: string;
}
--- END FILE: backend/src/shop/dto/purchase.dto.ts ---



--- START FILE: backend/src/shop/entities/pending-command.entity.ts ---

// backend/src/shop/entities/pending-command.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from 'typeorm';

@Entity('pending_commands')
export class PendingCommand {
    @PrimaryGeneratedColumn()
    id: number;

    // –ì–æ—Ç–æ–≤–∞—è –∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é –∫–æ–º–∞–Ω–¥–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "lp user Steve parent set vip"
    @Column({ type: 'varchar', length: 255 })
    command: string;

    @CreateDateColumn({ name: 'created_at' })
    created_at: Date;
}
--- END FILE: backend/src/shop/entities/pending-command.entity.ts ---



--- START FILE: backend/src/shop/entities/shop-item.entity.ts ---

// backend/src/shop/entities/shop-item.entity.ts
import { Purchase } from '../../purchases/entities/purchase.entity';
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';

@Entity('shop_items')
export class ShopItem {
  @PrimaryGeneratedColumn({ name: 'item_id' })
  item_id: number;

  @Column({ type: 'varchar', length: 100 })
  name: string; // –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "VIP –°—Ç–∞—Ç—É—Å –Ω–∞ 30 –¥–Ω–µ–π" 

  @Column({ type: 'text', nullable: true })
  description: string | null; // –û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Å–∞–π—Ç–∞ 

  @Column({ type: 'integer' })
  price: number; // –¶–µ–Ω–∞ –≤ –¥–æ–Ω–∞—Ç–Ω–æ–π –≤–∞–ª—é—Ç–µ (–±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) 

  @Column({ type: 'varchar', length: 255, nullable: true, name: 'image_url' })
  image_url: string | null; // –°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫—É —Ç–æ–≤–∞—Ä–∞ 

  @Column({ type: 'varchar', length: 255 })
  ingame_command: string; // –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –ü—Ä–∏–º–µ—Ä: "lp user {username} parent set vip" 

  @Column({ type: 'boolean', default: true, name: 'is_active' })
  is_active: boolean; // –ú–æ–∂–Ω–æ –ª–∏ –∫—É–ø–∏—Ç—å —ç—Ç–æ—Ç —Ç–æ–≤–∞—Ä —Å–µ–π—á–∞—Å 
  
  @Column({ type: 'varchar', length: 50, default: 'items' })
  category: string; // –ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞ —Å–∞–π—Ç–µ 

  @CreateDateColumn({ name: 'created_at' })
  created_at: Date; // 

  @UpdateDateColumn({ name: 'updated_at' })
  updated_at: Date; // 

    @OneToMany(() => Purchase, (purchase) => purchase.item)
  purchases: Purchase[];
}
--- END FILE: backend/src/shop/entities/shop-item.entity.ts ---



--- START FILE: backend/src/shop/shop.controller.ts ---

// backend/src/shop/shop.controller.ts
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Request, ParseIntPipe, Logger } from '@nestjs/common';
import { ShopService } from './shop.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { SystemRanks } from '../ranks/ranks.service';
import { PluginApiKeyGuard } from '../auth/guards/plugin-api-key.guard';
import { PurchaseDto } from './dto/purchase.dto';
import { CreateShopDto, UpdateShopDto } from './dto/admin-shop.dto';

@Controller('shop')
export class ShopController {
  private readonly logger = new Logger(ShopController.name);

  constructor(private readonly shopService: ShopService) {}

  @Get()
  findAllActive() {
    this.logger.verbose('üîé Fetching all active shop items for a user.');
    return this.shopService.findAllActive();
  }

  @Post('purchase')
  @UseGuards(JwtAuthGuard)
  purchaseItem(@Body() purchaseDto: PurchaseDto, @Request() req) {
    this.logger.log(`[PURCHASE] üí≥ User ID: ${req.user.userId} is attempting to purchase Item ID: ${purchaseDto.itemId} for target: "${purchaseDto.targetUsername || 'self'}".`);
    return this.shopService.purchase(purchaseDto, req.user.userId);
  }

  @Get('pending-commands')
  @UseGuards(PluginApiKeyGuard)
  getPendingCommands() {
    this.logger.log('[PLUGIN-FETCH] üîå Plugin is fetching pending commands.');
    return this.shopService.getPendingCommands();
  }

  @Post('clear-pending-commands')
  @UseGuards(PluginApiKeyGuard)
  clearPendingCommands(@Body('commandIds') commandIds: number[]) {
    this.logger.log(`[PLUGIN-CLEAR] üîå Plugin is clearing ${commandIds?.length || 0} executed command(s). IDs: [${commandIds?.join(', ')}]`);
    return this.shopService.clearPendingCommands(commandIds);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  create(@Body() createDto: CreateShopDto) {
    this.logger.log(`[ADMIN-CREATE] üì¶ Admin is creating a new shop item: "${createDto.name}"`);
    return this.shopService.create(createDto);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  update(@Param('id', ParseIntPipe) id: number, @Body() updateDto: UpdateShopDto) {
    this.logger.log(`[ADMIN-UPDATE] üìù Admin is updating shop item ID: ${id}.`);
    return this.shopService.update(id, updateDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(SystemRanks.ADMIN.power_level)
  remove(@Param('id', ParseIntPipe) id: number) {
    this.logger.warn(`[ADMIN-DELETE] üóëÔ∏è Admin is deleting shop item ID: ${id}.`);
    return this.shopService.remove(id);
  }
}
--- END FILE: backend/src/shop/shop.controller.ts ---



--- START FILE: backend/src/shop/shop.module.ts ---

// backend/src/shop/shop.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ShopService } from './shop.service';
import { ShopController } from './shop.controller';
import { ShopItem } from './entities/shop-item.entity';
import { PendingCommand } from './entities/pending-command.entity';
import { User } from '../users/entities/user.entity';
import { PluginApiKeyGuard } from '../auth/guards/plugin-api-key.guard';
// import { ChatModule } from '../chat/chat.module'; // <-- –≠–¢–û–¢ –ò–ú–ü–û–†–¢ –ë–û–õ–¨–®–ï –ù–ï –ù–£–ñ–ï–ù

@Module({
  imports: [
    TypeOrmModule.forFeature([ShopItem, PendingCommand, User]),
    // ChatModule, // <-- –£–ë–ò–†–ê–ï–ú –ï–ì–û –û–¢–°–Æ–î–ê
  ],
  controllers: [ShopController],
  providers: [ShopService, PluginApiKeyGuard],
})
export class ShopModule {}
--- END FILE: backend/src/shop/shop.module.ts ---



--- START FILE: backend/src/shop/shop.service.ts ---

// backend/src/shop/shop.service.ts
import { Injectable, NotFoundException, ForbiddenException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ShopItem } from './entities/shop-item.entity';
import { PendingCommand } from './entities/pending-command.entity';
import { User } from '../users/entities/user.entity';
import { PurchaseDto } from './dto/purchase.dto';
import { CreateShopDto, UpdateShopDto } from './dto/admin-shop.dto';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class ShopService {
  private readonly logger = new Logger(ShopService.name);

  constructor(
    @InjectRepository(ShopItem) private shopItemsRepository: Repository<ShopItem>,
    @InjectRepository(PendingCommand) private pendingCommandsRepository: Repository<PendingCommand>,
    @InjectRepository(User) private usersRepository: Repository<User>,
    // ChatGateway –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω, —Ç–∞–∫ –∫–∞–∫ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏—Å—Ç–µ–º—É –∫–æ–º–∞–Ω–¥
        private readonly eventEmitter: EventEmitter2, // <-- 2. –ò–ù–™–ï–ö–¢–ò–†–£–ï–ú
  ) {}

  async findAllActive(): Promise<ShopItem[]> {
    return this.shopItemsRepository.findBy({ is_active: true });
  }

async purchase(purchaseDto: PurchaseDto, buyerId: number): Promise<{ message: string }> {
    const { itemId, targetUsername } = purchaseDto;
    const item = await this.shopItemsRepository.findOneBy({ item_id: itemId, is_active: true });
    if (!item) {
        throw new NotFoundException('Item not found or is not available for purchase.');
    }
    
    const buyer = await this.usersRepository.findOneBy({ id: buyerId });
    if (!buyer) {
        throw new NotFoundException('Buyer account not found.');
    }
    if (buyer.balance < item.price) {
        throw new ForbiddenException('Insufficient funds.');
    }

    let finalCommand: string;
    let recipientName: string;
    if (targetUsername) {
      recipientName = targetUsername;
      finalCommand = item.ingame_command.replace('{username}', recipientName);
    } else {
      if (!buyer.minecraft_username) {
          throw new ForbiddenException('To buy for yourself, you must link your Minecraft account first.');
      }
      recipientName = buyer.minecraft_username;
      finalCommand = item.ingame_command.replace('{username}', recipientName);
    }

    buyer.balance -= item.price;
    await this.usersRepository.save(buyer);
    const pendingCommand = this.pendingCommandsRepository.create({ command: finalCommand });
    await this.pendingCommandsRepository.save(pendingCommand);

    // --- 3. –ì–ï–ù–ï–†–ò–†–£–ï–ú –°–û–ë–´–¢–ò–ï ---
    this.eventEmitter.emit('command.queued');
    this.logger.log(`[PURCHASE-EVENT] Emitted 'command.queued' event.`);
    
    this.logger.log(`[PURCHASE-SUCCESS] ‚úÖ User ID: ${buyerId} purchased Item ID: ${item.item_id} for "${recipientName}". Price: ${item.price}. New balance: ${buyer.balance}.`);
    const message = `Successfully purchased "${item.name}" for ${recipientName}! The item will be delivered in-game shortly.`;
    return { message };
  }

  async getPendingCommands(): Promise<PendingCommand[]> {
    const commands = await this.pendingCommandsRepository.find();
    this.logger.verbose(`[PLUGIN-FETCH-SUCCESS] üíæ Found ${commands.length} pending commands for the plugin.`);
    return commands;
  }

  async clearPendingCommands(commandIds: number[]): Promise<void> {
    if (commandIds && commandIds.length > 0) {
      await this.pendingCommandsRepository.delete(commandIds);
      this.logger.warn(`[PLUGIN-CLEAR-SUCCESS] ‚úÖ Cleared ${commandIds.length} command(s) from the database.`);
    }
  }
  
  async create(createDto: CreateShopDto): Promise<ShopItem> {
      const newItem = this.shopItemsRepository.create(createDto);
      const savedItem = await this.shopItemsRepository.save(newItem);
      this.logger.log(`[ADMIN-CREATE-SUCCESS] ‚úÖ Created new shop item "${savedItem.name}" with ID: ${savedItem.item_id}.`);
      return savedItem;
  }

  async update(id: number, updateDto: UpdateShopDto): Promise<ShopItem> {
      await this.shopItemsRepository.update(id, updateDto);
      const updatedItem = await this.shopItemsRepository.findOneBy({ item_id: id });
      if (!updatedItem) {
          this.logger.error(`[ADMIN-UPDATE-FAIL] ‚ùå Shop item with ID ${id} not found after update operation.`);
          throw new NotFoundException('Item not found');
      }
      this.logger.log(`[ADMIN-UPDATE-SUCCESS] ‚úÖ Updated shop item ID: ${id}.`);
      return updatedItem;
  }

  async remove(id: number): Promise<void> {
      const result = await this.shopItemsRepository.delete(id);
      if (result.affected === 0) {
          this.logger.error(`[ADMIN-DELETE-FAIL] ‚ùå Shop item with ID ${id} not found for deletion.`);
          throw new NotFoundException('Item not found');
      }
      this.logger.warn(`[ADMIN-DELETE-SUCCESS] ‚úÖ Deleted shop item ID: ${id}.`);
  }
}
--- END FILE: backend/src/shop/shop.service.ts ---



--- START FILE: backend/src/users/dto/create-user.dto.ts ---

import { IsEmail, IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty({ 
    example: 'Player123', 
    description: 'The username of the user', 
    minLength: 3, 
    maxLength: 50 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  username: string;

  @ApiProperty({ 
    example: 'user@example.com', 
    description: 'User email address', 
    maxLength: 255 
  })
  @IsNotEmpty()
  @IsEmail()
  @MaxLength(255)
  email: string;

  @ApiProperty({ 
    example: 'SecurePassword123!', 
    description: 'User password (min 8 characters)', 
    minLength: 8 
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string;
}
--- END FILE: backend/src/users/dto/create-user.dto.ts ---



--- START FILE: backend/src/users/dto/find-all-users.dto.ts ---

import { IsEnum, IsInt, IsOptional, IsString, Max, Min } from 'class-validator';
import { Type } from 'class-transformer'; // <-- –î–û–ë–ê–í–õ–ï–ù–û\

export class FindAllUsersDto {
  @IsOptional()
  @IsEnum(['username', 'reputation_count', 'first_login'])
  sortBy?: 'username' | 'reputation_count' | 'first_login' = 'first_login';

  @IsOptional()
  @IsEnum(['ASC', 'DESC'])
  order?: 'ASC' | 'DESC' = 'DESC';

  @IsOptional()
  @IsString()
  search?: string;

  // --- –ù–û–í–û–ï –ü–û–õ–ï: –ù–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã ---
  @IsOptional()
  @Type(() => Number) // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º query-–ø–∞—Ä–∞–º–µ—Ç—Ä –∏–∑ —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ
  @IsInt()
  @Min(1)
  page?: number = 1;

  // --- –ù–û–í–û–ï –ü–û–õ–ï: –õ–∏–º–∏—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ ---
  @IsOptional()
  @Type(() => Number) // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º query-–ø–∞—Ä–∞–º–µ—Ç—Ä –∏–∑ —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ
  @IsInt()
  @Min(1)
  @Max(100) // –£—Å—Ç–∞–Ω–æ–≤–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ª–∏–º–∏—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–π
  limit?: number = 10;
}
--- END FILE: backend/src/users/dto/find-all-users.dto.ts ---



--- START FILE: backend/src/users/dto/update-profile-response.dto.ts ---

import { ApiProperty } from '@nestjs/swagger';
import { User } from '../entities/user.entity';

// –≠—Ç–æ—Ç DTO –æ–ø–∏—Å—ã–≤–∞–µ—Ç –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è
export class UpdateProfileResponseDto {
  @ApiProperty({ description: 'A new JWT token with updated user data' })
  access_token: string;

  // –î–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–ª–Ω—É—é —Å—É—â–Ω–æ—Å—Ç—å User,
  // —Ç–∞–∫ –∫–∞–∫ PublicUser - —ç—Ç–æ –ª–∏—à—å —Ç–∏–ø, –∞ –Ω–µ –∫–ª–∞—Å—Å.
  @ApiProperty({ type: User })
  user: User;
}
--- END FILE: backend/src/users/dto/update-profile-response.dto.ts ---



--- START FILE: backend/src/users/dto/update-user.dto.ts ---

import { IsOptional, IsString, IsUrl, MaxLength, Matches } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';
// --- –î–û–ë–ê–í–õ–ï–ù–û: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä Transform ---
import { Transform } from 'class-transformer';

export class UpdateUserDto {
  @ApiPropertyOptional({ 
    example: 'AwesomeRabbit', 
    description: 'A new non-unique display name for the website',
    maxLength: 50
  })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  username?: string;

  // --- –ò–ó–ú–ï–ù–ï–ù–ò–Ø –ó–î–ï–°–¨ ---
  @ApiPropertyOptional({ 
    example: 'rabbit-the-great', 
    description: 'A unique profile URL slug. Only letters, numbers, and dashes. Must be unique.',
    maxLength: 50,
    pattern: '^[a-zA-Z0-9-]+$'
  })
  // –≠—Ç–æ—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É "" –≤ null,
  // —á—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç IsOptional –∏ –¥—Ä—É–≥–∏–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –µ–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.
  @Transform(({ value }) => (value?.trim() === '' ? null : value))
  @IsOptional()
  @IsString()
  @MaxLength(50)
  @Matches(/^[a-zA-Z0-9-]+$/, {
    message: 'Profile slug can only contain letters, numbers, and dashes.',
  })
  profile_slug?: string | null; // –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–∞–∫–∂–µ null
  
  @ApiPropertyOptional({ 
    example: 'A seasoned player looking for a team!', 
    description: 'An updated short user description',
    maxLength: 70
  })
  @IsOptional()
  @IsString()
  @MaxLength(70)
  description?: string;

  @ApiPropertyOptional({ 
    example: 'https://mynewdomain.com/path/to/profile_pic.png', 
    description: 'URL to a new profile picture'
  })
  @IsOptional()
  @IsString()
  @IsUrl()
  @MaxLength(100)
  pfp_url?: string;
  
  @ApiPropertyOptional({ 
    example: 'https://mynewdomain.com/path/to/banner_image.png', 
    description: 'URL to a new banner image' 
  })
  @IsOptional()
  @IsString()
  @IsUrl()
  @MaxLength(100)
  banner_url?: string;
}
--- END FILE: backend/src/users/dto/update-user.dto.ts ---



--- START FILE: backend/src/users/entities/user.entity.ts ---

// backend/src/users/entities/user.entity.ts

import {
  Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany, Index, DeleteDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import * as bcrypt from 'bcrypt';
import { Post } from '../../posts/entities/post.entity';
import { News } from '../../news/entities/news.entity';
import { Friendship } from '../../friendships/entities/friendship.entity';
import { Message } from '../../messages/entities/message.entity';
import { Notification } from '../../notifications/entities/notification.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { Purchase } from '../../purchases/entities/purchase.entity';
import { Exclude } from 'class-transformer';
import { Vote } from '../../votes/entities/vote.entity';
import { Rank } from '../../ranks/entities/rank.entity';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50 })
  username: string;

  // --- –ù–û–í–û–ï –ü–û–õ–ï: –ù–∏–∫–Ω–µ–π–º –≤ Minecraft ---
  @Column({ type: 'varchar', length: 16, nullable: true, name: 'minecraft_username' })
  minecraft_username: string | null;

  @Index({ unique: true, where: '"profile_slug" IS NOT NULL' })
  @Column({ type: 'varchar', length: 50, unique: true, nullable: true, name: 'profile_slug' })
  profile_slug: string | null;

  // --- –ù–û–í–û–ï –ü–û–õ–ï: UUID –≤ Minecraft ---
  @Index({ unique: true, where: '"minecraft_uuid" IS NOT NULL' })
  @Column({ type: 'varchar', length: 36, unique: true, nullable: true, name: 'minecraft_uuid' })
  minecraft_uuid: string | null;

  @CreateDateColumn({ type: 'timestamp', name: 'first_login', default: () => 'CURRENT_TIMESTAMP' })
  first_login: Date;

  // ... –æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å —Ñ–∞–π–ª–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
  @Column({ type: 'varchar', length: 70, nullable: true })
  description: string | null;

  @Column({ type: 'varchar', length: 100, nullable: true, name: 'pfp_url' })
  pfp_url: string | null;

  @Column({ type: 'varchar', length: 100, nullable: true, name: 'banner_url' })
  banner_url: string | null;

  @Column({ type: 'boolean', default: false, name: 'is_banned' })
  is_banned: boolean;

  @Column({ type: 'integer', default: 0 })
  balance: number;

  @Column({ type: 'varchar', length: 255, name: 'password_hash' })
  @Exclude({ toPlainOnly: true })
  password_hash: string;

  @Index({ unique: true })
  @Column({ type: 'varchar', length: 255, unique: true })
  email: string;

  @Column({ type: 'timestamp', name: 'email_verified_at', nullable: true, default: null })
  email_verified_at: Date | null;

  @Column({ type: 'timestamp', name: 'last_login', nullable: true })
  last_login: Date | null;

  @Column({ type: 'integer', name: 'reputation_count', default: 0 })
  reputation_count: number;

  @Column({ type: 'boolean', default: false, name: 'is_minecraft_online' })
  is_minecraft_online: boolean;

  @UpdateDateColumn({ type: 'timestamp', name: 'updated_at' })
  updated_at: Date;

  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamp', nullable: true })
  @Exclude({ toPlainOnly: true })
  deleted_at: Date | null;

  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @OneToMany(() => News, (news) => news.author)
  news: News[];

  @OneToMany(() => Friendship, (friendship) => friendship.requester)
  sent_friend_requests: Friendship[];

  @OneToMany(() => Friendship, (friendship) => friendship.receiver)
  received_friend_requests: Friendship[];

  @OneToMany(() => Message, (message) => message.sender)
  sent_messages: Message[];

  @OneToMany(() => Message, (message) => message.receiver)
  received_messages: Message[];

  @OneToMany(() => Notification, (notification) => notification.user)
  notifications: Notification[];

  @OneToMany(() => Comment, (comment) => comment.author)
  comments: Comment[];

  @OneToMany(() => Purchase, (purchase) => purchase.user)
  purchases: Purchase[];

  @OneToMany(() => Vote, (vote) => vote.voter)
  votes: Vote[];

  @ManyToOne(() => Rank, (rank) => rank.users, {
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–Ω–≥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω
    onDelete: 'SET NULL',
    nullable: true,
    eager: true, // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–≥—Ä—É–∂–∞—Ç—å —Ä–∞–Ω–≥ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  })
  @JoinColumn({ name: 'rank_id' })
  rank: Rank;

  @Column({ name: 'rank_id', nullable: true })
  rank_id: number | null;

  async validatePassword(passwordToValidate: string): Promise<boolean> {
    if (!this.password_hash) return false;
    return bcrypt.compare(passwordToValidate, this.password_hash);
  }
}
--- END FILE: backend/src/users/entities/user.entity.ts ---



--- START FILE: backend/src/users/users.controller.ts ---

// backend/src/users/users.controller.ts

import {
  Controller, Get, Post, Body, Param, UsePipes, ValidationPipe, Patch, UseGuards, Request, Delete, HttpCode, HttpStatus,
  UseInterceptors, UploadedFile, ParseFilePipe, MaxFileSizeValidator, Logger, BadRequestException, Query
} from '@nestjs/common';
import { PublicUser, UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from './entities/user.entity';
import { UpdateProfileResponseDto } from './dto/update-profile-response.dto';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { FindAllUsersDto } from './dto/find-all-users.dto';

const generateUniqueFilename = (req, file, callback) => {
  const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
  const extension = extname(file.originalname);
  callback(null, `${uniqueSuffix}${extension}`);
};

@ApiTags('Users')
@Controller('users')
export class UsersController {
  private readonly logger = new Logger(UsersController.name);

  constructor(private readonly usersService: UsersService) { }

  @Post()
  @ApiOperation({ summary: 'Create a new user (for future admin use)' })
  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))
  create(@Body() createUserDto: CreateUserDto) {
    this.logger.log(`[CREATE] üë§ Admin is creating a new user: ${createUserDto.email}`);
    return this.usersService.create(createUserDto);
  }

  @Patch('me')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update my profile' })
  updateMyProfile(@Request() req, @Body() updateUserDto: UpdateUserDto): Promise<{ user: PublicUser; access_token: string; }> {
    const userId = req.user.userId;
    this.logger.log(`[UPDATE-ME] üìù User ID: ${userId} is updating their own profile.`);
    return this.usersService.updateProfile(userId, updateUserDto);
  }

  @Delete('me')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete my account' })
  deleteMyAccount(@Request() req): Promise<void> {
    const userId = req.user.userId;
    this.logger.warn(`[DELETE-ME] üóëÔ∏è User ID: ${userId} is soft-deleting their own account.`);
    return this.usersService.softDeleteUser(userId);
  }

  @Get()
  @ApiOperation({ summary: 'Get all users' })
  findAll(@Query(new ValidationPipe({ transform: true, forbidNonWhitelisted: true })) query: FindAllUsersDto): Promise<{ data: PublicUser[], total: number }> {
    this.logger.verbose(`[GET-ALL] üîé Fetching all users with query: ${JSON.stringify(query)}`);
    return this.usersService.findAll(query);
  }

  @Get(':identifier')
  @ApiOperation({ summary: 'Get a single user by ID or slug' })
  findOne(@Param('identifier') identifier: string) {
    this.logger.verbose(`[GET-ONE] üîé Fetching user with identifier: '${identifier}'`);
    const idAsNumber = parseInt(identifier, 10);
    const queryIdentifier = isNaN(idAsNumber) ? identifier : idAsNumber;
    return this.usersService.findOne(queryIdentifier);
  }

  @Post('me/avatar')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @UseInterceptors(FileInterceptor('file', { storage: diskStorage({ destination: './uploads/avatars', filename: generateUniqueFilename }) }))
  async uploadAvatar(@Request() req, @UploadedFile(new ParseFilePipe({ validators: [new MaxFileSizeValidator({ maxSize: 5 * 1024 * 1024 })], fileIsRequired: true })) file: Express.Multer.File) {
    const userId = req.user.userId;
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (!allowedMimeTypes.includes(file.mimetype)) {
      this.logger.warn(`[UPLOAD-AVATAR-FAIL] üö´ User ID: ${userId} uploaded an invalid file type: ${file.mimetype}`);
      throw new BadRequestException(`Invalid file type. Only JPEG, PNG, and GIF are allowed.`);
    }
    this.logger.log(`[UPLOAD-AVATAR] üñºÔ∏è User ID: ${userId} is uploading a new avatar: ${file.filename}`);
    const avatarUrl = `/uploads/avatars/${file.filename}`;
    return this.usersService.updateAvatar(userId, avatarUrl);
  }

  @Post('me/banner')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @UseInterceptors(FileInterceptor('file', { storage: diskStorage({ destination: './uploads/banners', filename: generateUniqueFilename }) }))
  async uploadBanner(@Request() req, @UploadedFile(new ParseFilePipe({ validators: [new MaxFileSizeValidator({ maxSize: 10 * 1024 * 1024 })], fileIsRequired: true })) file: Express.Multer.File) {
    const userId = req.user.userId;
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (!allowedMimeTypes.includes(file.mimetype)) {
      this.logger.warn(`[UPLOAD-BANNER-FAIL] üö´ User ID: ${userId} uploaded an invalid file type: ${file.mimetype}`);
      throw new BadRequestException(`Invalid file type. Only JPEG, PNG, and GIF are allowed.`);
    }
    this.logger.log(`[UPLOAD-BANNER] üñºÔ∏è User ID: ${userId} is uploading a new banner: ${file.filename}`);
    const bannerUrl = `/uploads/banners/${file.filename}`;
    return this.usersService.updateBanner(userId, bannerUrl);
  }

  @Post('me/unlink-minecraft')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Unlink Minecraft account from my profile' })
  unlinkMinecraftAccount(@Request() req) {
    const userId = req.user.userId;
    this.logger.log(`[UNLINK-MC] üîó User ID: ${userId} is unlinking their Minecraft account.`);
    return this.usersService.unlinkMinecraftAccount(userId);
  }
}
--- END FILE: backend/src/users/users.controller.ts ---



--- START FILE: backend/src/users/users.module.ts ---

import { Module, Global } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { RanksModule } from '../ranks/ranks.module';
import { PendingCommand } from '../shop/entities/pending-command.entity';

@Global()
@Module({
  imports: [
    TypeOrmModule.forFeature([User, PendingCommand]),
    RanksModule,
  ],
  providers: [UsersService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}
--- END FILE: backend/src/users/users.module.ts ---



--- START FILE: backend/src/users/users.service.ts ---

import { Injectable, NotFoundException, ConflictException, ForbiddenException, InternalServerErrorException, Logger, forwardRef, Inject } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Not, ILike, FindManyOptions } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { Ranks } from '../common/enums/ranks.enum';
import * as bcrypt from 'bcrypt';
import { UpdateUserDto } from './dto/update-user.dto';
import { FindAllUsersDto } from './dto/find-all-users.dto';

import { JwtService } from '@nestjs/jwt';
import { AdminUpdateUserDto } from 'src/admin/dto/admin-update-user.dto';
import { RanksService, SystemRanks } from '../ranks/ranks.service'; // <-- –î–û–ë–ê–í–õ–ï–ù–û
import { Rank } from 'src/ranks/entities/rank.entity';
import { ChatGateway } from 'src/chat/chat.gateway'; // <-- –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–æ—Ç –∏–º–ø–æ—Ä—Ç –µ—Å—Ç—å
import { PendingCommand } from 'src/shop/entities/pending-command.entity';
import { EventEmitter2 } from '@nestjs/event-emitter'; // <-- –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∏–º–ø–æ—Ä—Ç


export type PublicUser = Omit<User, 'password_hash' | 'validatePassword' | 'deleted_at'>;

@Injectable()
export class UsersService {

  private readonly logger = new Logger(UsersService.name);


  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    @InjectRepository(PendingCommand)
    private pendingCommandsRepository: Repository<PendingCommand>,
    private readonly eventEmitter: EventEmitter2,
    private jwtService: JwtService,
    private ranksService: RanksService,
  ) { }

  async create(createUserDto: CreateUserDto): Promise<PublicUser> {
    const { email, username, password } = createUserDto;
    const totalUsers = await this.usersRepository.count();
    let rankToAssign;
    try {
      rankToAssign = totalUsers === 0 ? await this.ranksService.findOwnerRank() : await this.ranksService.findDefaultRank();
    } catch (error) {
      this.logger.error(`[CREATE-FAIL] üî• CRITICAL: Could not find system ranks.`, error.stack);
      throw new InternalServerErrorException('Could not determine rank for new user.');
    }
    const existingUserByEmail = await this.usersRepository.findOne({ where: { email } });
    if (existingUserByEmail) {
      throw new ConflictException('User with this email already exists');
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const userToCreate = this.usersRepository.create({ username, email, password_hash: hashedPassword, rank: rankToAssign });
    const savedUser = await this.usersRepository.save(userToCreate);
    const { password_hash, validatePassword, deleted_at, ...result } = savedUser;
    return result as PublicUser;
  }

  async updateProfile(userId: number, updateUserDto: UpdateUserDto): Promise<{ user: PublicUser, access_token: string }> {
    const user = await this.usersRepository.findOne({ where: { id: userId } });
    if (!user) {
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }

    if (updateUserDto.profile_slug) {
      const existingSlugUser = await this.usersRepository.findOne({
        where: { profile_slug: updateUserDto.profile_slug, id: Not(userId) }
      });
      if (existingSlugUser) {
        throw new ConflictException('This profile URL slug is already taken.');
      }
    }

    Object.assign(user, updateUserDto);
    const updatedUser = await this.usersRepository.save(user);

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å –Ω–æ–≤—ã–º username)
    const jwtTokenPayload = { username: updatedUser.username, sub: updatedUser.id, rank: updatedUser.rank };
    const newAccessToken = this.jwtService.sign(jwtTokenPayload);

    const { password_hash, validatePassword, deleted_at, ...publicData } = updatedUser;

    return { user: publicData as PublicUser, access_token: newAccessToken };
  }


  async banUser(userId: number): Promise<PublicUser> {
    const user = await this.usersRepository.findOneBy({ id: userId });
    if (!user) {
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }
    user.is_banned = true;
    const bannedUser = await this.usersRepository.save(user);
    const { password_hash, validatePassword, deleted_at, ...result } = bannedUser;
    return result as PublicUser;
  }

  async unbanUser(userId: number): Promise<PublicUser> {
    const user = await this.usersRepository.findOneBy({ id: userId });
    if (!user) {
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }
    user.is_banned = false;
    const unbannedUser = await this.usersRepository.save(user);
    const { password_hash, validatePassword, deleted_at, ...result } = unbannedUser;
    return result as PublicUser;
  }

  async softDeleteUser(userId: number): Promise<void> {
    const result = await this.usersRepository.softDelete(userId);
    if (result.affected === 0) {
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }
  }

  async adminUpdateUser(targetUserId: number, dto: AdminUpdateUserDto, actorId: number): Promise<PublicUser> {
    this.logger.log(`[ADMIN-UPDATE] üìù Admin ID: ${actorId} is updating User ID: ${targetUserId}`);
    const [targetUser, actor] = await Promise.all([
      this.usersRepository.findOne({ where: { id: targetUserId }, relations: ['rank'] }),
      this.usersRepository.findOne({ where: { id: actorId }, relations: ['rank'] }),
    ]);
    if (!targetUser) throw new NotFoundException(`User with ID ${targetUserId} not found.`);
    if (!actor) throw new ForbiddenException('Actor performing the action not found.');
    if (actor.id !== targetUser.id && actor.rank.power_level <= targetUser.rank.power_level) {
      throw new ForbiddenException('You cannot modify a user with an equal or higher rank.');
    }
    if (dto.rank_id) {
      const newRank = await this.ranksService.findOne(dto.rank_id);
      const oldRank = targetUser.rank;
      if (actor.rank.power_level <= newRank.power_level) {
        throw new ForbiddenException(`You do not have permission to assign the rank "${newRank.name}".`);
      }
      targetUser.rank = newRank;
      let commandToQueue: string | null = null;
      if (targetUser.minecraft_username) {
        if (newRank.id === SystemRanks.DEFAULT.id && oldRank?.command_template_remove) {
          commandToQueue = oldRank.command_template_remove.replace('{username}', targetUser.minecraft_username);
        } else if (newRank.command_template) {
          commandToQueue = newRank.command_template.replace('{username}', targetUser.minecraft_username);
        }
      }
      if (commandToQueue) {
        const pendingCommand = this.pendingCommandsRepository.create({ command: commandToQueue });
        await this.pendingCommandsRepository.save(pendingCommand);
        this.eventEmitter.emit('command.queued');
        this.logger.log(`[ADMIN-UPDATE] Queued command and emitted 'command.queued' event: "${commandToQueue}"`);
      }
    }
    if (dto.reputation_count !== undefined) {
      targetUser.reputation_count = dto.reputation_count;
    }
    const updatedUser = await this.usersRepository.save(targetUser);
    this.logger.log(`[ADMIN-UPDATE-SUCCESS] ‚úÖ User ID: ${targetUserId} was successfully updated by Admin ID: ${actorId}.`);
    const { password_hash, validatePassword, deleted_at, ...result } = updatedUser;
    return result as PublicUser;
  }

  async findAll(queryDto: FindAllUsersDto): Promise<{ data: PublicUser[], total: number }> {
    const { search, order = 'DESC', sortBy: requestedSortBy = 'first_login', page = 1, limit = 10 } = queryDto;

    const allowedSortFields: (keyof User)[] = ['username', 'reputation_count', 'first_login'];
    const sortBy = allowedSortFields.includes(requestedSortBy as keyof User) ? requestedSortBy : 'first_login';

    const findOptions: FindManyOptions<User> = {
      relations: ['rank'],
      order: {
        [sortBy]: order,
      },
      take: limit, // <-- –í–∑—è—Ç—å 'limit' –∑–∞–ø–∏—Å–µ–π
      skip: (page - 1) * limit, // <-- –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (page - 1) * limit –∑–∞–ø–∏—Å–µ–π
    };

    if (search) {
      findOptions.where = { username: ILike(`%${search}%`) };
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º findAndCount, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ —Å –¥–∞–Ω–Ω—ã–º–∏ –∏ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
    const [users, total] = await this.usersRepository.findAndCount(findOptions);

    const publicUsers = users.map(user => {
      const { password_hash, validatePassword, deleted_at, ...result } = user;
      return result as PublicUser;
    });

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –¥–∞–Ω–Ω—ã–º–∏ –∏ –æ–±—â–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º
    return {
      data: publicUsers,
      total: total,
    };
  }

  async findOne(identifier: string | number): Promise<PublicUser> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∏—Å–ª–æ–º –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π, —Å–æ—Å—Ç–æ—è—â–µ–π —Ç–æ–ª—å–∫–æ –∏–∑ —Ü–∏—Ñ—Ä
    const isNumeric = typeof identifier === 'number' || /^\d+$/.test(String(identifier));

    const user = await this.usersRepository.findOne({
      where: isNumeric
        ? { id: Number(identifier) }
        : { profile_slug: String(identifier) },
    });

    if (!user) {
      throw new NotFoundException(`User with identifier '${identifier}' not found`);
    }

    const { password_hash, validatePassword, deleted_at, ...result } = user;
    return result as PublicUser;
  }

  async findOneByUsername(username: string): Promise<User | null> {
    return this.usersRepository.findOne({ where: { username } });
  }

  async findOneWithPasswordByEmail(email: string): Promise<User | null> {
    return this.usersRepository.createQueryBuilder("user")
      .addSelect("user.password_hash")
      .where("user.email = :email", { email })
      .getOne();
  }

  async updatePassword(userId: number, newHashedPassword: string): Promise<void> {
    await this.usersRepository.update(userId, { password_hash: newHashedPassword });
  }

  async findOneWithPasswordById(id: number): Promise<User | null> {
    return this.usersRepository.createQueryBuilder("user")
      .addSelect("user.password_hash")
      .where("user.id = :id", { id })
      .getOne();
  }

  async findUserEntityById(id: number): Promise<User | null> {
    return this.usersRepository.findOneBy({ id });
  }

  async updateAvatar(userId: number, avatarUrl: string): Promise<User> {
    const user = await this.usersRepository.findOneBy({ id: userId });
    if (!user) {
      throw new NotFoundException('User not found');
    }
    user.pfp_url = avatarUrl;
    return this.usersRepository.save(user);
  }

  // --- –ù–û–í–´–ô –ú–ï–¢–û–î: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ URL –±–∞–Ω–Ω–µ—Ä–∞ ---
  async updateBanner(userId: number, bannerUrl: string): Promise<User> {
    const user = await this.usersRepository.findOneBy({ id: userId });
    if (!user) {
      throw new NotFoundException('User not found');
    }
    user.banner_url = bannerUrl;
    return this.usersRepository.save(user);
  }

  async setMinecraftOnlineStatus(minecraftUuid: string, isOnline: boolean): Promise<User | null> {
    const user = await this.usersRepository.findOneBy({ minecraft_uuid: minecraftUuid });
    if (user) {
      user.is_minecraft_online = isOnline;
      return this.usersRepository.save(user);
    }
    return null;
  }

  async findUserByMinecraftUuid(uuid: string): Promise<User | null> {
    return this.usersRepository.findOneBy({ minecraft_uuid: uuid });
  }

  async findOneByMinecraftUsername(mcUsername: string): Promise<User | null> {
    return this.usersRepository.findOne({ where: { minecraft_username: mcUsername } });
  }

  async syncRankFromPlugin(minecraftUuid: string, rankSystemName: string): Promise<void> {
        this.logger.verbose(`[RANK-SYNC] üîÑ Received rank sync from plugin. UUID: ${minecraftUuid}, Rank: ${rankSystemName}`);
        const user = await this.usersRepository.findOne({ where: { minecraft_uuid: minecraftUuid }, relations: ['rank'] });
        if (!user) return;
        const rankFromGame = await this.ranksService.findRankBySystemName(rankSystemName);
        if (!rankFromGame) {
            this.logger.warn(`[RANK-SYNC-FAIL] ‚ö†Ô∏è Could not find a rank with system_name "${rankSystemName}" in the database.`);
            return;
        }
        const currentWebsiteRank = user.rank;
        if (currentWebsiteRank?.id === rankFromGame.id) return;
        if (!currentWebsiteRank || rankFromGame.power_level > currentWebsiteRank.power_level) {
            user.rank = rankFromGame;
            await this.usersRepository.save(user);
            this.logger.log(`[RANK-SYNC-UPDATE-SITE] ‚úÖ User ID: ${user.id}. Game rank "${rankFromGame.name}" had higher priority.`);
        } else {
            this.logger.warn(`[RANK-SYNC-FIX] Mismatch for User ID: ${user.id}. Website: "${currentWebsiteRank.name}", Game: "${rankFromGame.name}". Website has priority.`);
            if (currentWebsiteRank.command_template && user.minecraft_username) {
                const fixCommand = currentWebsiteRank.command_template.replace('{username}', user.minecraft_username);
                const pendingCommand = this.pendingCommandsRepository.create({ command: fixCommand });
                await this.pendingCommandsRepository.save(pendingCommand);
                this.eventEmitter.emit('command.queued');
                this.logger.log(`[RANK-SYNC-FIX] ‚úÖ Re-queued command to fix in-game rank: "${fixCommand}"`);
            }
        }
    }

  async unlinkMinecraftAccount(userId: number): Promise<{ user: PublicUser, access_token: string }> {
    const user = await this.usersRepository.findOneBy({ id: userId });

    if (!user) {
      throw new NotFoundException(`User with ID ${userId} not found.`);
    }

    // –û—á–∏—â–∞–µ–º –ø–æ–ª—è, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å Minecraft
    user.minecraft_uuid = null;
    user.minecraft_username = null;
    user.is_minecraft_online = false;

    const updatedUser = await this.usersRepository.save(user);

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω, —á—Ç–æ–±—ã —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–∏–ª –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const jwtTokenPayload = { username: updatedUser.username, sub: updatedUser.id, rank: updatedUser.rank };
    const newAccessToken = this.jwtService.sign(jwtTokenPayload);

    const { password_hash, validatePassword, deleted_at, ...publicData } = updatedUser;
    return { user: publicData as PublicUser, access_token: newAccessToken };
  }

  async findById(id: number): Promise<User | null> {
    return this.usersRepository.findOne({
      where: { id },
      relations: ['rank'], // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–π —Ä–∞–Ω–≥, —ç—Ç–æ –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è
    });
  }

  async updateOnlineStatus(minecraftUuid: string, isOnline: boolean): Promise<void> {
    const user = await this.usersRepository.findOne({ where: { minecraft_uuid: minecraftUuid } });
    if (user) {
      user.is_minecraft_online = isOnline;
      await this.usersRepository.save(user);
    }
  }

  async updateRankFromGameEvent(minecraftUuid: string, newRankSystemName: string): Promise<void> {
      const user = await this.usersRepository.findOneBy({ minecraft_uuid: minecraftUuid });
      if (!user) return; // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–µ—á–µ–≥–æ –¥–µ–ª–∞—Ç—å

      const newRank = await this.ranksService.findRankBySystemName(newRankSystemName);
      if (!newRank) {
          this.logger.warn(`[EVENT-SYNC-FAIL] Rank "${newRankSystemName}" from game event not found in DB.`);
          return;
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–Ω–≥ –Ω–∞ —Å–∞–π—Ç–µ, –¥–æ–≤–µ—Ä—è—è —Å–æ–±—ã—Ç–∏—é –æ—Ç –ø–µ—Ä–µ—Ö–≤–∞—Ç—á–∏–∫–∞
      if (user.rank_id !== newRank.id) {
          user.rank = newRank;
          await this.usersRepository.save(user);
          this.logger.log(`[EVENT-SYNC-SUCCESS] User ID ${user.id} rank updated to "${newRank.name}" based on in-game command event.`);
      }
  }

}
--- END FILE: backend/src/users/users.service.ts ---



--- START FILE: backend/src/votes/dto/create-vote.dto.ts ---

import { IsIn, IsInt, IsNotEmpty } from 'class-validator';

export class CreateVoteDto {
  @IsNotEmpty()
  @IsInt()
  @IsIn([-1, 1], { message: 'Vote value must be 1 or -1' })
  value: number;
}
--- END FILE: backend/src/votes/dto/create-vote.dto.ts ---



--- START FILE: backend/src/votes/entities/vote.entity.ts ---

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  Check,
  Index,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';

@Entity('votes')
@Index(['voter', 'post'], { unique: true, where: '"post_id" IS NOT NULL' })
@Index(['voter', 'comment'], { unique: true, where: '"comment_id" IS NOT NULL' })
@Check(`("post_id" IS NOT NULL AND "comment_id" IS NULL) OR ("post_id" IS NULL AND "comment_id" IS NOT NULL)`)
export class Vote {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'integer' })
  value: number;

  @ManyToOne(() => User, (user) => user.votes, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'voter_id' })
  voter: User;

  @ManyToOne(() => Post, (post) => post.votes, { // –≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –≤—ã–∑—ã–≤–∞–ª–∞ –æ—à–∏–±–∫—É
    onDelete: 'CASCADE',
    nullable: true,
  })
  @JoinColumn({ name: 'post_id' })
  post: Post | null;

  @ManyToOne(() => Comment, (comment) => comment.votes, {
    onDelete: 'CASCADE',
    nullable: true,
  })
  @JoinColumn({ name: 'comment_id' })
  comment: Comment | null;
}
--- END FILE: backend/src/votes/entities/vote.entity.ts ---



--- START FILE: backend/src/votes/votes.controller.ts ---

// backend/src/votes/votes.controller.ts

import {
  Controller,
  Post,
  Param,
  Body,
  UseGuards,
  Request,
  ParseIntPipe,
  HttpCode,
  HttpStatus,
  Logger, // <-- –î–æ–±–∞–≤–ª–µ–Ω–æ
} from '@nestjs/common';
import { VotesService } from './votes.service';
import { CreateVoteDto } from './dto/create-vote.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';

@ApiTags('Votes & Reputation')
@Controller('votes')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class VotesController {
  private readonly logger = new Logger(VotesController.name);

  constructor(private readonly votesService: VotesService) {}

  @Post('/posts/:id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Vote for a post' })
  voteForPost(
    @Param('id', ParseIntPipe) id: number,
    @Request() req,
    @Body() createVoteDto: CreateVoteDto,
  ) {
    const voterId = req.user.userId;
    this.logger.log(`[VOTE-POST] üëç User ID: ${voterId} is voting on Post ID: ${id} with value: ${createVoteDto.value}`);
    return this.votesService.castVote(voterId, 'post', id, createVoteDto.value);
  }

  @Post('/comments/:id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Vote for a comment' })
  voteForComment(
    @Param('id', ParseIntPipe) id: number,
    @Request() req,
    @Body() createVoteDto: CreateVoteDto,
  ) {
    const voterId = req.user.userId;
    this.logger.log(`[VOTE-COMMENT] üëç User ID: ${voterId} is voting on Comment ID: ${id} with value: ${createVoteDto.value}`);
    return this.votesService.castVote(voterId, 'comment', id, createVoteDto.value);
  }
}
--- END FILE: backend/src/votes/votes.controller.ts ---



--- START FILE: backend/src/votes/votes.module.ts ---

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { VotesService } from './votes.service';
import { VotesController } from './votes.controller';
import { Vote } from './entities/vote.entity';
import { User } from '../users/entities/user.entity';
import { Post } from '../posts/entities/post.entity';
import { Comment } from '../comments/entities/comment.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Vote, User, Post, Comment])],
  controllers: [VotesController],
  providers: [VotesService],
})
export class VotesModule {}
--- END FILE: backend/src/votes/votes.module.ts ---



--- START FILE: backend/src/votes/votes.service.ts ---

// backend/src/votes/votes.service.ts

import { Injectable, NotFoundException, ForbiddenException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource } from 'typeorm';
import { Vote } from './entities/vote.entity';
import { User } from '../users/entities/user.entity';
import { Post } from '../posts/entities/post.entity';
import { Comment } from '../comments/entities/comment.entity';

@Injectable()
export class VotesService {
  private readonly logger = new Logger(VotesService.name);

  constructor(
    @InjectRepository(Vote)
    private votesRepository: Repository<Vote>,
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(Comment)
    private commentsRepository: Repository<Comment>,
    private dataSource: DataSource,
  ) { }

  async castVote(
    voterId: number,
    targetType: 'post' | 'comment',
    targetId: number,
    value: number,
  ) {
    return this.dataSource.transaction(async (manager) => {
      this.logger.verbose(`[VOTE-TX-START] üó≥Ô∏è  User ID: ${voterId} casting vote on ${targetType} ID: ${targetId} (Value: ${value}).`);

      let target: Post | Comment | null;

      if (targetType === 'post') {
        target = await manager.findOne(Post, { where: { id: targetId }, relations: ['author'] });
      } else {
        target = await manager.findOne(Comment, { where: { id: targetId }, relations: ['author'] });
      }

      if (!target) {
        this.logger.warn(`[VOTE-FAIL] ‚ö†Ô∏è  Target ${targetType} with ID ${targetId} not found.`);
        throw new NotFoundException(`${targetType} with ID ${targetId} not found.`);
      }

      if (!target.author) {
        // –≠—Ç–∞ —Å–∏—Ç—É–∞—Ü–∏—è –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–∞, –µ—Å–ª–∏ –≤ –ë–î –≤—Å–µ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ, –Ω–æ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–∂–Ω–∞
        this.logger.error(`[VOTE-FAIL] ‚ùå Author for ${targetType} with ID ${targetId} not found. Content seems orphaned.`);
        throw new NotFoundException(`Author for ${targetType} with ID ${targetId} not found.`);
      }
      if (target.author.id === voterId) {
        this.logger.warn(`[VOTE-DENIED] üö´ User ID: ${voterId} attempted to vote for their own ${targetType} (ID: ${targetId}).`);
        throw new ForbiddenException('You cannot vote for your own content.');
      }

      const author = target.author;
      const existingVote = await manager.findOne(Vote, {
        where: { voter: { id: voterId }, [targetType]: { id: targetId } },
      });

      let reputationChange = 0;

      if (existingVote) {
        if (existingVote.value === value) {
          this.logger.log(`[VOTE-REMOVE] üóëÔ∏è User ID: ${voterId} is removing their vote from ${targetType} ID: ${targetId}.`);
          await manager.remove(Vote, existingVote);
          reputationChange = -value;
        } else {
          this.logger.log(`[VOTE-CHANGE] ‚ÜîÔ∏è  User ID: ${voterId} is changing their vote on ${targetType} ID: ${targetId} from ${existingVote.value} to ${value}.`);
          reputationChange = value - existingVote.value;
          existingVote.value = value;
          await manager.save(Vote, existingVote);
        }
      } else {
        this.logger.log(`[VOTE-NEW] ‚ú® User ID: ${voterId} is casting a new vote on ${targetType} ID: ${targetId}.`);
        const newVote = manager.create(Vote, { voter: { id: voterId }, [targetType]: { id: targetId }, value });
        await manager.save(Vote, newVote);
        reputationChange = value;
      }

      if (reputationChange !== 0) {
        this.logger.log(`[VOTE-REPUTATION] üìà Updating reputation for author ID: ${author.id} by ${reputationChange}.`);
        await manager.increment(User, { id: author.id }, 'reputation_count', reputationChange);
      }

      const votes = await manager.find(Vote, { where: { [targetType]: { id: targetId } } });
      const likes = votes.filter(v => v.value === 1).length;
      const dislikes = votes.filter(v => v.value === -1).length;

      this.logger.log(`[VOTE-TX-SUCCESS] ‚úÖ Vote transaction for ${targetType} ID: ${targetId} completed. New score: ${likes - dislikes}`);
      return { likes, dislikes };
    });
  }
}
--- END FILE: backend/src/votes/votes.service.ts ---



--- START FILE: frontend/src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

--- END FILE: frontend/src/App.css ---



--- START FILE: frontend/src/App.js ---

import React from 'react';
import { CssVarsProvider } from '@mui/joy/styles';
import CssBaseline from '@mui/joy/CssBaseline';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import { ChatProvider } from './context/ChatContext';
import { NotificationsProvider } from './context/NotificationsContext';
import { Toaster } from 'react-hot-toast';

import monochromeDarkTheme from './theme';
import MainLayout from './layouts/MainLayout';
import ProtectedRoute from './components/ProtectedRoute';
import LandingPage from './pages/LandingPage';
import NewsPage from './pages/NewsPage';
import PostsPage from './pages/PostsPage';
import SinglePostPage from './pages/SinglePostPage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import MyProfilePage from './pages/MyProfilePage';
import PlayersPage from './pages/PlayersPage';
import PublicProfilePage from './pages/PublicProfilePage';
import CreatePostPage from './pages/CreatePostPage';
import FriendsPage from './pages/FriendsPage';
import MessagesPage from './pages/MessagesPage';
import ConversationPage from './pages/ConversationPage';
import EditPostPage from './pages/EditPostPage';
import SettingsPage from './pages/SettingsPage';
import SearchPage from './pages/SearchPage';
import AdminPage from './pages/AdminPage';
import AdminPostsPage from './pages/AdminPostsPage'; // <-- –î–û–ë–ê–í–¨–¢–ï –≠–¢–û
import CreateNewsPage from './pages/CreateNewsPage'; // <-- –î–û–ë–ê–í–¨–¢–ï –≠–¢–û
import LinkMinecraftPage from './pages/LinkMinecraftPage'; // <-- –î–û–ë–ê–í–¨–¢–ï –≠–¢–û
import AdminRanksPage from './pages/AdminRanksPage';
import ShopPage from './pages/ShopPage'; // <-- –î–û–ë–ê–í–¨ –≠–¢–£ –°–¢–†–û–ö–£
import { Box, Typography } from '@mui/joy'; // <-- –î–û–ë–ê–í–õ–ï–ù–û
import { ThemeProvider as MuiThemeProvider, createTheme as createMuiTheme } from '@mui/material/styles';
import AdminShopPage from './pages/AdminShopPage'; // <-- –î–û–ë–ê–í–¨ –≠–¢–£ –°–¢–†–û–ö–£
import AdminCreateItemPage from './pages/AdminCreateItemPage'; // <-- –î–û–ë–ê–í–¨ –≠–¢–£ –°–¢–†–û–ö–£
import AdminCustomPages from './pages/AdminCustomPages';   // [!code ++]
import AdminEditPage from './pages/AdminEditPage';         // [!code ++]
import CustomPageView from './pages/CustomPageView';       // [!code ++]
import axios from 'axios'; // <-- –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ axios –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω

axios.defaults.baseURL = process.env.REACT_APP_API_BASE_URL;
 
const muiTheme = createMuiTheme({
  palette: {
    mode: 'dark',
  },
});

function App() {
  return (
    <MuiThemeProvider theme={muiTheme}>
      <CssVarsProvider theme={monochromeDarkTheme} defaultMode="dark">
        <CssBaseline />
        <AuthProvider>
          <ChatProvider>
            <NotificationsProvider>
              <Router>
                <Toaster position="bottom-right" toastOptions={{ duration: 5000 }} />
                <Routes>
                  <Route path="/" element={<MainLayout />}>
                    <Route index element={<LandingPage />} />
                    <Route path="news" element={<NewsPage />} />
                    <Route path="posts" element={<PostsPage />} />
                    <Route path="posts/:postId" element={<SinglePostPage />} />
                    <Route path="players" element={<PlayersPage />} />
                    <Route path="users/:userId" element={<PublicProfilePage />} />
                    <Route path="friends" element={<ProtectedRoute><FriendsPage /></ProtectedRoute>} />
                    <Route path="messages" element={<ProtectedRoute><MessagesPage /></ProtectedRoute>} />
                    <Route path="messages/:userId" element={<ProtectedRoute><ConversationPage /></ProtectedRoute>} />
                    <Route path="posts/new" element={<ProtectedRoute><CreatePostPage /></ProtectedRoute>} />
                    <Route path="posts/:postId/edit" element={<ProtectedRoute><EditPostPage /></ProtectedRoute>} />
                    <Route path="/profile/settings" element={<ProtectedRoute><SettingsPage /></ProtectedRoute>} />
                    <Route path="search" element={<SearchPage />} />
                    <Route path="/admin/users" element={<ProtectedRoute><AdminPage /></ProtectedRoute>} />
                    <Route path="/admin/news/create" element={<ProtectedRoute><CreateNewsPage /></ProtectedRoute>} />
                    <Route path="/admin/posts" element={<ProtectedRoute><AdminPostsPage /></ProtectedRoute>} />
                    <Route path="profile/me" element={<ProtectedRoute><MyProfilePage /></ProtectedRoute>} />
                    <Route path="/profile/link-minecraft" element={<ProtectedRoute><LinkMinecraftPage /></ProtectedRoute>} />
                    <Route path="/admin/ranks" element={<ProtectedRoute><AdminRanksPage /></ProtectedRoute>} />
                    <Route path="/shop" element={<ShopPage />} />
                    <Route path="/admin/pages" element={<ProtectedRoute><AdminCustomPages /></ProtectedRoute>} /> {/* [!code ++] */}
                    <Route path="/admin/pages/new" element={<ProtectedRoute><AdminEditPage /></ProtectedRoute>} /> {/* [!code ++] */}
                    <Route path="/admin/pages/:pageId" element={<ProtectedRoute><AdminEditPage /></ProtectedRoute>} /> {/* [!code ++] */}
                    <Route path="/p/:slug" element={<CustomPageView />} /> {/* [!code ++] */}
                    <Route path="/admin/shop" element={<ProtectedRoute><AdminShopPage /></ProtectedRoute>} /> {/* <-- –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê */}
                    <Route path="/admin/shop/new" element={<ProtectedRoute><AdminCreateItemPage /></ProtectedRoute>} /> {/* <-- –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê */}
                    <Route path="/store/ranks" element={
                      <Box>
                        <Typography level="h1">Ranks Store</Typography>
                        <Typography>This page is under construction.</Typography>
                      </Box>
                    } />
                  </Route>

                  <Route path="/login" element={<LoginPage />} />
                  <Route path="/register" element={<RegisterPage />} />
                </Routes>
              </Router>
            </NotificationsProvider>
          </ChatProvider>
        </AuthProvider>
      </CssVarsProvider>
    </MuiThemeProvider>
  );
}

export default App;
--- END FILE: frontend/src/App.js ---



--- START FILE: frontend/src/components/BannedUserOverlay.js ---

// frontend/src/components/BannedUserOverlay.js

import React from 'react';
import { Box, Typography, Button, Sheet } from '@mui/joy';
import BlockIcon from '@mui/icons-material/Block';
import LogoutIcon from '@mui/icons-material/Logout';
import { useAuth } from '../context/AuthContext';

function BannedUserOverlay() {
  const { logout } = useAuth();

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        width: '100vw',
        position: 'fixed',
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        zIndex: 9999,
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã –¥–ª—è —Å–∞–º—ã—Ö –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ ---
        p: { xs: 2, sm: 0 }, 
      }}
    >
      <Sheet
        variant="outlined"
        sx={{
          // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º–∏ ---
          p: { xs: 2, sm: 3, md: 4 },
          borderRadius: 'md',
          textAlign: 'center',
          boxShadow: 'lg',
          // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É, —á—Ç–æ–±—ã –Ω–∞ –±–æ–ª—å—à–∏—Ö —ç–∫—Ä–∞–Ω–∞—Ö –Ω–µ –±—ã–ª–æ —Å–ª–∏—à–∫–æ–º —à–∏—Ä–æ–∫–æ ---
          maxWidth: '500px',
          width: '100%',
        }}
      >
        {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏–∫–æ–Ω–∫–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
        <BlockIcon sx={{ fontSize: { xs: 50, md: 60 }, color: 'danger.500', mb: 2 }} />
        {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
        <Typography level={{ xs: 'h2', md: 'h1' }} component="h1" textColor="danger.500">
          You Have Been Banned
        </Typography>
        <Typography sx={{ mt: 1, mb: 3 }}>
          Your account has been suspended. Please contact support for more information.
        </Typography>
        <Button
          variant="solid"
          color="neutral"
          startDecorator={<LogoutIcon />}
          onClick={logout}
        >
          Logout
        </Button>
      </Sheet>
    </Box>
  );
}

export default BannedUserOverlay;
--- END FILE: frontend/src/components/BannedUserOverlay.js ---



--- START FILE: frontend/src/components/CollapsiblePushSidebar.js ---

import React, { useState, useEffect } from 'react';
import { NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import NotificationBell from './NotificationBell';
import {
    Box, Sheet, List, ListItem, ListItemButton, ListItemDecorator, ListItemContent, IconButton, Typography, Button, Input, Dropdown, Menu, MenuItem, MenuButton, Divider, Drawer
} from '@mui/joy';
import { useTheme } from '@mui/joy/styles';
import { useMediaQuery } from '@mui/material';

import HomeIcon from '@mui/icons-material/Home';
import ArticleIcon from '@mui/icons-material/Article';
import ForumIcon from '@mui/icons-material/Forum';
import PeopleIcon from '@mui/icons-material/People';
import StorefrontIcon from '@mui/icons-material/Storefront';
import SupportAgentIcon from '@mui/icons-material/SupportAgent';
import AdminPanelSettingsIcon from '@mui/icons-material/AdminPanelSettings';
import AccountCircleIcon from '@mui/icons-material/AccountCircle';
import SettingsIcon from '@mui/icons-material/Settings';
import GroupAddIcon from '@mui/icons-material/GroupAdd';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import SearchIcon from '@mui/icons-material/Search';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import AdbIcon from '@mui/icons-material/Adb';
import DiamondIcon from '@mui/icons-material/Diamond';
import LogoutIcon from '@mui/icons-material/Logout';
import MailIcon from '@mui/icons-material/Mail';
import SupervisedUserCircleIcon from '@mui/icons-material/SupervisedUserCircle';
import DynamicFeedIcon from '@mui/icons-material/DynamicFeed';
import MenuIcon from '@mui/icons-material/Menu';
import ShieldIcon from '@mui/icons-material/Menu';
import LoginIcon from '@mui/icons-material/Login';

const SIDEBAR_WIDTH = 280;
const MAIN_CONTENT_MAX_WIDTH = '1000px';
const LARGE_ICON_BUTTON_HEIGHT = '48px';

const navItems = [
    { name: 'Home', icon: <HomeIcon />, path: '/' },
    { name: 'News', icon: <ArticleIcon />, path: '/news' },
    {
        name: 'Community', icon: <PeopleIcon />, subItems: [
            { name: 'Posts', icon: <ForumIcon />, path: '/posts' },
            { name: 'Players', icon: <PeopleIcon />, path: '/players' },
        ],
    },
    {
        name: 'Store', icon: <StorefrontIcon />, subItems: [
            { name: 'Ranks', icon: <AdbIcon />, path: '/store/ranks' },
            { name: 'Items', icon: <DiamondIcon />, path: '/shop' },
        ],
    },
    { name: 'Support', icon: <SupportAgentIcon />, path: '/support' },
];

const userNavItems = {
    name: 'My Profile', icon: <AccountCircleIcon />, subItems: [
        { name: 'Profile', icon: <AccountCircleIcon />, path: '/profile/me' },
        { name: 'Messages', icon: <MailIcon />, path: '/messages' },
        { name: 'Friends', icon: <GroupAddIcon />, path: '/friends' },
        { name: 'Settings', icon: <SettingsIcon />, path: '/profile/settings' },
    ],
};

const adminNavItem = {
    name: 'Admin Panel', icon: <AdminPanelSettingsIcon />, subItems: [
        { name: 'User Management', icon: <SupervisedUserCircleIcon />, path: '/admin/users' },
        { name: 'Post Management', icon: <DynamicFeedIcon />, path: '/admin/posts' },
        { name: 'Rank Management', icon: <ShieldIcon />, path: '/admin/ranks' },
        { name: 'Shop Management', icon: <StorefrontIcon />, path: '/admin/shop' },
        { name: 'Custom Pages', icon: <ArticleIcon />, path: '/admin/pages' } 
    ],
};


const CollapsiblePushSidebar = ({ children }) => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const [sidebarOpen, setSidebarOpen] = useState(!isMobile);
    const [mobileDrawerOpen, setMobileDrawerOpen] = useState(false);
    const [openCategories, setOpenCategories] = useState({ Community: true, 'Admin Panel': true });
    const navigate = useNavigate();
    const { isLoggedIn, user, logout } = useAuth();
    const [searchQuery, setSearchQuery] = useState('');

    // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨ ---
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ power_level, –∞ –Ω–µ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —Ä–∞–Ω–≥–∞. 800 - —ç—Ç–æ —É—Ä–æ–≤–µ–Ω—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞.
    const isAdmin = user?.rank?.power_level >= 800;

    useEffect(() => {
        if (isMobile) {
            setSidebarOpen(false);
        } else {
            setSidebarOpen(true);
            setMobileDrawerOpen(false);
        }
    }, [isMobile]);

    const toggleSidebar = () => !isMobile && setSidebarOpen(!sidebarOpen);
    const toggleMobileDrawer = () => setMobileDrawerOpen(!mobileDrawerOpen);
    const toggleCategory = (categoryName) => setOpenCategories((prev) => ({ ...prev, [categoryName]: !prev[categoryName] }));
    const handleSearch = (event) => {
        if (event.key === 'Enter' && searchQuery.trim()) {
            navigate(`/search?query=${searchQuery.trim()}`);
            setSearchQuery('');
        }
    };

    const handleLogout = () => {
        logout();
        navigate('/');
    };

    const renderSidebarContent = (isMobileView = false) => (
        <div>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                    <img src="/logo.png" alt="FlameWall Logo" style={{ width: '32px', height: '32px' }} />
                    <Typography component="h2" fontWeight="lg">FlameWall</Typography>
                </Box>
                {!isMobileView &&
                    (
                        <IconButton onClick={toggleSidebar} variant="plain" color="neutral" size="sm">
                            <ChevronLeftIcon />
                        </IconButton>
                    )}
            </Box>
            <List sx={{ '--List-nestedInsetStart': '20px' }}>
                {renderNavItems(navItems, isMobileView)}
                {isLoggedIn && renderNavItems([userNavItems], isMobileView)}
                {isLoggedIn && isAdmin && renderNavItems([adminNavItem], isMobileView)}
            </List>
        </div>
    );

    const renderNavItems = (items, isMobileView = false) => {
        const handleItemClick = () => {
            if (isMobileView) {
                setMobileDrawerOpen(false);
            }
        };
        return items.map((item) => (
            <ListItem key={item.name} nested={!!item.subItems}>
                {item.subItems ? (
                    <div>
                        <ListItemButton onClick={() => toggleCategory(item.name)}>
                            {item.icon && <ListItemDecorator>{item.icon}</ListItemDecorator>}
                            <ListItemContent>{item.name}</ListItemContent>
                            {openCategories[item.name] ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
                        </ListItemButton>
                        {openCategories[item.name] && (
                            <List sx={{ '--List-nestedInsetStart': '20px', pt: 0.5 }}>
                                {item.subItems.map((subItem) => (
                                    <ListItem key={subItem.name}>
                                        <NavLink to={subItem.path} style={{ textDecoration: 'none', color: 'inherit', width: '100%' }} onClick={handleItemClick}>
                                            {({ isActive }) => (
                                                <ListItemButton selected={isActive}>
                                                    {subItem.icon && <ListItemDecorator sx={{ color: 'text.tertiary' }}>{subItem.icon}</ListItemDecorator>}
                                                    <ListItemContent>{subItem.name}</ListItemContent>
                                                </ListItemButton>
                                            )}
                                        </NavLink>
                                    </ListItem>
                                ))}
                            </List>
                        )}
                    </div>
                ) : (
                    <NavLink to={item.path} style={{ textDecoration: 'none', color: 'inherit' }} onClick={handleItemClick}>
                        {({ isActive }) => (
                            <ListItemButton selected={isActive}>
                                {item.icon && <ListItemDecorator>{item.icon}</ListItemDecorator>}
                                <ListItemContent>{item.name}</ListItemContent>
                            </ListItemButton>
                        )}
                    </NavLink>
                )}
            </ListItem>
        ));
    };

    return (
        <Box sx={{ display: 'flex', minHeight: '100vh' }}>
            <Sheet
                variant="outlined"
                sx={{
                    display: { xs: 'none', md: 'block' },
                    width: sidebarOpen ? SIDEBAR_WIDTH : 0,
                    minWidth: sidebarOpen ? SIDEBAR_WIDTH : 0,
                    height: '100vh',
                    position: 'sticky',
                    top: 0,
                    zIndex: 1100,
                    overflow: 'auto',
                    transition: 'width 0.3s ease, min-width 0.3s ease',
                    boxShadow: 'md',
                    p: sidebarOpen ? 2 : 0,
                    opacity: sidebarOpen ? 1 : 0,
                    borderRight: '1px solid',
                    borderColor: 'divider',
                }}
            >
                {sidebarOpen && renderSidebarContent()}
            </Sheet>

            <Drawer
                open={mobileDrawerOpen}
                onClose={() => setMobileDrawerOpen(false)}
                size="md"
            >
                <Box sx={{ p: 2 }}>
                    {renderSidebarContent(true)}
                </Box>
            </Drawer>
            <Box component="main" sx={{ flexGrow: 1, p: { xs: 2, md: 3 } }}>
                <Box sx={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    mb: 4,
                    height: LARGE_ICON_BUTTON_HEIGHT,
                    px: { xs: 0, sm: 1 }
                }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, flexShrink: 0, minWidth: { md: '200px' } }}>
                        {!isMobile && !sidebarOpen && (
                            <IconButton onClick={toggleSidebar} variant="plain" color="neutral" size="lg"><ChevronRightIcon /></IconButton>
                        )}
                        {isMobile && (
                            <IconButton onClick={toggleMobileDrawer} variant="plain" color="neutral" size="lg"><MenuIcon /></IconButton>
                        )}

                        {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï ‚Ññ1: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–∏—Å–∫ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö –∏ –∑–∞–¥–∞–µ–º –µ–º—É —à–∏—Ä–∏–Ω—É --- */}
                        <Input
                            size="md"
                            placeholder="Search..."
                            startDecorator={<SearchIcon />}
                            sx={{
                                display: 'inline-flex', // –¢–µ–ø–µ—Ä—å –ø–æ–∏—Å–∫ –≤–∏–¥–µ–Ω –≤—Å–µ–≥–¥–∞
                                width: { xs: 120, md: 'auto' }, // –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —à–∏—Ä–∏–Ω–∞ 150px, –Ω–∞ –ü–ö - –∞–≤—Ç–æ
                                mr: 0.5
                            }}
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            onKeyDown={handleSearch}
                        />
                    </Box>

                    <Box sx={{
                        flexGrow: 1,
                        display: { xs: 'none', sm: 'flex' },
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: 1
                    }}>
                        <img src="/logo.png" alt="FlameWall Logo" style={{ width: '40px', height: '40px' }} />
                        <Typography fontWeight="lg" level="h2" component="div">FlameWall</Typography>
                    </Box>

                    <Box sx={{ display: 'flex', gap: { xs: 0.5, sm: 1.5 }, alignItems: 'center', flexShrink: 0, minWidth: { md: '200px' }, justifyContent: 'flex-end' }}>
                        {isLoggedIn ? (
                            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï ‚Ññ2: –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–π div –¥–ª—è –ª—É—á—à–µ–π –≤–µ—Ä—Å—Ç–∫–∏ ---
                            <>
                                <NotificationBell />
                                <Dropdown>
                                    <MenuButton slots={{ root: Button }} slotProps={{ root: { variant: 'plain', color: 'neutral', size: 'md', startDecorator: <AccountCircleIcon /> } }}>
                                        <Typography sx={{ display: { xs: 'none', sm: 'inline' } }}>
                                            {user?.username}
                                        </Typography>
                                    </MenuButton>
                                    <Menu>
                                        <MenuItem component={NavLink} to="/profile/me">Profile</MenuItem>
                                        <MenuItem component={NavLink} to="/profile/settings">Settings</MenuItem>
                                        <Divider />
                                        <MenuItem onClick={handleLogout} sx={{ color: 'danger.500' }}>
                                            <ListItemDecorator><LogoutIcon /></ListItemDecorator>
                                            Logout
                                        </MenuItem>
                                    </Menu>
                                </Dropdown>
                            </>
                        ) : (
                            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï ‚Ññ2: –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–π div –¥–ª—è –ª—É—á—à–µ–π –≤–µ—Ä—Å—Ç–∫–∏ ---
                            <>
                                <Button component={NavLink} to="/login" variant="outlined" color="primary" size="md">
                                    <Typography sx={{ display: { xs: 'none', sm: 'inline' } }}>Log in</Typography>
                                    <LoginIcon sx={{ display: { sm: 'none' } }} />
                                </Button>
                                <Button component={NavLink} to="/register" variant="outlined" color="primary" size="md">
                                    <Typography sx={{ display: { xs: 'none', sm: 'inline' } }}>Register</Typography>
                                    <GroupAddIcon sx={{ display: { sm: 'none' } }} />
                                </Button>
                            </>
                        )}
                    </Box>
                </Box>
                <Box sx={{ width: '100%', maxWidth: MAIN_CONTENT_MAX_WIDTH, mx: 'auto' }}>
                    {children}
                </Box>
            </Box>
        </Box>
    );
};

export default CollapsiblePushSidebar;
--- END FILE: frontend/src/components/CollapsiblePushSidebar.js ---



--- START FILE: frontend/src/components/JoyPagination.js ---

import React from 'react';
import { Box, Button, IconButton, Typography } from '@mui/joy';
import KeyboardArrowLeftIcon from '@mui/icons-material/KeyboardArrowLeft';
import KeyboardArrowRightIcon from '@mui/icons-material/KeyboardArrowRight';

function JoyPagination({ count, page, onChange }) {
  if (count <= 1) {
    return null; // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–∞–≥–∏–Ω–∞—Ü–∏—é, –µ—Å–ª–∏ –≤—Å–µ–≥–æ –æ–¥–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∏–ª–∏ –º–µ–Ω—å—à–µ
  }

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1 }}>
      <IconButton
        disabled={page === 1}
        onClick={(e) => onChange(e, page - 1)}
        variant="outlined"
        color="neutral"
      >
        <KeyboardArrowLeftIcon />
      </IconButton>
      <Typography>
        Page {page} of {count}
      </Typography>
      <IconButton
        disabled={page === count}
        onClick={(e) => onChange(e, page + 1)}
        variant="outlined"
        color="neutral"
      >
        <KeyboardArrowRightIcon />
      </IconButton>
    </Box>
  );
}

export default JoyPagination;
--- END FILE: frontend/src/components/JoyPagination.js ---



--- START FILE: frontend/src/components/NotificationBell.js ---

import React from 'react';
import { useNotifications } from '../context/NotificationsContext';
import { NavLink } from 'react-router-dom';
import {
  IconButton,
  Dropdown,
  Menu,
  MenuButton,
  MenuItem,
  Badge,
  ListDivider,
  Typography,
  Box,
  Tooltip, // <-- –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º Tooltip
} from '@mui/joy';
import NotificationsIcon from '@mui/icons-material/Notifications';
import MarkChatReadIcon from '@mui/icons-material/MarkChatRead'; // <-- –ò–∫–æ–Ω–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏

function NotificationBell() {
  // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ—Å—Ç–∞–µ–º markAllAsRead ---
  const { notifications, unreadCount, markAsRead, markAllAsRead } = useNotifications();

  const handleNotificationClick = (notification) => {
    if (!notification.read) {
      markAsRead(notification.notification_id);
    }
  };

  return (
    <Dropdown>
      <MenuButton
        slots={{ root: IconButton }}
        slotProps={{ root: { variant: 'plain', color: 'neutral' } }}
      >
        <Badge badgeContent={unreadCount} color="danger" max={99}>
          <NotificationsIcon />
        </Badge>
      </MenuButton>
      <Menu sx={{ minWidth: 320, p: 1, gap: 1 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', px: 1 }}>
            <Typography level="title-md">Notifications</Typography>
            {/* --- –î–û–ë–ê–í–õ–ï–ù–û: –ö–Ω–æ–ø–∫–∞ "–ü—Ä–æ—á–∏—Ç–∞—Ç—å –≤—Å–µ" --- */}
            <Tooltip title="Mark all as read" variant="outlined" size="sm">
                <IconButton 
                    size="sm" 
                    variant="plain" 
                    color="primary"
                    disabled={unreadCount === 0}
                    onClick={markAllAsRead}
                >
                    <MarkChatReadIcon />
                </IconButton>
            </Tooltip>
        </Box>
        <ListDivider />
        {notifications.length > 0 ? (
          notifications.slice(0, 5).map(n => (
            <MenuItem 
              key={n.notification_id} 
              component={NavLink} 
              to={n.link || '#'}
              onClick={() => handleNotificationClick(n)}
              sx={{ 
                bgcolor: n.read ? 'transparent' : 'primary.softBg',
                borderRadius: 'sm',
                '&:hover': {
                    bgcolor: n.read ? 'background.level1' : 'primary.softHoverBg'
                }
            }}
            >
                <Box>
                    <Typography level="title-sm">{n.title}</Typography>
                    <Typography level="body-sm">{n.message}</Typography>
                    <Typography level="body-xs" textColor="text.tertiary">
                        {new Date(n.created_at).toLocaleString()}
                    </Typography>
                </Box>
            </MenuItem>
          ))
        ) : (
          <MenuItem disabled>
            <Typography sx={{ textAlign: 'center', width: '100%' }}>No notifications yet.</Typography>
          </MenuItem>
        )}
        <ListDivider />
        <MenuItem component={NavLink} to="/notifications" sx={{ borderRadius: 'sm' }}>
            <Typography level="body-sm" sx={{ textAlign: 'center', width: '100%' }}>View all notifications</Typography>
        </MenuItem>
      </Menu>
    </Dropdown>
  );
}

export default NotificationBell;
--- END FILE: frontend/src/components/NotificationBell.js ---



--- START FILE: frontend/src/components/ProtectedRoute.js ---

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { Box, CircularProgress } from '@mui/joy';

const ProtectedRoute = ({ children }) => {
  const { isLoggedIn, user } = useAuth();
  const location = useLocation();

  // –ü–æ–∫–∞ –º—ã –Ω–µ –∑–Ω–∞–µ–º, –∑–∞–ª–æ–≥–∏–Ω–µ–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–µ),
  // –º–æ–∂–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏. `user` —Å—Ç–∞–Ω–µ—Ç `null` –∏–ª–∏ –æ–±—ä–µ–∫—Ç–æ–º –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞ –≤ AuthContext.
  if (user === undefined) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (!isLoggedIn) {
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤—Ö–æ–¥–∞.
    // –ú—ã —Ç–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –æ–Ω –ø—ã—Ç–∞–ª—Å—è –∑–∞–π—Ç–∏, —á—Ç–æ–±—ã –ø–æ—Å–ª–µ –≤—Ö–æ–¥–∞ –≤–µ—Ä–Ω—É—Ç—å –µ–≥–æ –æ–±—Ä–∞—Ç–Ω–æ.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—à–µ–Ω–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É.
  return children;
};

export default ProtectedRoute;
--- END FILE: frontend/src/components/ProtectedRoute.js ---



--- START FILE: frontend/src/components/PurchaseModal.js ---

// frontend/src/components/PurchaseModal.js
import React, { useState } from 'react';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { useNavigate } from 'react-router-dom';
import {
    Modal,
    ModalDialog,
    ModalClose,
    Typography,
    Box,
    Button,
    FormControl,
    FormLabel,
    Input,
    Switch,
    Alert,
    Stack,
    Divider,
} from '@mui/joy';
import toast from 'react-hot-toast';

function PurchaseModal({ open, onClose, item }) {
    const { user, isLoggedIn, updateAuthToken } = useAuth();
    const navigate = useNavigate();

    const [isGifting, setIsGifting] = useState(false);
    const [targetUsername, setTargetUsername] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    const handleConfirmPurchase = async () => {
        if (!isLoggedIn) {
            navigate('/login');
            return;
        }
        setLoading(true);
        setError('');

        try {
            const payload = {
                itemId: item.item_id,
                // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–¥–∞—Ä–æ–∫, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∏–∫. –ò–Ω–∞—á–µ - –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–µ.
                targetUsername: isGifting ? targetUsername : undefined,
            };

            const response = await axios.post('/api/shop/purchase', payload);
            toast.success(response.data.message || "Purchase successful!");
            
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω, —á—Ç–æ–±—ã –æ–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å –≤ AuthContext
            const profileResponse = await axios.get('/api/auth/profile');
            if (profileResponse.data.access_token) {
                 updateAuthToken(profileResponse.data.access_token);
            } else {
                 // –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ –ø—Ä–∏—à–µ–ª, –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–∏—Ç—å —é–∑–µ—Ä–∞
                 // setUser(profileResponse.data) - —ç—Ç–æ –ø–æ—Ç—Ä–µ–±—É–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å setUser –≤ AuthContext
                 // –ü—Ä–æ—â–µ –≤—Å–µ–≥–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞, –Ω–æ —ç—Ç–æ –Ω–µ –ª—É—á—à–∏–π UX
                 // –û—Å—Ç–∞–≤–∏–º –ø–æ–∫–∞ —Ç–∞–∫, —ç—Ç–æ —É–∂–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
            }

            onClose(); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
        } catch (err) {
            setError(err.response?.data?.message || 'An unknown error occurred.');
        } finally {
            setLoading(false);
        }
    };

    if (!item) return null; // –ù–µ —Ä–µ–Ω–¥–µ—Ä–∏–º –Ω–∏—á–µ–≥–æ, –µ—Å–ª–∏ —Ç–æ–≤–∞—Ä –Ω–µ –≤—ã–±—Ä–∞–Ω

    return (
        <Modal open={open} onClose={onClose}>
            <ModalDialog sx={{ minWidth: 350 }}>
                <ModalClose />
                <Typography level="h4" component="h2">Confirm Purchase</Typography>
                <Divider sx={{ my: 2 }} />
                <Stack spacing={2}>
                    <Box>
                        <Typography level="title-md">{item.name}</Typography>
                        <Typography level="body-sm">{item.description}</Typography>
                    </Box>

                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                        <Typography fontWeight="lg">Price:</Typography>
                        <Typography fontWeight="lg">{item.price} coins</Typography>
                    </Box>

                    {isLoggedIn && (
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                            <Typography>Your Balance:</Typography>
                            <Typography>{user.balance} coins</Typography>
                        </Box>
                    )}

                    <FormControl sx={{ display: 'flex', flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                        <FormLabel>Gift to another player?</FormLabel>
                        <Switch
                            checked={isGifting}
                            onChange={(e) => setIsGifting(e.target.checked)}
                            disabled={!isLoggedIn}
                        />
                    </FormControl>

                    {isGifting && (
                        <FormControl>
                            <FormLabel>Player's Minecraft Username</FormLabel>
                            <Input
                                placeholder="Enter exact username"
                                value={targetUsername}
                                onChange={(e) => setTargetUsername(e.target.value)}
                                required
                            />
                        </FormControl>
                    )}
                    
                    {error && <Alert color="danger">{error}</Alert>}

                    <Button
                        variant="solid"
                        color="primary"
                        loading={loading}
                        onClick={handleConfirmPurchase}
                        disabled={isGifting && !targetUsername.trim()}
                    >
                        {isLoggedIn ? 'Confirm and Buy' : 'Log In to Purchase'}
                    </Button>
                </Stack>
            </ModalDialog>
        </Modal>
    );
}

export default PurchaseModal;
--- END FILE: frontend/src/components/PurchaseModal.js ---



--- START FILE: frontend/src/components/TiptapEditor.js ---

// frontend/src/components/TiptapEditor.js
import React, { useCallback } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image'; // <-- 1. –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ

import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { Box, Button, ToggleButtonGroup, Divider, IconButton, Select, Option } from '@mui/joy';
import { constructImageUrl } from '../utils/url';
import FontFamily from '@tiptap/extension-font-family'; // <-- 1. –ò–º–ø–æ—Ä—Ç –¥–ª—è —à—Ä–∏—Ñ—Ç–æ–≤
import Link from '@tiptap/extension-link';
import TextAlign from '@tiptap/extension-text-align'; // <-- 1. –ò–º–ø–æ—Ä—Ç –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
import { Color } from '@tiptap/extension-color';      // <-- 2. –ò–º–ø–æ—Ä—Ç —Ü–≤–µ—Ç–∞
import TextStyle from '@tiptap/extension-text-style';  // <-- 3. –ò–º–ø–æ—Ä—Ç —Å—Ç–∏–ª–µ–π
import Underline from '@tiptap/extension-underline';
import Strike from '@tiptap/extension-strike';
import Highlight from '@tiptap/extension-highlight';
import Superscript from '@tiptap/extension-superscript';
import Subscript from '@tiptap/extension-subscript';

import LinkIcon from '@mui/icons-material/Link';
import LinkOffIcon from '@mui/icons-material/LinkOff';
import FormatAlignLeftIcon from '@mui/icons-material/FormatAlignLeft';
import FormatAlignCenterIcon from '@mui/icons-material/FormatAlignCenter';
import FormatAlignRightIcon from '@mui/icons-material/FormatAlignRight';
import FormatColorTextIcon from '@mui/icons-material/FormatColorText';
import FormatUnderlinedIcon from '@mui/icons-material/FormatUnderlined';
import StrikethroughSIcon from '@mui/icons-material/StrikethroughS';
import BorderColorIcon from '@mui/icons-material/BorderColor';
import SuperscriptIcon from '@mui/icons-material/Superscript';
import SubscriptIcon from '@mui/icons-material/Subscript';
// –ò–∫–æ–Ω–∫–∏
import FormatListBulletedIcon from '@mui/icons-material/FormatListBulleted';
import FormatListNumberedIcon from '@mui/icons-material/FormatListNumbered';
import HorizontalRuleIcon from '@mui/icons-material/HorizontalRule';
import ImageIcon from '@mui/icons-material/Image';

const MenuBar = ({ editor }) => {
    const { authToken } = useAuth(); // –ù—É–∂–µ–Ω –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞


    const setLink = useCallback(() => {
        const previousUrl = editor.getAttributes('link').href;
        const url = window.prompt('URL', previousUrl);

        // –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª Cancel
        if (url === null) {
            return;
        }

        // –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª–∏–ª URL, —Ç–æ —É–±–∏—Ä–∞–µ–º —Å—Å—ã–ª–∫—É
        if (url === '') {
            editor.chain().focus().extendMarkRange('link').unsetLink().run();
            return;
        }

        // –≤—Å—Ç–∞–≤–ª—è–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É
        editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
    }, [editor]);

    if (!editor) return null;

    // --- 2. –õ–æ–≥–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ---
    const addImage = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = async () => {
            const file = input.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await axios.post('/api/admin/pages/upload-image', formData, {
                    headers: { Authorization: `Bearer ${authToken}` },
                });

                // --- 2. –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨ ---
                const relativeUrl = response.data.url; // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä /uploads/pages/img.png
                if (relativeUrl) {
                    // –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –≤ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä http://localhost:3001/uploads/pages/img.png
                    const fullUrl = constructImageUrl(relativeUrl);
                    // –í—Å—Ç–∞–≤–ª—è–µ–º –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä —É–∂–µ –ø–æ–ª–Ω—ã–π, –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π URL
                    editor.chain().focus().setImage({ src: fullUrl }).run();
                }
                // --------------------------

            } catch (error) {
                console.error('Image upload failed:', error);
                alert('Image upload failed!');
            }
        };
        input.click();
    };

    return (
        <ToggleButtonGroup
            variant="soft"
            spacing={0.5}
            sx={{ p: 1, borderBottom: '1px solid', borderColor: 'divider', flexWrap: 'wrap', gap: 0.5 }}
        >
            {/* --- 4. –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, –≤–∫–ª—é—á–∞—è H1 –∏ H4 --- */}
            <Button onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()} value="h1" variant={editor.isActive('heading', { level: 1 }) ? 'solid' : 'plain'}>H1</Button>
            <Button onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()} value="h2" variant={editor.isActive('heading', { level: 2 }) ? 'solid' : 'plain'}>H2</Button>
            <Button onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()} value="h3" variant={editor.isActive('heading', { level: 3 }) ? 'solid' : 'plain'}>H3</Button>
            <Button onClick={() => editor.chain().focus().toggleHeading({ level: 4 }).run()} value="h4" variant={editor.isActive('heading', { level: 4 }) ? 'solid' : 'plain'}>H4</Button>

            <Divider orientation="vertical" sx={{ bgcolor: 'divider' }} /> {/* <-- 5. –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –¶–í–ï–¢ */}

            {/* --- 6. –í—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –≤—ã–±–æ—Ä–∞ —à—Ä–∏—Ñ—Ç–∞ --- */}
            <Select
                size="sm"
                variant="plain"
                value={editor.getAttributes('textStyle').fontFamily || 'Inter'}
                onChange={(e, newValue) => editor.chain().focus().setFontFamily(newValue).run()}
                sx={{ minWidth: 120 }}
            >
                <Option value="Inter">Inter (Default)</Option>
                <Option value="Arial">Arial</Option>
                <Option value="Georgia">Georgia</Option>
                <Option value="Courier New">Courier New</Option>
            </Select>

            <Divider orientation="vertical" sx={{ bgcolor: 'divider' }} /> {/* <-- 5. –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –¶–í–ï–¢ */}

            <Button onClick={() => editor.chain().focus().toggleBold().run()} value="bold" variant={editor.isActive('bold') ? 'solid' : 'plain'}><b>B</b></Button>
            <Button onClick={() => editor.chain().focus().toggleItalic().run()} value="italic" variant={editor.isActive('italic') ? 'solid' : 'plain'}><i>I</i></Button>
            <Button onClick={() => editor.chain().focus().toggleUnderline().run()} value="underline" variant={editor.isActive('underline') ? 'solid' : 'plain'}><FormatUnderlinedIcon /></Button>
            <Button onClick={() => editor.chain().focus().toggleStrike().run()} value="strike" variant={editor.isActive('strike') ? 'solid' : 'plain'}><StrikethroughSIcon /></Button>
            <Button onClick={() => editor.chain().focus().toggleHighlight({ color: '#ffcc00' }).run()} value="highlight" variant={editor.isActive('highlight') ? 'solid' : 'plain'}><BorderColorIcon /></Button>
            <IconButton component="label" value="color" aria-label="color">
                <FormatColorTextIcon />
                <input type="color" onInput={(event) => editor.chain().focus().setColor(event.target.value).run()} value={editor.getAttributes('textStyle').color || '#ffffff'} style={{ position: 'absolute', opacity: 0 }} />
            </IconButton>

            <Divider orientation="vertical" sx={{ bgcolor: 'divider' }} /> {/* <-- 5. –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –¶–í–ï–¢ */}

            <Button onClick={() => editor.chain().focus().setTextAlign('left').run()} value="left" variant={editor.isActive({ textAlign: 'left' }) ? 'solid' : 'plain'}><FormatAlignLeftIcon /></Button>
            <Button onClick={() => editor.chain().focus().setTextAlign('center').run()} value="center" variant={editor.isActive({ textAlign: 'center' }) ? 'solid' : 'plain'}><FormatAlignCenterIcon /></Button>
            <Button onClick={() => editor.chain().focus().setTextAlign('right').run()} value="right" variant={editor.isActive({ textAlign: 'right' }) ? 'solid' : 'plain'}><FormatAlignRightIcon /></Button>

            <Divider orientation="vertical" sx={{ bgcolor: 'divider' }} /> {/* <-- 5. –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –¶–í–ï–¢ */}

            <Button onClick={setLink} value="link" variant={editor.isActive('link') ? 'solid' : 'plain'}><LinkIcon /></Button>
            <Button onClick={() => editor.chain().focus().unsetLink().run()} value="unlink" disabled={!editor.isActive('link')}><LinkOffIcon /></Button>
            <Button onClick={addImage} value="image"><ImageIcon /></Button>
            <Button onClick={() => editor.chain().focus().toggleBlockquote().run()} value="quote" variant={editor.isActive('blockquote') ? 'solid' : 'plain'}>Quote</Button>
            <Button onClick={() => editor.chain().focus().toggleBulletList().run()} value="ul" variant={editor.isActive('bulletList') ? 'solid' : 'plain'}><FormatListBulletedIcon /></Button>
            <Button onClick={() => editor.chain().focus().toggleOrderedList().run()} value="ol" variant={editor.isActive('orderedList') ? 'solid' : 'plain'}><FormatListNumberedIcon /></Button>
            <Button onClick={() => editor.chain().focus().setHorizontalRule().run()} value="hr"><HorizontalRuleIcon /></Button>
        </ToggleButtonGroup>
    );
};

export const TiptapEditor = ({ content, onChange, ...props }) => {
    const editor = useEditor({
        extensions: [
            StarterKit,
            Image,
            TextAlign.configure({ types: ['heading', 'paragraph'] }),
            TextStyle,
            Color,
            FontFamily, // <-- 7. –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è —à—Ä–∏—Ñ—Ç–æ–≤
            Link.configure({ // <-- 8. –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è —Å—Å—ã–ª–æ–∫
                openOnClick: false, // –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å —Å—Å—ã–ª–∫—É –ø–æ –∫–ª–∏–∫—É –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ
                autolink: true, // –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å —Ç–µ–∫—Å—Ç –≤ —Å—Å—ã–ª–∫–∏
            }),
            Underline,
            Strike,
            Highlight.configure({ multicolor: true }), // —Ä–∞–∑—Ä–µ—à–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞ –º–∞—Ä–∫–µ—Ä–∞
            Superscript,
            Subscript,
        ],
        content: content || '',
        onUpdate: ({ editor }) => {
            onChange(editor.getHTML());
        },
        editorProps: {
            attributes: {
                style: `min-height: 250px; padding: 10px; outline: none; color: var(--joy-palette-text-primary);`,
            },
        },
        ...props,
    });

    return (
        <Box sx={{ border: '1px solid', borderColor: 'divider', borderRadius: 'sm', overflow: 'hidden' }}>
            <MenuBar editor={editor} />
            <EditorContent editor={editor} />
        </Box>
    );
};
--- END FILE: frontend/src/components/TiptapEditor.js ---



--- START FILE: frontend/src/components/VoteButtons.js ---

// frontend/src/components/VoteButtons.js

import React, { useState, useEffect } from 'react';
import { Box, IconButton, Typography, Tooltip } from '@mui/joy';
import ThumbUpIcon from '@mui/icons-material/ThumbUp';
import ThumbDownIcon from '@mui/icons-material/ThumbDown';

// --- –ò–ó–ú–ï–ù–Ø–ï–ú –ü–†–û–ü–°–´: –î–û–ë–ê–í–õ–Ø–ï–ú initialScore ---
function VoteButtons({ initialScore, initialLikes, initialDislikes, currentUserVote, onVote, disabled = false }) {
  // --- –õ–û–ì–ò–ö–ê –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –ù–ê–ß–ê–õ–¨–ù–û–ì–û –†–ï–ô–¢–ò–ù–ì–ê ---
  const getInitialScore = () => {
    if (initialScore !== undefined) {
      return initialScore;
    }
    if (initialLikes !== undefined && initialDislikes !== undefined) {
      return initialLikes - initialDislikes;
    }
    return 0; // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  };

  const [displayScore, setDisplayScore] = useState(getInitialScore());
  const [voteStatus, setVoteStatus] = useState(currentUserVote || 0);

  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –µ—Å–ª–∏ –ø—Ä–æ–ø—Å—ã –∏–∑–º–µ–Ω—è—Ç—Å—è
  useEffect(() => {
    setDisplayScore(getInitialScore());
    setVoteStatus(currentUserVote || 0);
  }, [initialScore, initialLikes, initialDislikes, currentUserVote]);

  const handleVoteClick = (newValue) => {
    if (disabled) return;

    const oldStatus = voteStatus;
    let newDisplayScore = displayScore;

    // –û—Ç–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –≥–æ–ª–æ—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±—ã–ª –ª–∞–π–∫, –Ω–∞–∂–∞–ª–∏ –ª–∞–π–∫ –µ—â–µ —Ä–∞–∑)
    if (oldStatus === newValue) {
      newValue === 1 ? newDisplayScore-- : newDisplayScore++;
      setVoteStatus(0);
    } else {
      // –°–º–µ–Ω–∞ –≥–æ–ª–æ—Å–∞ (—Å –ª–∞–π–∫–∞ –Ω–∞ –¥–∏–∑–ª–∞–π–∫)
      if (oldStatus === 1) newDisplayScore--;
      if (oldStatus === -1) newDisplayScore++;
      // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –≥–æ–ª–æ—Å–∞
      newValue === 1 ? newDisplayScore++ : newDisplayScore--;
      setVoteStatus(newValue);
    }
    
    setDisplayScore(newDisplayScore);
    onVote(newValue); // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ API
  };

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
      <Tooltip title="Like" variant="outlined" size="sm">
        <IconButton
          variant={voteStatus === 1 ? 'solid' : 'soft'}
          color={voteStatus === 1 ? 'success' : 'neutral'}
          onClick={() => handleVoteClick(1)}
          disabled={disabled}
        >
          <ThumbUpIcon />
        </IconButton>
      </Tooltip>
      <Typography fontWeight="md" sx={{ minWidth: '20px', textAlign: 'center' }}>
        {/* --- –û–¢–û–ë–†–ê–ñ–ê–ï–ú –ù–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï --- */}
        {displayScore}
      </Typography>
      <Tooltip title="Dislike" variant="outlined" size="sm">
        <IconButton
          variant={voteStatus === -1 ? 'solid' : 'soft'}
          color={voteStatus === -1 ? 'danger' : 'neutral'}
          onClick={() => handleVoteClick(-1)}
          disabled={disabled}
        >
          <ThumbDownIcon />
        </IconButton>
      </Tooltip>
    </Box>
  );
}

export default VoteButtons;
--- END FILE: frontend/src/components/VoteButtons.js ---



--- START FILE: frontend/src/context/AuthContext.js ---

// frontend/src/context/AuthContext.js

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { jwtDecode } from 'jwt-decode';
import axios from 'axios';
import { io } from 'socket.io-client';
import toast from 'react-hot-toast'; // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º toast –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π


const AuthContext = createContext(null);
export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
  // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ user - undefined, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –∑–∞–≥—Ä—É–∑–∫—É, –ø–æ–∫–∞ –∏–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞
  const [user, setUser] = useState(undefined);
  const [authToken, setAuthToken] = useState(() => localStorage.getItem('authToken') || null);
  const socketRef = useRef(null);
  const [socket, setSocket] = useState(null);

  // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨: –≠—Ñ—Ñ–µ–∫—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞ –∏ –ø—Ä–æ—Ñ–∏–ª—è ---
  useEffect(() => {
    const initializeAuth = async () => {
      const token = localStorage.getItem('authToken');
      if (token) {
        try {
          const decoded = jwtDecode(token);
          if (decoded.exp * 1000 < Date.now()) {
            throw new Error("Token expired");
          }

          axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;

          // –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –±—ç–∫–µ–Ω–¥ –∑–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–º –ø—Ä–æ—Ñ–∏–ª–µ–º
          const response = await axios.get('/api/auth/profile');

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—ã–π –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –æ—Ç–≤–µ—Ç–∞ API
          setUser(response.data);
          setAuthToken(token);

        } catch (error) {
        // –í—ã–∫–∏–¥—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ø–í–ù–û —Å–∫–∞–∑–∞–ª, —á—Ç–æ –º—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã (401) –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω (403).
        if (error.response && (error.response.status === 401 || error.response.status === 403)) {
            console.error("Auth Error: Logging out due to 401/403 response.");
            localStorage.removeItem('authToken');
            delete axios.defaults.headers.common['Authorization'];
            setUser(null);
            setAuthToken(null);
        } else {
            // –ï—Å–ª–∏ —ç—Ç–æ —Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ (–±—ç–∫–µ–Ω–¥ –µ—â–µ –Ω–µ –ø–æ–¥–Ω—è–ª—Å—è) –∏–ª–∏ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ (5xx),
            // –º—ã –ù–ï –≤—ã–∫–∏–¥—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ú—ã –ø—Ä–æ—Å—Ç–æ –Ω–µ –º–æ–∂–µ–º –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –µ–≥–æ —Å–µ—Å—Å–∏—é –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.
            // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–∏–¥–∏—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏, –∞ –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–π –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã,
            // –∫–æ–≥–¥–∞ –±—ç–∫–µ–Ω–¥ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–æ–π–¥–µ—Ç —É—Å–ø–µ—à–Ω–æ.
            console.error("Could not verify session. Backend might be temporarily unavailable or returning an error.", error);
            // –í–∞–∂–Ω–æ: –º—ã –Ω–µ –≤—ã–∑—ã–≤–∞–µ–º setUser(null) –∏ –Ω–µ —Å—Ç–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –æ—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.
        }
      }
      } else {
        // –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω–∞ –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º user –≤ null
        setUser(null);
      }
    };

    initializeAuth();
  }, []); // –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω—è–ª–æ—Å—å –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ

  // ... –æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å —Ñ–∞–π–ª–∞ (useEffect –¥–ª—è —Å–æ–∫–µ—Ç–∞, login, logout) –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
  useEffect(() => {
    if (authToken && user && !user.is_banned) {
      if (!socketRef.current) {
        console.log('AuthProvider: Connecting socket...');
        const newSocket = io(process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001', {
          transports: ['websocket'],
          auth: { token: authToken },
        });

        // --- –ù–û–í–´–ô –°–õ–£–®–ê–¢–ï–õ–¨ –°–û–ë–´–¢–ò–Ø ---
        newSocket.on('linkStatus', (data) => {
            if (data.success) {
                toast.success(`Successfully linked to Minecraft account: ${data.minecraftUsername}!`);
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
                setUser(prevUser => ({ ...prevUser, minecraft_username: data.minecraftUsername, minecraft_uuid: 'linked' }));
            } else {
                toast.error(`Linking failed: ${data.error}`);
            }
        });

        socketRef.current = newSocket;
        setSocket(newSocket);
      }
    } else {
      if (socketRef.current) {
        socketRef.current.disconnect();
        socketRef.current = null;
        setSocket(null);
      }
    }
    return () => {
        // –£–±–∏—Ä–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏
        if(socketRef.current) {
            socketRef.current.off('linkStatus');
        }
    }
  }, [authToken, user]);

  const login = useCallback(async (token) => {
    localStorage.setItem('authToken', token);
    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    try {
      // –ü–æ—Å–ª–µ –ª–æ–≥–∏–Ω–∞ —Å—Ä–∞–∑—É –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
      const response = await axios.get('/api/auth/profile');
      setUser(response.data);
      setAuthToken(token);
    } catch (error) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è
      logout();
    }
  }, []);

  const logout = useCallback(() => {
    localStorage.removeItem('authToken');
    delete axios.defaults.headers.common['Authorization'];
    setAuthToken(null);
    setUser(null);
  }, []);

  const updateAuthToken = useCallback((token) => {
    login(token);
  }, [login]);

  const value = useMemo(() => ({
    // –¢–µ–ø–µ—Ä—å `user` –º–æ–∂–µ—Ç –±—ã—Ç—å undefined, null –∏–ª–∏ –æ–±—ä–µ–∫—Ç–æ–º
    isLoggedIn: !!user,
    user,
    authToken,
    socket,
    login,
    logout,
    updateAuthToken,
  }), [user, authToken, socket, login, logout, updateAuthToken]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
--- END FILE: frontend/src/context/AuthContext.js ---



--- START FILE: frontend/src/context/ChatContext.jsx ---

// frontend/src/context/ChatProvider.js

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from './AuthContext'; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à –æ—Å–Ω–æ–≤–Ω–æ–π AuthContext
import axios from 'axios';
import { jwtDecode } from 'jwt-decode';

const ChatContext = createContext(null);
export const useChat = () => useContext(ChatContext);

export const ChatProvider = ({ children }) => {
  // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ü–æ–ª—É—á–∞–µ–º —Å–æ–∫–µ—Ç –∏–∑ AuthContext, –∞ –Ω–µ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π ---
  const { isLoggedIn, authToken, socket, user: currentUser } = useAuth(); 

  const [conversations, setConversations] = useState({});
  
  // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –≠—Ç–æ—Ç useEffect —Ç–µ–ø–µ—Ä—å –ø—Ä–æ—Å—Ç–æ —Å–ª—É—à–∞–µ—Ç —Å–æ–±—ã—Ç–∏—è –Ω–∞ –≥–æ—Ç–æ–≤–æ–º —Å–æ–∫–µ—Ç–µ ---
  useEffect(() => {
    // –ï—Å–ª–∏ —Å–æ–∫–µ—Ç–∞ –Ω–µ—Ç (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞–ª–æ–≥–∏–Ω–µ–Ω –∏–ª–∏ —Å–æ–∫–µ—Ç –µ—â–µ –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è), –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
    if (!socket) return;

    const handleNewMessage = (message) => {
      if (!currentUser) return;
      
      const otherUserId = message.sender.id === currentUser.id ? message.receiver.id : message.sender.id;
      
      setConversations(prev => {
        const currentMessages = prev[otherUserId] || [];
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã, –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        if (currentMessages.find(m => m.id === message.id)) return prev;
        return { ...prev, [otherUserId]: [...currentMessages, message] };
      });
    };

    // –í–µ—à–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–æ–∫–µ—Ç
    socket.on('newMessage', handleNewMessage);

    // –£–±–∏—Ä–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –∏–ª–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ —Å–æ–∫–µ—Ç–∞
    return () => {
      socket.off('newMessage', handleNewMessage);
    };
  }, [socket, currentUser]); // –ó–∞–≤–∏—Å–∏–º –æ—Ç —Å–æ–∫–µ—Ç–∞ –∏–∑ AuthContext

  const sendMessage = useCallback((recipientId, content) => {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Å–æ–∫–µ—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    if (socket?.connected) {
      socket.emit('sendMessage', { recipientId, content });
    }
  }, [socket]);

  const loadConversationHistory = useCallback(async (otherUserId) => {
    try {
      // –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ AuthContext
      const response = await axios.get(`/api/messages/conversation/${otherUserId}`);
      
      setConversations(prev => ({
        ...prev,
        [otherUserId]: response.data,
      }));
    } catch (error) {
      console.error("Failed to load conversation history", error);
    }
  }, []);

  const value = useMemo(() => ({
    sendMessage,
    conversations,
    loadConversationHistory,
    isConnected: socket?.connected || false,
  }), [sendMessage, conversations, loadConversationHistory, socket?.connected]);

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
};
--- END FILE: frontend/src/context/ChatContext.jsx ---



--- START FILE: frontend/src/context/NotificationsContext.js ---

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from './AuthContext';
import axios from 'axios';
import toast from 'react-hot-toast';
import { Alert, Typography, Link as JoyLink } from '@mui/joy';
import InfoIcon from '@mui/icons-material/Info';

const NotificationsContext = createContext(null);
export const useNotifications = () => useContext(NotificationsContext);

// NotificationToast –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
const NotificationToast = ({ notification, toastInstance }) => {
  const navigate = useNavigate();
  const handleClick = () => {
    if (notification.link) navigate(notification.link);
    toast.dismiss(toastInstance.id);
  };
  return (
    <JoyLink onClick={handleClick} overlay sx={{ textDecoration: 'none', cursor: 'pointer' }}>
      <Alert key={notification.notification_id} variant="soft" color="primary" startDecorator={<InfoIcon />} sx={{ boxShadow: 'lg', width: '350px' }}>
        <div>
          <Typography fontWeight="lg">{notification.title}</Typography>
          <Typography level="body-sm">{notification.message}</Typography>
        </div>
      </Alert>
    </JoyLink>
  );
};


export const NotificationsProvider = ({ children }) => {
  const { isLoggedIn, authToken, socket } = useAuth();
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [friendshipUpdateTrigger, setFriendshipUpdateTrigger] = useState(null);

  const fetchNotifications = useCallback(async () => {
    if (!authToken) return;
    try {
      const config = { headers: { Authorization: `Bearer ${authToken}` } };
      const response = await axios.get(`/api/notifications`, config);
      setNotifications(response.data);
      setUnreadCount(response.data.filter(n => !n.read).length);
    } catch (error) {
      console.error("Failed to fetch notifications", error);
    }
  }, [authToken]);

  useEffect(() => {
    if (isLoggedIn) fetchNotifications();
    else {
      setNotifications([]);
      setUnreadCount(0);
    }
  }, [isLoggedIn, fetchNotifications]);

  useEffect(() => {
    if (socket) {
      const handleNewNotification = (newNotification) => {
        setNotifications(prev => prev.find(n => n.notification_id === newNotification.notification_id) ? prev : [newNotification, ...prev]);
        setUnreadCount(prev => prev + 1);
        toast.custom((t) => <NotificationToast notification={newNotification} toastInstance={t} />);
        if (newNotification?.type?.startsWith('friendship.')) {
            setFriendshipUpdateTrigger(Date.now());
        }
      };
      socket.on('newNotification', handleNewNotification);
      return () => { socket.off('newNotification', handleNewNotification); };
    }
  }, [socket]);

  // --- –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞–±–∏–ª–∏–∑–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é, —É–±—Ä–∞–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç 'notifications' ---
  const markAsRead = useCallback(async (notificationId) => {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ `prev` —Å–æ—Å—Ç–æ—è–Ω–∏—é
    setNotifications(prevNotifications => {
        const notification = prevNotifications.find(n => n.notification_id === notificationId);
        if (!notification || notification.read) return prevNotifications; // –ï—Å–ª–∏ –Ω–µ—á–µ–≥–æ –º–µ–Ω—è—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        
        // –û–ø—Ç–∏–º–∏—Å—Ç–∏—á–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º
        setUnreadCount(prev => (prev > 0 ? prev - 1 : 0));
        return prevNotifications.map(n => n.notification_id === notificationId ? { ...n, read: true } : n);
    });
    
    try {
      await axios.post(`/api/notifications/${notificationId}/read`, {}, { headers: { Authorization: `Bearer ${authToken}` } });
    } catch (error) {
      console.error("Failed to mark notification as read", error);
    }
  }, [authToken]); // <-- –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å `notifications` —É–±—Ä–∞–Ω–∞

  // --- –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞–±–∏–ª–∏–∑–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é, —É–±—Ä–∞–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç 'unreadCount' ---
  const markAllAsRead = useCallback(async () => {
    // –û–ø—Ç–∏–º–∏—Å—Ç–∏—á–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    setNotifications(prev => prev.map(n => ({ ...n, read: true })));
    setUnreadCount(0);
    try {
      await axios.post(`/api/notifications/read-all`, {}, { headers: { Authorization: `Bearer ${authToken}` } });
    } catch (error) {
      console.error("Failed to mark all notifications as read", error);
      fetchNotifications(); // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    }
  }, [authToken, fetchNotifications]); // <-- –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å `unreadCount` —É–±—Ä–∞–Ω–∞

  // --- –ò–ó–ú–ï–ù–ï–ù–û: –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —É–∂–µ –±—ã–ª–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã ---
  const markNotificationsAsReadByLink = useCallback(async (link) => {
    try {
        const { data } = await axios.post(`/api/notifications/read-by-link`, { link }, { headers: { Authorization: `Bearer ${authToken}` } });
        if (data.affected > 0) {
            fetchNotifications();
        }
    } catch (error) {
        console.error("Failed to mark by link", error);
    }
  }, [authToken, fetchNotifications]);

  const value = useMemo(() => ({
    notifications,
    unreadCount,
    markAsRead,
    friendshipUpdateTrigger,
    markAllAsRead,
    markNotificationsAsReadByLink,
  }), [notifications, unreadCount, markAsRead, friendshipUpdateTrigger, markAllAsRead, markNotificationsAsReadByLink]);

  return <NotificationsContext.Provider value={value}>{children}</NotificationsContext.Provider>;
};
--- END FILE: frontend/src/context/NotificationsContext.js ---



--- START FILE: frontend/src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* –≠—Ç–∏ —Å—Ç–∏–ª–∏ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ Tiptap –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å, –æ–Ω–∏ –Ω–µ –º–µ—à–∞—é—Ç */
.tiptap .ProseMirror img {
  max-width: 400px;
  height: auto;
  display: block;
  margin-left: 0;
  margin-right: 0;
}
.tiptap .ProseMirror img.ProseMirror-selectednode {
  max-width: 400px;
}
.ProseMirror img {
  max-width: 100% !important;
  height: auto !important;
}
--- END FILE: frontend/src/index.css ---



--- START FILE: frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(

    <App />

);

if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker-prod.js')
      .then(registration => {
        console.log('Service Worker registered for production: ', registration);
      })
      .catch(registrationError => {
        console.log('Service Worker registration failed: ', registrationError);
      });
  });
}

--- END FILE: frontend/src/index.js ---



--- START FILE: frontend/src/layouts/MainLayout.js ---

// frontend/src/layouts/MainLayout.js

import React from 'react';
import { Outlet } from 'react-router-dom';
import CollapsiblePushSidebar from '../components/CollapsiblePushSidebar';
import { useAuth } from '../context/AuthContext';
import BannedUserOverlay from '../components/BannedUserOverlay';

const MainLayout = () => {
  const { user, isLoggedIn } = useAuth();

  // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ª–æ–≥–∏–Ω–µ–Ω –∏ —É –Ω–µ–≥–æ —Å—Ç–æ–∏—Ç —Ñ–ª–∞–≥ is_banned,
  // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–º—É –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—É—é –±–ª–æ–∫–∏—Ä–æ–≤–∫—É.
  if (isLoggedIn && user.is_banned) {
    return <BannedUserOverlay />;
  }
  
  // –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–∞–π—Ç–∞.
  return (
    <CollapsiblePushSidebar>
      <Outlet />
    </CollapsiblePushSidebar>
  );
};

export default MainLayout;
--- END FILE: frontend/src/layouts/MainLayout.js ---



--- START FILE: frontend/src/pages/AdminCreateItemPage.js ---

// frontend/src/pages/AdminCreateItemPage.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box,
    Typography,
    FormControl,
    FormLabel,
    Input,
    Textarea,
    Button,
    Alert,
    Breadcrumbs,
    Link as JoyLink,
    Switch,
    Stack
} from '@mui/joy';
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import toast from 'react-hot-toast';

function AdminCreateItemPage() {
    const navigate = useNavigate();
    const { authToken } = useAuth();
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    const [formData, setFormData] = useState({
        name: '',
        description: '',
        price: 0,
        image_url: '',
        ingame_command: '',
        category: 'items',
        is_active: true,
    });

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleSwitchChange = (e) => {
        const { name, checked } = e.target;
        setFormData(prev => ({ ...prev, [name]: checked }));
    };

    const handleSubmit = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');

        try {
            const payload = {
                ...formData,
                price: Number(formData.price)
            };

            await axios.post('/api/shop', payload, {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            toast.success('Item created successfully!');
            navigate('/admin/shop');
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to create item.');
            console.error('Error creating item:', err);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box component="form" onSubmit={handleSubmit}>
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 2 }}>
                <JoyLink href="/admin/users"><HomeIcon /></JoyLink>
                <JoyLink href="/admin/shop">Shop Management</JoyLink>
                <Typography>Create New Item</Typography>
            </Breadcrumbs>

            <Typography level="h2" component="h1" sx={{ mb: 2 }}>Create New Shop Item</Typography>

            {error && <Alert color="danger" sx={{ mb: 2 }}>{Array.isArray(error) ? error.join(', ') : error}</Alert>}

            <Stack spacing={2}>
                <FormControl required>
                    <FormLabel>Item Name</FormLabel>
                    <Input name="name" value={formData.name} onChange={handleChange} placeholder="e.g., VIP Rank (30 days)" />
                </FormControl>

                <FormControl required>
                    <FormLabel>Description</FormLabel>
                    <Textarea name="description" value={formData.description} onChange={handleChange} minRows={3} placeholder="A short description of the item for the shop page." />
                </FormControl>

                <Stack direction="row" spacing={2}>
                    <FormControl required sx={{ flex: 1 }}>
                        <FormLabel>Price (in coins)</FormLabel>
                        <Input name="price" type="number" value={formData.price} onChange={handleChange} />
                    </FormControl>
                    <FormControl required sx={{ flex: 1 }}>
                        <FormLabel>Category</FormLabel>
                        <Input name="category" value={formData.category} onChange={handleChange} placeholder="e.g., ranks, items, keys" />
                    </FormControl>
                </Stack>

                <FormControl>
                    <FormLabel>Image URL</FormLabel>
                    <Input name="image_url" value={formData.image_url} onChange={handleChange} placeholder="https://example.com/image.png" />
                </FormControl>

                <FormControl required>
                    <FormLabel>In-game Command</FormLabel>
                    <Input name="ingame_command" value={formData.ingame_command} onChange={handleChange} placeholder="lp user {username} parent set vip" />
                </FormControl>

                <FormControl sx={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                    <FormLabel>Item is Active</FormLabel>
                    <Switch name="is_active" checked={formData.is_active} onChange={handleSwitchChange} />
                </FormControl>

                <Button type="submit" loading={loading} sx={{ mt: 2 }}>
                    Create Item
                </Button>
            </Stack>
        </Box>
    );
}

export default AdminCreateItemPage;
--- END FILE: frontend/src/pages/AdminCreateItemPage.js ---



--- START FILE: frontend/src/pages/AdminCustomPages.js ---

// frontend/src/pages/AdminCustomPages.js
import React, { useState, useEffect, useCallback } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box, Typography, Button, CircularProgress, Alert, Sheet, Table,
    IconButton, Tooltip, Link as JoyLink, Chip
} from '@mui/joy';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import ArticleIcon from '@mui/icons-material/Article';


function AdminCustomPages() {
    const { authToken } = useAuth();
    const navigate = useNavigate();
    const [pages, setPages] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchPages = useCallback(async () => {
        setLoading(true);
        try {
            const response = await axios.get('/api/admin/pages', {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            setPages(response.data);
        } catch (err) {
            setError('Failed to load pages.');
        } finally {
            setLoading(false);
        }
    }, [authToken]);

    useEffect(() => {
        fetchPages();
    }, [fetchPages]);

    const handleDelete = async (pageId) => {
        if (!window.confirm('Are you sure you want to delete this page?')) return;
        try {
            await axios.delete(`/api/admin/pages/${pageId}`, {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            fetchPages();
        } catch (err) {
            alert('Failed to delete page.');
        }
    };

    if (loading) return <CircularProgress />;
    if (error) return <Alert color="danger">{error}</Alert>;

    return (
        <Box>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography level="h2">Custom Pages</Typography>
                <Button
                    component={RouterLink}
                    to="/admin/pages/new"
                    startDecorator={<AddIcon />}
                >
                    Create Page
                </Button>
            </Box>
            <Sheet variant="outlined" sx={{ borderRadius: 'sm', overflow: 'auto' }}>
                <Table hoverRow>
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>URL Slug</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {pages.map((page) => (
                            <tr key={page.id}>
                                <td>{page.title}</td>
                                <td>
                                    <JoyLink component={RouterLink} to={`/p/${page.slug}`} target="_blank" rel="noopener noreferrer">
                                        /p/{page.slug}
                                    </JoyLink>
                                </td>
                                <td>
                                    {page.is_published ? (
                                        <Chip color="success" size="sm">Published</Chip>
                                    ) : (
                                        <Chip color="neutral" size="sm">Draft</Chip>
                                    )}
                                </td>
                                <td>
                                    <Tooltip title="Edit">
                                        <IconButton size="sm" variant="outlined" color="neutral" onClick={() => navigate(`/admin/pages/${page.id}`)}>
                                            <EditIcon />
                                        </IconButton>
                                    </Tooltip>
                                    <Tooltip title="Delete">
                                        <IconButton size="sm" variant="soft" color="danger" onClick={() => handleDelete(page.id)}>
                                            <DeleteForeverIcon />
                                        </IconButton>
                                    </Tooltip>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </Table>
            </Sheet>
        </Box>
    );
}

export default AdminCustomPages;
--- END FILE: frontend/src/pages/AdminCustomPages.js ---



--- START FILE: frontend/src/pages/AdminEditPage.js ---

// frontend/src/pages/AdminEditPage.js
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { TiptapEditor } from '../components/TiptapEditor'; // –ù–∞—à –Ω–æ–≤—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä
import {
    Box, Typography, Button, CircularProgress, Alert, FormControl,
    FormLabel, Input, Switch, Stack, Breadcrumbs, Link as JoyLink
} from '@mui/joy';
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import toast from 'react-hot-toast';

function AdminEditPage() {
    const { pageId } = useParams();
    const navigate = useNavigate();
    const { authToken } = useAuth();
    const isCreating = !pageId;

    const [title, setTitle] = useState('');
    const [slug, setSlug] = useState('');
    const [content, setContent] = useState('');
    const [is_published, setIsPublished] = useState(false);

    const [loading, setLoading] = useState(!isCreating);
    const [error, setError] = useState(null);

    const fetchPageData = useCallback(() => {
        if (!isCreating) {
            axios.get(`/api/admin/pages/${pageId}`, { headers: { Authorization: `Bearer ${authToken}` } })
                .then(response => {
                    const { title, slug, content, is_published } = response.data;
                    setTitle(title);
                    setSlug(slug);
                    setContent(content);
                    setIsPublished(is_published);
                })
                .catch(() => setError('Failed to load page data.'))
                .finally(() => setLoading(false));
        }
    }, [pageId, isCreating, authToken]);

    useEffect(() => {
        fetchPageData();
    }, [fetchPageData]);

    const handleSubmit = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError(null);

        // --- –í–û–¢ –ù–ê–®–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï ---
        // –ú—ã –±—É–¥–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –Ω–µ –≤–µ—Å—å formData, –∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç payload
        let payload;

        if (isCreating) {
            // –î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ title –∏ content, –∫–∞–∫ —Ç–æ–≥–æ —Ç—Ä–µ–±—É–µ—Ç CreatePageDto
            payload = {
                title: title,
                content: content,
            };
        } else {
            // –î–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ –ø–æ–ª—è, —Ç–∞–∫ –∫–∞–∫ UpdatePageDto —ç—Ç–æ —Ä–∞–∑—Ä–µ—à–∞–µ—Ç
            payload = {
                title: title,
                slug: slug,
                content: content,
                is_published: is_published,
            };
        }
        // -----------------------------

        const apiCall = isCreating
            ? axios.post('/api/admin/pages', payload, { headers: { Authorization: `Bearer ${authToken}` } })
            : axios.patch(`/api/admin/pages/${pageId}`, payload, { headers: { Authorization: `Bearer ${authToken}` } });

        try {
            await apiCall;
            toast.success(`Page ${isCreating ? 'created' : 'updated'} successfully!`);
            navigate('/admin/pages');
        } catch (err) {
            const errorMessage = err.response?.data?.message || 'An error occurred.';
            // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ - —ç—Ç–æ –º–∞—Å—Å–∏–≤, –æ–±—ä–µ–¥–∏–Ω–∏–º –µ–≥–æ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
            setError(Array.isArray(errorMessage) ? errorMessage.join(', ') : errorMessage);
            setLoading(false);
        }
    };

    if (loading && !isCreating) return <CircularProgress />;

    return (
        <Box component="form" onSubmit={handleSubmit}>
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 2 }}>
                <JoyLink component={RouterLink} to="/admin/users"><HomeIcon /></JoyLink>
                <JoyLink component={RouterLink} to="/admin/pages">Custom Pages</JoyLink>
                <Typography>{isCreating ? 'Create' : 'Edit'}</Typography>
            </Breadcrumbs>

            <Typography level="h2" sx={{ mb: 2 }}>{isCreating ? 'Create New Page' : 'Edit Page'}</Typography>

            {error && <Alert color="danger" sx={{ mb: 2 }}>{error}</Alert>}

            <Stack spacing={2}>
                <FormControl required>
                    <FormLabel>Page Title</FormLabel>
                    <Input name="title" value={title} onChange={(e) => setTitle(e.target.value)} />
                </FormControl>

                {!isCreating && (
                    <FormControl required>
                        <FormLabel>URL Slug (e.g., /p/your-slug)</FormLabel>
                        <Input name="slug" value={slug} onChange={(e) => setSlug(e.target.value)} />
                    </FormControl>
                )}
                <FormControl required>
                    <FormLabel>Content</FormLabel>
                    {/* –°–æ–∑–¥–∞–µ–º "–∫–ª–µ—Ç–∫—É" (–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä-–æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å) –¥–ª—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ */}
                    <Box
                        sx={{
                            width: '100%',
                            maxWidth: '100%', // –í–∞–∂–Ω–æ, —á—Ç–æ–±—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –≤—ã–ª–µ–∑–∞–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —Ä–æ–¥–∏—Ç–µ–ª—è
                        }}
                    >
                        <TiptapEditor content={content} onChange={setContent} />
                    </Box>
                </FormControl>

                <FormControl sx={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                    <FormLabel>Publish Page</FormLabel>
                    <Switch checked={is_published} onChange={(e) => setIsPublished(e.target.checked)} />
                </FormControl>

                <Button type="submit" loading={loading} sx={{ mt: 2, alignSelf: 'flex-start' }}>
                    {isCreating ? 'Create Page' : 'Save Changes'}
                </Button>
            </Stack>
        </Box>
    );
}

export default AdminEditPage;
--- END FILE: frontend/src/pages/AdminEditPage.js ---



--- START FILE: frontend/src/pages/AdminPage.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box, Typography, Sheet, Table, Input, CircularProgress, Alert, Chip, Button,
    Modal, ModalDialog, ModalClose, Select, Option, FormControl, FormLabel,
    Stack, Tooltip,
    useTheme,
    Divider,
    IconButton
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import EditIcon from '@mui/icons-material/Edit';
import BlockIcon from '@mui/icons-material/Block';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import JoyPagination from '../components/JoyPagination';

// --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —Ü–≤–µ—Ç–Ω–æ–º —Ñ–æ–Ω–µ ---
function isColorLight(hexColor) {
    if (!hexColor) return false;
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    // –§–æ—Ä–º—É–ª–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è—Ä–∫–æ—Å—Ç–∏
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155;
}


function AdminPage() {
    const { authToken } = useAuth();
    const [users, setUsers] = useState([]);
    const [ranks, setRanks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [searchQuery, setSearchQuery] = useState('');

    const [page, setPage] = useState(1);
    const [limit, setLimit] = useState(15); // –ë—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ 15 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    const [totalPages, setTotalPages] = useState(0);

    const [isModalOpen, setIsModalOpen] = useState(false);
    const [selectedUser, setSelectedUser] = useState(null);
    const [selectedRankId, setSelectedRankId] = useState('');
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    const fetchUsers = useCallback(async (query) => {
        setLoading(true);
        try {
            const config = {
                headers: { Authorization: `Bearer ${authToken}` },
                // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –≤ –∑–∞–ø—Ä–æ—Å
                params: { search: query, page, limit },
            };
            const response = await axios.get(`/api/users`, config);

            // –ë–µ—Ä–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø–æ–ª—è 'data'
            setUsers(response.data.data);
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü
            setTotalPages(Math.ceil(response.data.total / limit));

        } catch (err) {
            setError('Failed to load user data.');
            console.error(err);
        } finally {
            setLoading(false);
        }
        // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ useCallback
    }, [authToken, page, limit]);


    // --- –î–û–ë–ê–í–õ–ï–ù–û: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ä–∞–Ω–≥–æ–≤ ---
    const fetchRanks = useCallback(async () => {
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            const response = await axios.get('/api/ranks', config);
            setRanks(response.data);
        } catch (err) {
            console.error("Failed to load ranks list", err);
            // –ú–æ–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        }
    }, [authToken]);


    useEffect(() => {
        // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Ä–∞–Ω–≥–æ–≤
        fetchUsers(searchQuery);
        fetchRanks();
    }, [fetchUsers, fetchRanks, searchQuery]);


    const handleSearch = (event) => {
        if (event.key === 'Enter') {
            setPage(1); // –ü—Ä–∏ –Ω–æ–≤–æ–º –ø–æ–∏—Å–∫–µ –≤—Å–µ–≥–¥–∞ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ searchQuery –≤—ã–∑–æ–≤–µ—Ç –Ω—É–∂–Ω—ã–π useEffect
        }
    };

    const handleOpenModal = (user) => {
        setSelectedUser(user);
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ID —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞–Ω–≥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ---
        setSelectedRankId(user.rank?.id || '');
        setIsModalOpen(true);
    };

    const handleSaveChanges = async () => {
        if (!selectedUser) return;
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∏–º–µ–Ω–µ–º –ø–æ–ª—è (rank_id) –∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (—á–∏—Å–ª–æ–º ID)
            await axios.patch(
                `/api/admin/users/${selectedUser.id}/update`,
                { rank_id: selectedRankId },
                config
            );

            setIsModalOpen(false);
            fetchUsers(searchQuery);
        } catch (err) {
            // –£–ª—É—á—à–∏–º –≤—ã–≤–æ–¥ –æ—à–∏–±–æ–∫, —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
            const errorMessage = err.response?.data?.message || 'Failed to update user.';
            alert(Array.isArray(errorMessage) ? errorMessage.join(', ') : errorMessage);
            console.error(err);
        }
    };

    const handleToggleBanStatus = async (user) => {
        const action = user.is_banned ? 'unban' : 'ban';
        if (!window.confirm(`Are you sure you want to ${action} ${user.username}?`)) {
            return;
        }
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            await axios.post(`/api/admin/users/${user.id}/${action}`, {}, config);
            fetchUsers(searchQuery);
        } catch (err) {
            alert(`Failed to ${action} user.`);
            console.error(err);
        }
    };

    if (error) {
        return <Alert color="danger">{error}</Alert>;
    }

    const renderUserCard = (user) => (
        <Sheet key={user.id} variant="outlined" sx={{ p: 2, borderRadius: 'sm' }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: 2 }}>
                <Box>
                    <Typography level="title-md">{user.username}</Typography>
                    <Typography level="body-sm" textColor="text.tertiary">{user.email}</Typography>
                    <Stack direction="row" spacing={1} sx={{ mt: 1 }}>
                        {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–∞–Ω–≥–∞ —Å —Ü–≤–µ—Ç–æ–º --- */}
                        {user.rank ? (
                            <Chip
                                size="sm"
                                variant="soft"
                                sx={{
                                    backgroundColor: user.rank.display_color,
                                    color: isColorLight(user.rank.display_color) ? '#000' : '#FFF'
                                }}
                            >
                                {user.rank.name}
                            </Chip>
                        ) : <Chip size="sm">No Rank</Chip>}

                        {user.is_banned ? (
                            <Chip size="sm" color="danger">Banned</Chip>
                        ) : (
                            <Chip size="sm" color="success">Active</Chip>
                        )}
                    </Stack>
                </Box>
                <Stack direction="column" spacing={0.5} sx={{ alignItems: 'flex-end' }}>
                    <Tooltip title="Edit Rank" variant="outlined" size="sm">
                        <IconButton size="sm" variant="plain" color="neutral" onClick={() => handleOpenModal(user)}>
                            <EditIcon />
                        </IconButton>
                    </Tooltip>
                    {user.is_banned ? (
                        <Tooltip title="Unban User" variant="outlined" size="sm">
                            <IconButton size="sm" variant="plain" color="success" onClick={() => handleToggleBanStatus(user)}>
                                <CheckCircleOutlineIcon />
                            </IconButton>
                        </Tooltip>
                    ) : (
                        <Tooltip title="Ban User" variant="outlined" size="sm">
                            <IconButton size="sm" variant="plain" color="danger" onClick={() => handleToggleBanStatus(user)}>
                                <BlockIcon />
                            </IconButton>
                        </Tooltip>
                    )}
                </Stack>
            </Box>
            <Divider sx={{ my: 1.5 }} />
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Typography level="body-xs">ID: {user.id}</Typography>
                <Typography level="body-xs">Reputation: <strong>{user.reputation_count}</strong></Typography>
            </Box>
        </Sheet>
    );

    return (
        <Box>
            <Typography level="h1" component="h1" sx={{ mb: 3 }}>
                User Management
            </Typography>

            <Input
                sx={{ mb: 2, maxWidth: { xs: '100%', md: '400px' } }}
                placeholder="Search by username or email and press Enter..."
                startDecorator={<SearchIcon />}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={handleSearch}
            />
            {!loading && totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
            {loading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                    <CircularProgress />
                </Box>
            ) : (
                isMobile ? (
                    <Stack spacing={1.5}>
                        {users.map(user => renderUserCard(user))}
                    </Stack>
                ) : (
                    <Sheet variant="outlined" sx={{ borderRadius: 'sm', overflow: 'auto' }}>
                        <Table hoverRow sx={{ '& thead th': { verticalAlign: 'middle' }, '& tbody td': { verticalAlign: 'middle' } }}>
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th style={{ minWidth: '150px' }}>Username</th>
                                    <th style={{ minWidth: '200px' }}>Email</th>
                                    <th>Rank</th>
                                    <th>Reputation</th>
                                    <th>Status</th>
                                    <th style={{ minWidth: '120px' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {users.map((user) => (
                                    <tr key={user.id}>
                                        <td>{user.id}</td>
                                        <td>
                                            {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –¥–ª–∏–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ --- */}
                                            <Tooltip title={user.username} variant="outlined" size="sm">
                                                <Typography
                                                    sx={{
                                                        maxWidth: '150px',
                                                        whiteSpace: 'nowrap',
                                                        overflow: 'hidden',
                                                        textOverflow: 'ellipsis'
                                                    }}
                                                >
                                                    {user.username}
                                                </Typography>
                                            </Tooltip>
                                        </td>
                                        <td>
                                            {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –¥–ª–∏–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ --- */}
                                            <Tooltip title={user.email} variant="outlined" size="sm">
                                                <Typography
                                                    sx={{
                                                        maxWidth: '200px',
                                                        whiteSpace: 'nowrap',
                                                        overflow: 'hidden',
                                                        textOverflow: 'ellipsis'
                                                    }}
                                                >
                                                    {user.email}
                                                </Typography>
                                            </Tooltip>
                                        </td>
                                        <td>
                                            {user.rank ? (
                                                <Chip
                                                    size="sm"
                                                    variant="soft"
                                                    sx={{
                                                        backgroundColor: user.rank.display_color,
                                                        color: isColorLight(user.rank.display_color) ? '#000' : '#FFF'
                                                    }}
                                                >
                                                    {user.rank.name}
                                                </Chip>
                                            ) : <Chip size="sm">No Rank</Chip>}
                                        </td>
                                        <td>{user.reputation_count}</td>
                                        <td>
                                            {user.is_banned ? (
                                                <Chip size="sm" color="danger">Banned</Chip>
                                            ) : (
                                                <Chip size="sm" color="success">Active</Chip>
                                            )}
                                        </td>
                                        <td>
                                            {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –ö–Ω–æ–ø–∫–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –∏–∫–æ–Ω–∫–∏ —Å –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏ --- */}
                                            <Stack direction="row" spacing={1}>
                                                <Tooltip title="Edit" variant="outlined" size="sm">
                                                    <IconButton size="sm" variant="outlined" color="neutral" onClick={() => handleOpenModal(user)}>
                                                        <EditIcon />
                                                    </IconButton>
                                                </Tooltip>
                                                {user.is_banned ? (
                                                    <Tooltip title="Unban" variant="outlined" size="sm">
                                                        <IconButton size="sm" variant="soft" color="success" onClick={() => handleToggleBanStatus(user)}>
                                                            <CheckCircleOutlineIcon />
                                                        </IconButton>
                                                    </Tooltip>
                                                ) : (
                                                    <Tooltip title="Ban" variant="outlined" size="sm">
                                                        <IconButton size="sm" variant="soft" color="danger" onClick={() => handleToggleBanStatus(user)}>
                                                            <BlockIcon />
                                                        </IconButton>
                                                    </Tooltip>
                                                )}
                                            </Stack>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </Table>
                    </Sheet>
                )
            )}
            {totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
            <Modal open={isModalOpen} onClose={() => setIsModalOpen(false)}>
                <ModalDialog>
                    <ModalClose />
                    <Typography level="h4">Edit User: {selectedUser?.username}</Typography>
                    <FormControl sx={{ mt: 2 }}>
                        <FormLabel>Rank</FormLabel>
                        {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π Select --- */}
                        <Select
                            value={selectedRankId}
                            onChange={(e, newValue) => setSelectedRankId(newValue)}
                        >
                            {ranks.map(rank => (
                                <Option key={rank.id} value={rank.id}>{rank.name}</Option>
                            ))}
                        </Select>
                    </FormControl>
                    <Button sx={{ mt: 3 }} onClick={handleSaveChanges}>
                        Save Changes
                    </Button>
                </ModalDialog>
            </Modal>
        </Box>
    );
}

export default AdminPage;
--- END FILE: frontend/src/pages/AdminPage.js ---



--- START FILE: frontend/src/pages/AdminPostsPage.js ---

// frontend/src/pages/AdminPostsPage.js

import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box, Typography, Sheet, Table, Input, CircularProgress, Alert, Button, Tooltip, Link, Stack,
    useTheme,
    IconButton,
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
// --- –®–ê–ì 1: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ ---
import JoyPagination from '../components/JoyPagination';

function AdminPostsPage() {
    const { authToken } = useAuth();
    const navigate = useNavigate();
    const [posts, setPosts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [searchQuery, setSearchQuery] = useState('');
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    // --- –®–ê–ì 2: –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ ---
    const [page, setPage] = useState(1);
    const [limit, setLimit] = useState(15);
    const [totalPages, setTotalPages] = useState(0);

    // --- –®–ê–ì 3: –û–±–Ω–æ–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö ---
    const fetchPosts = useCallback(async (query) => {
        setLoading(true);
        try {
            const config = {
                headers: { Authorization: `Bearer ${authToken}` },
                params: {
                    search: query,
                    sortBy: 'created_at',
                    order: 'DESC',
                    page,
                    limit
                },
            };
            const response = await axios.get('/api/posts', config);

            // –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–π –æ—Ç–≤–µ—Ç –æ—Ç API
            setPosts(response.data.data);
            setTotalPages(Math.ceil(response.data.total / limit));

        } catch (err) {
            setError('Failed to load post data.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [authToken, page, limit]); // –î–æ–±–∞–≤–ª—è–µ–º page –∏ limit –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

    useEffect(() => {
        fetchPosts(searchQuery);
    }, [fetchPosts, searchQuery]);

    const handleSearch = (event) => {
        if (event.key === 'Enter') {
            setPage(1); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø—Ä–∏ –ø–æ–∏—Å–∫–µ
            fetchPosts(searchQuery);
        }
    };

    const handleDeletePost = async (postId) => {
        if (!window.confirm('Are you sure you want to permanently delete this post?')) return;
        try {
            await axios.delete(`/api/posts/${postId}`, {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            fetchPosts(searchQuery);
        } catch (err) {
            alert('Failed to delete the post.');
            console.error(err);
        }
    };

    const handleEditPost = (postId) => {
        navigate(`/posts/${postId}/edit`);
    };

    if (error) {
        return <Alert color="danger">{error}</Alert>;
    }

    const renderPostCard = (post) => (
        <Sheet key={post.id} variant="outlined" sx={{ p: 2, borderRadius: 'sm' }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: 2 }}>
                <Box sx={{ flexGrow: 1, minWidth: 0 }}>
                    <Link
                        component={RouterLink}
                        to={`/posts/${post.id}`}
                        level="title-md"
                        overlay
                        sx={{ wordBreak: 'break-word' }}
                    >
                        {post.title}
                    </Link>
                    <Typography level="body-sm" textColor="text.tertiary" sx={{ mt: 0.5 }}>
                        by {post.author?.username || 'N/A'} on {new Date(post.created_at).toLocaleDateString()}
                    </Typography>
                </Box>
                <Stack direction="row" spacing={0.5} sx={{ flexShrink: 0 }}>
                    <Tooltip title="Edit Post" variant="outlined" size="sm">
                        <IconButton size="sm" variant="plain" color="neutral" onClick={() => handleEditPost(post.id)}>
                            <EditIcon />
                        </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete Post" variant="outlined" size="sm">
                        <IconButton size="sm" variant="plain" color="danger" onClick={() => handleDeletePost(post.id)}>
                            <DeleteForeverIcon />
                        </IconButton>
                    </Tooltip>
                </Stack>
            </Box>
        </Sheet>
    );

    return (
        <Box>
            <Typography level="h1" component="h1" sx={{ mb: 3 }}>
                Post Management
            </Typography>

            <Input
                sx={{ mb: 2, maxWidth: { xs: '100%', md: '400px' } }}
                placeholder="Search by title and press Enter..."
                startDecorator={<SearchIcon />}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={handleSearch}
            />
            {!loading && totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
            {loading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                    <CircularProgress />
                </Box>
            ) : (
                <>
                    {isMobile ? (
                        <Stack spacing={1.5}>
                            {posts.map(post => renderPostCard(post))}
                        </Stack>
                    ) : (
                        <Sheet variant="outlined" sx={{ borderRadius: 'sm', overflow: 'auto' }}>
                            <Table hoverRow sx={{ tableLayout: 'fixed' }}>
                                <thead>
                                    <tr>
                                        <th style={{ width: '60px' }}>ID</th>
                                        <th style={{ width: '40%' }}>Title</th>
                                        <th style={{ width: '20%' }}>Author</th>
                                        <th style={{ width: '15%' }}>Created At</th>
                                        <th style={{ width: '15%' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {posts.map((post) => (
                                        <tr key={post.id}>
                                            <td>{post.id}</td>
                                            <td>
                                                <Link component={RouterLink} to={`/posts/${post.id}`} sx={{ wordBreak: 'break-all' }}>
                                                    {post.title}
                                                </Link>
                                            </td>
                                            <td>{post.author?.username || 'N/A'}</td>
                                            <td>{new Date(post.created_at).toLocaleDateString()}</td>
                                            <td>
                                                <Stack direction="row" spacing={1}>
                                                    <Tooltip title="Edit Post" variant="outlined" size="sm">
                                                        <IconButton size="sm" variant="outlined" color="neutral" onClick={() => handleEditPost(post.id)}>
                                                            <EditIcon />
                                                        </IconButton>
                                                    </Tooltip>
                                                    <Tooltip title="Delete Post" variant="outlined" size="sm">
                                                        <IconButton size="sm" variant="soft" color="danger" onClick={() => handleDeletePost(post.id)}>
                                                            <DeleteForeverIcon />
                                                        </IconButton>
                                                    </Tooltip>
                                                </Stack>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </Table>
                        </Sheet>
                    )}

                    {/* --- –®–ê–ì 4: –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ --- */}
                    {totalPages > 1 && (
                        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                            <JoyPagination
                                count={totalPages}
                                page={page}
                                onChange={(event, value) => setPage(value)}
                            />
                        </Box>
                    )}
                </>
            )}
        </Box>
    );
}

export default AdminPostsPage;
--- END FILE: frontend/src/pages/AdminPostsPage.js ---



--- START FILE: frontend/src/pages/AdminRanksPage.js ---

// frontend/src/pages/AdminRanksPage.js

import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box, Typography, Sheet, Table, Input, CircularProgress, Alert, Chip, Button,
    Modal, ModalDialog, ModalClose, FormControl, FormLabel, FormHelperText,
    Stack, Tooltip, IconButton, Select, Option
} from '@mui/joy';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import AddIcon from '@mui/icons-material/Add';
import ShieldIcon from '@mui/icons-material/Shield';

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —á–∏–ø–∞—Ö
function isColorLight(hexColor) {
    if (!hexColor) return false;
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155;
}

function AdminRanksPage() {
    const { authToken } = useAuth();
    const [ranks, setRanks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
    const [rankToDelete, setRankToDelete] = useState(null);
    const [migrationRankId, setMigrationRankId] = useState('');

    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingRank, setEditingRank] = useState(null);
    const [formData, setFormData] = useState({ name: '', system_name: '', power_level: 10, display_color: '#808080', command_template: '', command_template_remove: '' }); const [modalError, setModalError] = useState('');

    const fetchRanks = useCallback(async () => {
        setLoading(true);
        try {
            const response = await axios.get('/api/ranks', { headers: { Authorization: `Bearer ${authToken}` } });
            // –û—Ç–≤–µ—Ç –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –ø–æ power_level –Ω–∞ –±—ç–∫–µ–Ω–¥–µ, —á—Ç–æ –∏ –∑–∞–¥–∞–µ—Ç –∏—Ö –ø–æ—Ä—è–¥–æ–∫
            setRanks(response.data);
        } catch (err) {
            setError('Failed to load ranks data.');
        } finally {
            setLoading(false);
        }
    }, [authToken]);

    useEffect(() => {
        fetchRanks();
    }, [fetchRanks]);

    const handleOpenModal = (rank = null) => {
        setModalError('');
        if (rank) {
            setEditingRank(rank);
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª—è –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
            setFormData({
                name: rank.name,
                system_name: rank.system_name,
                power_level: rank.power_level,
                display_color: rank.display_color,
                command_template: rank.command_template || '', // || '' –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ null
                command_template_remove: rank.command_template_remove || ''
            });
        } else {
            setEditingRank(null);
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Ä–∞–Ω–≥–∞
            setFormData({
                name: '',
                system_name: '',
                power_level: 10,
                display_color: '#808080',
                command_template: '',
                command_template_remove: ''
            });
        }
        setIsModalOpen(true);
    };

    const handleCloseModal = () => {
        setIsModalOpen(false);
    };

    const handleFormChange = (e) => {
        const { name, value } = e.target;

        // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨ ---
        // –ï—Å–ª–∏ –º—ã –º–µ–Ω—è–µ–º –ø–æ–ª–µ 'power_level', –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –µ–≥–æ –≤ —á–∏—Å–ª–æ
        if (name === 'power_level') {
            // parseInt(value, 10) –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ.
            // –ï—Å–ª–∏ –ø–æ–ª–µ –ø—É—Å—Ç–æ–µ, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ —Å—Ç–∏—Ä–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ.
            const numericValue = value === '' ? '' : parseInt(value, 10);
            setFormData(prev => ({ ...prev, [name]: numericValue }));
        } else {
            // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
            setFormData(prev => ({ ...prev, [name]: value }));
        }
    };

    const handleSaveRank = async (event) => {
        event.preventDefault();
        setModalError('');

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä–∞–Ω–≥–∏ —Å–∏–ª—å–Ω–µ–µ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
        const isCustomRank = !editingRank || editingRank.is_removable;

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¢–û–õ–¨–ö–û –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ä–∞–Ω–≥–æ–≤
        if (isCustomRank && formData.power_level >= 800) {
            setModalError('Power level must be less than 800 for custom ranks.');
            return;
        }

        const apiCall = editingRank
            ? axios.patch(`/api/ranks/${editingRank.id}`, formData, { headers: { Authorization: `Bearer ${authToken}` } })
            : axios.post('/api/ranks', formData, { headers: { Authorization: `Bearer ${authToken}` } });

        try {
            await apiCall;
            fetchRanks();
            handleCloseModal();
        } catch (err) {
            setModalError(err.response?.data?.message || 'An error occurred.');
        }
    };

    const handleDeleteRank = async (rank) => {
        if (!window.confirm(`Are you sure you want to delete the rank "${rank.name}"? This cannot be undone.`)) {
            return;
        }

        try {
            // –ü–µ—Ä–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞: –ø—Ä–æ—Å—Ç–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
            await axios.delete(`/api/ranks/${rank.id}`, { headers: { Authorization: `Bearer ${authToken}` } });
            // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫
            fetchRanks();
        } catch (err) {
            // –ï—Å–ª–∏ –±—ç–∫–µ–Ω–¥ –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É "—Ä–∞–Ω–≥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è" (409)
            if (err.response && err.response.status === 409) {
                // –û—Ç–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–∏–≥—Ä–∞—Ü–∏–∏
                setRankToDelete(rank);
                setModalError(err.response.data.message); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç API
                setIsDeleteModalOpen(true);
            } else {
                // –î—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
                alert(err.response?.data?.message || 'Failed to delete rank.');
            }
        }
    };

    const handleConfirmDeleteWithMigration = async () => {
        if (!rankToDelete || !migrationRankId) {
            setModalError('You must select a rank to migrate users to.');
            return;
        }

        try {
            // –í—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞: —É–¥–∞–ª–µ–Ω–∏–µ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º migrationRankId –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞
            await axios.delete(`/api/ranks/${rankToDelete.id}`, {
                headers: { Authorization: `Bearer ${authToken}` },
                data: { migrationRankId: Number(migrationRankId) } // axios –¥–ª—è DELETE —Ç—Ä–µ–±—É–µ—Ç —Ç–µ–ª–æ –≤ –ø–æ–ª–µ data
            });

            // –£—Å–ø–µ—Ö! –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
            setIsDeleteModalOpen(false);
            setRankToDelete(null);
            setMigrationRankId('');
            setModalError('');
            fetchRanks();
        } catch (err) {
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤–Ω—É—Ç—Ä–∏ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
            setModalError(err.response?.data?.message || 'An error occurred during migration.');
        }
    };

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;

    return (
        <Box>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                <Typography level="h1" component="h1">Rank Management</Typography>
                <Button startDecorator={<AddIcon />} onClick={() => handleOpenModal()}>
                    Create Rank
                </Button>
            </Box>

            <Sheet variant="outlined" sx={{ borderRadius: 'sm', overflow: 'auto' }}>
                <Table hoverRow>
                    <thead>
                        <tr>
                            <th style={{ width: '80px' }}>ID</th>
                            <th>Color</th>
                            <th>Display Name</th>
                            <th>System Name</th>
                            <th>Power Level</th>
                            <th style={{ width: '120px' }}>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {ranks.map((rank) => (
                            <tr key={rank.id}>
                                <td>{rank.id}</td>
                                <td>
                                    <Chip
                                        size="lg"
                                        variant="soft"
                                        sx={{ bgcolor: rank.display_color, border: '1px solid rgba(0,0,0,0.2)' }}
                                    />
                                </td>
                                <td>{rank.name}</td>
                                <td>{rank.system_name}</td>
                                <td>{rank.power_level}</td>
                                <td>
                                    <Stack direction="row" spacing={1}>
                                        <Tooltip title="Edit Rank" variant="outlined" size="sm">
                                            <IconButton size="sm" color="neutral" onClick={() => handleOpenModal(rank)}>
                                                <EditIcon />
                                            </IconButton>
                                        </Tooltip>
                                        <Tooltip title="Delete Rank" variant="outlined" size="sm">
                                            <Box> {/* –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è Tooltip, —á—Ç–æ–±—ã –æ–Ω —Ä–∞–±–æ—Ç–∞–ª –Ω–∞ disabled –∫–Ω–æ–ø–∫–µ */}
                                                <IconButton
                                                    size="sm"
                                                    color="danger"
                                                    // --- –ò–ó–ú–ï–ù–ï–ù–û: –ø–µ—Ä–µ–¥–∞–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç rank, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ id ---
                                                    onClick={() => handleDeleteRank(rank)}
                                                    disabled={!rank.is_removable}
                                                >
                                                    <DeleteForeverIcon />
                                                </IconButton>
                                            </Box>
                                        </Tooltip>
                                    </Stack>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </Table>
            </Sheet>

            <Modal open={isModalOpen} onClose={handleCloseModal}>
                <ModalDialog>
                    <ModalClose />
                    <Typography level="h4">{editingRank ? 'Edit Rank' : 'Create New Rank'}</Typography>
                    <form onSubmit={handleSaveRank}>
                        <Stack spacing={2} sx={{ mt: 2 }}>
                            <FormControl>
                                <FormLabel>Display Name</FormLabel>
                                <Input name="name" value={formData.name} onChange={handleFormChange} autoFocus required />
                            </FormControl>
                            <FormControl required disabled={editingRank && !editingRank.is_removable}>
                                <FormLabel>System Name</FormLabel>
                                <Input name="system_name" value={formData.system_name} onChange={handleFormChange} required />
                                <FormHelperText>
                                    –ò–º—è –¥–ª—è —Å–≤—è–∑–∏ —Å –∏–≥—Ä–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'vip'). –ú–∞–ª–µ–Ω—å–∫–∏–µ –±—É–∫–≤—ã, –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤.
                                </FormHelperText>
                            </FormControl>
                            <FormControl disabled={editingRank && !editingRank.is_removable}>
                                <FormLabel>Power Level</FormLabel>
                                <Input name="power_level" type="number" value={formData.power_level} onChange={handleFormChange} required />
                                <FormHelperText>Must be between 1 and 799. Higher is more powerful.</FormHelperText>
                            </FormControl>
                            <FormControl>
                                <FormLabel>Command Template (for issuing)</FormLabel>
                                <Input
                                    name="command_template"
                                    value={formData.command_template}
                                    onChange={handleFormChange}
                                    placeholder="e.g., lp user {username} parent set vip"
                                />
                                <FormHelperText>
                                    Use {'{username}'} as a placeholder. Can be empty.
                                </FormHelperText>
                            </FormControl>

                            <FormControl>
                                <FormLabel>Command Template (for removal)</FormLabel>
                                <Input
                                    name="command_template_remove"
                                    value={formData.command_template_remove}
                                    onChange={handleFormChange}
                                    placeholder="e.g., lp user {username} parent remove vip"
                                />
                                <FormHelperText>
                                    This command is executed when rank is removed.
                                </FormHelperText>
                            </FormControl>
                            <FormControl>
                                <FormLabel>Display Color</FormLabel>
                                <Input name="display_color" type="color" value={formData.display_color} onChange={handleFormChange} sx={{ p: 0, border: 0, '& input': { p: 0 } }} required />
                            </FormControl>
                            {modalError && <Alert color="danger">{modalError}</Alert>}
                            <Button type="submit" sx={{ mt: 1 }}>Save Changes</Button>
                        </Stack>
                    </form>
                </ModalDialog>
            </Modal>
            <Modal open={isDeleteModalOpen} onClose={() => setIsDeleteModalOpen(false)}>
                <ModalDialog>
                    <ModalClose />
                    <Typography level="h4">Delete Rank: {rankToDelete?.name}</Typography>
                    <Stack spacing={2} sx={{ mt: 2 }}>
                        <Alert color="warning">
                            {modalError || `The rank "${rankToDelete?.name}" is currently in use. To delete it, please select a new rank to which all current members will be migrated.`}
                        </Alert>

                        <FormControl>
                            <FormLabel>Migrate Users To</FormLabel>
                            <Select
                                placeholder="Select a new rank..."
                                value={migrationRankId}
                                onChange={(e, newValue) => setMigrationRankId(newValue)}
                            >
                                {ranks
                                    .filter(r => r.id !== rankToDelete?.id) // –ù–µ–ª—å–∑—è –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —É–¥–∞–ª—è–µ–º—ã–π —Ä–∞–Ω–≥
                                    .map(rank => (
                                        <Option key={rank.id} value={rank.id}>
                                            {rank.name} (Power: {rank.power_level})
                                        </Option>
                                    ))
                                }
                            </Select>
                        </FormControl>

                        <Button
                            color="danger"
                            onClick={handleConfirmDeleteWithMigration}
                            disabled={!migrationRankId}
                        >
                            Confirm Deletion and Migrate Users
                        </Button>
                    </Stack>
                </ModalDialog>
            </Modal>
        </Box>
    );
}

export default AdminRanksPage;
--- END FILE: frontend/src/pages/AdminRanksPage.js ---



--- START FILE: frontend/src/pages/AdminShopPage.js ---

// frontend/src/pages/AdminShopPage.js
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { Box, Typography, Button, CircularProgress, Alert, Sheet, Table, Chip, IconButton, Tooltip } from '@mui/joy';
import { Link as RouterLink } from 'react-router-dom';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';

// –ù–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –í–°–ï–• —Ç–æ–≤–∞—Ä–æ–≤, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö.
// –î–ª—è —ç—Ç–æ–≥–æ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –Ω–∞ –±—ç–∫–µ–Ω–¥–µ,
// –Ω–æ –ø–æ–∫–∞ –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π.
// –í –∏–¥–µ–∞–ª–µ: GET /api/shop/all (–∑–∞—â–∏—â–µ–Ω–Ω—ã–π –¥–ª—è –∞–¥–º–∏–Ω–æ–≤).

function AdminShopPage() {
    const { authToken } = useAuth();
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchAllItems = useCallback(async () => {
        setLoading(true);
        try {
            // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≠—Ç–æ—Ç —ç–Ω–¥–ø–æ–∏–Ω—Ç –æ—Ç–¥–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã.
            // –í –∏–¥–µ–∞–ª–µ –Ω—É–∂–µ–Ω –æ—Ç–¥–µ–ª—å–Ω—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –∞–¥–º–∏–Ω–æ–≤, –æ—Ç–¥–∞—é—â–∏–π –≤—Å–µ.
            const response = await axios.get('/api/shop', {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            setItems(response.data);
        } catch (err) {
            setError('Failed to load shop items.');
        } finally {
            setLoading(false);
        }
    }, [authToken]);

    useEffect(() => {
        fetchAllItems();
    }, [fetchAllItems]);
    
    // TODO: –õ–æ–≥–∏–∫–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
    const handleDelete = async (itemId) => {
        if (!window.confirm('Are you sure you want to delete this item?')) return;
        try {
            await axios.delete(`/api/shop/${itemId}`, {
                headers: { Authorization: `Bearer ${authToken}` },
            });
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è
            fetchAllItems();
        } catch (err) {
            alert('Failed to delete item.');
        }
    };

    if (loading) return <CircularProgress />;
    if (error) return <Alert color="danger">{error}</Alert>;

    return (
        <Box>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography level="h2">Shop Management</Typography>
                <Button
                    component={RouterLink}
                    to="/admin/shop/new" // –°—Å—ã–ª–∫–∞ –Ω–∞ –±—É–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
                    startDecorator={<AddIcon />}
                >
                    Create Item
                </Button>
            </Box>
            <Sheet variant="outlined" sx={{ borderRadius: 'sm', overflow: 'auto' }}>
                <Table hoverRow>
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Price</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {items.map((item) => (
                            <tr key={item.item_id}>
                                <td>{item.item_id}</td>
                                <td>{item.name}</td>
                                <td>{item.price} coins</td>
                                <td>
                                    {item.is_active ? 
                                        <Chip color="success" size="sm">Active</Chip> : 
                                        <Chip color="danger" size="sm">Inactive</Chip>
                                    }
                                </td>
                                <td>
                                    <Tooltip title="Edit">
                                        <IconButton size="sm" variant="outlined" color="neutral">
                                            <EditIcon />
                                        </IconButton>
                                    </Tooltip>
                                    <Tooltip title="Delete">
                                        <IconButton size="sm" variant="soft" color="danger" onClick={() => handleDelete(item.item_id)}>
                                            <DeleteForeverIcon />
                                        </IconButton>
                                    </Tooltip>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </Table>
            </Sheet>
        </Box>
    );
}

export default AdminShopPage;
--- END FILE: frontend/src/pages/AdminShopPage.js ---



--- START FILE: frontend/src/pages/ConversationPage.js ---

// frontend/src/pages/ConversationPage.js

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { useNotifications } from '../context/NotificationsContext';
import {
    Box, Typography, Sheet, CircularProgress, Alert, Textarea, IconButton, Avatar, Stack, FormControl, Button,
    Dropdown, Menu, MenuButton, MenuItem, Link as JoyLink,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö—É–∫–∏ –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ ---
    useTheme
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import MoreHorizIcon from '@mui/icons-material/MoreHoriz';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import ReplyIcon from '@mui/icons-material/Reply';
import CloseIcon from '@mui/icons-material/Close';
import axios from 'axios';
import { constructImageUrl } from '../utils/url';
import CircleIcon from '@mui/icons-material/Circle';

function ConversationPage() {
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ ---
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm')); // –ò—Å–ø–æ–ª—å–∑—É–µ–º 'sm' –¥–ª—è —á–∞—Ç–∞

    // ... (–æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å —Ö—É–∫–æ–≤ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    const { userId: otherUserId } = useParams();
    const navigate = useNavigate();
    const { user: currentUser, authToken, socket } = useAuth();
    const { markNotificationsAsReadByLink } = useNotifications();
    
    const [conversations, setConversations] = useState({});
    const [isConnected, setIsConnected] = useState(socket?.connected || false);
    const [otherUser, setOtherUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [newMessage, setNewMessage] = useState('');
    const [friendshipStatus, setFriendshipStatus] = useState(null);
    const [editingMessage, setEditingMessage] = useState(null);
    const [replyingToMessage, setReplyingToMessage] = useState(null);
    const [highlightedMessageId, setHighlightedMessageId] = useState(null);

    const messagesEndRef = useRef(null);
    const messages = conversations[otherUserId] || [];
    
    // ... (–≤—Å—è –ª–æ–≥–∏–∫–∞ (useEffect, handleSendMessage –∏ —Ç.–¥.) –æ—Å—Ç–∞–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–µ–π) ...
    
    useEffect(() => {
        if (!socket || !otherUser) return;
        const handleStatusUpdate = (data) => {
            if (data.userId === otherUser.id) {
                setOtherUser(prevUser => ({ ...prevUser, is_minecraft_online: data.is_minecraft_online }));
            }
        };
        socket.on('userStatusUpdate', handleStatusUpdate);
        return () => { socket.off('userStatusUpdate', handleStatusUpdate); };
    }, [socket, otherUser]);
    
    const handleReplyLinkClick = (event, messageId) => {
        event.preventDefault(); 
        const element = document.getElementById(`msg-${messageId}`);
        if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            setHighlightedMessageId(messageId);
            setTimeout(() => { setHighlightedMessageId(null); }, 1500);
        }
    };

    useEffect(() => {
        if (socket && otherUserId) {
            socket.emit('startViewingChat', { otherUserId: Number(otherUserId) });
            return () => { socket.emit('stopViewingChat'); };
        }
    }, [socket, otherUserId]);

    const loadInitialData = useCallback(async () => {
        if (!otherUserId || !authToken) return;
        try {
            setLoading(true);
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            const [userRes, friendshipRes, conversationRes] = await Promise.all([
                axios.get(`/api/users/${otherUserId}`, config),
                axios.get(`/api/friendships/status/${otherUserId}`, config),
                axios.get(`/api/messages/conversation/${otherUserId}`, config)
            ]);
            setOtherUser(userRes.data);
            setFriendshipStatus(friendshipRes.data.status);
            setConversations(prev => ({ ...prev, [otherUserId]: conversationRes.data }));
            markNotificationsAsReadByLink(`/messages/${otherUserId}`);
        } catch (err) {
            setError('Failed to load chat data. This user may not exist.');
        } finally {
            setLoading(false);
        }
    }, [otherUserId, authToken, markNotificationsAsReadByLink]);

    useEffect(() => {
        loadInitialData();
    }, [loadInitialData]);

    useEffect(() => {
        if (!socket) return;
        const handleMessageUpdate = (updatedMessage) => {
            const convoId = updatedMessage.sender.id === currentUser.id ? updatedMessage.receiver.id : updatedMessage.sender.id;
            if (String(convoId) !== otherUserId) return;
            setConversations(prev => {
                const currentConvo = prev[otherUserId] || [];
                const existingIndex = currentConvo.findIndex(m => m.id === updatedMessage.id);
                let newConvo;
                if (existingIndex > -1) {
                    newConvo = [...currentConvo];
                    newConvo[existingIndex] = updatedMessage;
                } else {
                    newConvo = [...currentConvo, updatedMessage];
                }
                return { ...prev, [otherUserId]: newConvo };
            });
        };
        const handleMessageDelete = ({ messageId }) => {
            setConversations(prev => {
                const currentConvo = prev[otherUserId] || [];
                const newConvo = currentConvo.map(m => 
                    m.id === messageId 
                    ? { ...m, content: 'Message has been deleted.', is_deleted: true } 
                    : m
                );
                return { ...prev, [otherUserId]: newConvo };
            });
        };
        const handleConnect = () => setIsConnected(true);
        const handleDisconnect = () => setIsConnected(false);
        socket.on('newMessage', handleMessageUpdate);
        socket.on('messageEdited', handleMessageUpdate);
        socket.on('messageDeleted', handleMessageDelete);
        socket.on('connect', handleConnect);
        socket.on('disconnect', handleDisconnect);
        return () => {
            socket.off('newMessage', handleMessageUpdate);
            socket.off('messageEdited', handleMessageUpdate);
            socket.off('messageDeleted', handleMessageDelete);
            socket.off('connect', handleConnect);
            socket.off('disconnect', handleDisconnect);
        };
    }, [socket, currentUser, otherUserId]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    const handleSendMessage = (e) => {
        e.preventDefault();
        if (!newMessage.trim() || !socket || isInputDisabled) return;
        if (editingMessage) {
            socket.emit('editMessage', { messageId: editingMessage.id, content: newMessage });
        } else {
            socket.emit('sendMessage', {
                recipientId: Number(otherUserId),
                content: newMessage,
                parentMessageId: replyingToMessage ? replyingToMessage.id : null,
            });
        }
        cancelActions();
    };
    
    const handleEditClick = (message) => {
        setEditingMessage({ id: message.id, content: message.content });
        setNewMessage(message.content);
        setReplyingToMessage(null);
    };
    const handleReplyClick = (message) => {
        setReplyingToMessage({ id: message.id, sender: message.sender, content: message.content });
        setEditingMessage(null);
    };
    const handleDeleteClick = (messageId) => {
        if (window.confirm('Are you sure you want to delete this message?')) {
            socket.emit('deleteMessage', { messageId });
        }
    };
    const cancelActions = () => {
        setEditingMessage(null);
        setReplyingToMessage(null);
        setNewMessage('');
    };

    let isInputDisabled = true;
    let placeholderText = 'Loading...';
    if (!loading) {
        switch (friendshipStatus) {
            case 'ACCEPTED':
                isInputDisabled = false;
                placeholderText = 'Type a message...';
                break;
            case 'BLOCKED':
                placeholderText = 'You cannot message this user while a block is active.';
                break;
            default:
                placeholderText = 'You must be friends to send messages.';
                break;
        }
    }


    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;
    if (!otherUser) return <Typography>User not found.</Typography>;
    
    return (
        <Sheet sx={{ height: `calc(100vh - ${isMobile ? '104px' : '120px'})`, display: 'flex', flexDirection: 'column' }}>
            <Box sx={{ p: {xs: 1, sm: 2}, borderBottom: '1px solid', borderColor: 'divider', display: 'flex', alignItems: 'center' }}>
                <IconButton onClick={() => navigate('/messages')} sx={{ mr: {xs: 1, sm: 2} }}><ArrowBackIcon /></IconButton>
                <Avatar src={constructImageUrl(otherUser.pfp_url)} />
                <Stack sx={{ ml: {xs: 1.5, sm: 2} }}>
                    <Typography 
                        level={{xs: 'title-md', sm: 'title-lg'}} 
                        sx={{ color: otherUser.rank?.display_color }}
                    >
                    {otherUser.username}
                    </Typography>
                    {otherUser.minecraft_username && (
                         <Typography 
                            level="body-xs" 
                            startDecorator={<CircleIcon sx={{ fontSize: '8px' }} />} 
                            sx={{ color: otherUser.is_minecraft_online ? 'success.400' : 'text.tertiary' }}
                         >
                            {otherUser.is_minecraft_online ? 'Online' : 'Offline'}
                         </Typography>
                    )}
                </Stack>
            </Box>

            <Box sx={{ flex: 1, overflowY: 'auto', p: {xs: 1, sm: 2} }}>
                <Stack spacing={2}>
                {messages.map(msg => (
                    <MessageBubble
                        key={msg.id}
                        message={msg}
                        isOwn={msg.sender?.id === currentUser?.id}
                        isHighlighted={highlightedMessageId === msg.id}
                        onReplyLinkClick={handleReplyLinkClick}
                        onEdit={() => handleEditClick(msg)}
                        onDelete={() => handleDeleteClick(msg.id)}
                        onReply={() => handleReplyClick(msg)}
                        // --- –ò–ó–ú–ï–ù–ï–ù–û: –ü–µ—Ä–µ–¥–∞–µ–º isMobile –≤ –¥–æ—á–µ—Ä–Ω–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç ---
                        isMobile={isMobile}
                    />
                ))}
                <div ref={messagesEndRef} />
                </Stack>
            </Box>

            <Box component="form" onSubmit={handleSendMessage} sx={{ p: {xs: 1, sm: 2}, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.surface' }}>
                {(replyingToMessage || editingMessage) && (
                    <Sheet variant="soft" sx={{ p: 1, mb: 1, borderRadius: 'sm', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Box sx={{overflow: 'hidden'}}>
                            <Typography level="title-sm">
                                {editingMessage ? 'Editing message' : `Replying to ${replyingToMessage.sender.username}`}
                            </Typography>
                            <Typography level="body-sm" noWrap sx={{ opacity: 0.7 }}>
                                {editingMessage ? editingMessage.content : replyingToMessage.content}
                            </Typography>
                        </Box>
                        <IconButton size="sm" onClick={cancelActions} variant="plain"><CloseIcon /></IconButton>
                    </Sheet>
                )}
                <FormControl>
                    <Textarea
                        placeholder={placeholderText}
                        disabled={isInputDisabled}
                        value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { handleSendMessage(e); } }}
                        minRows={1}
                        maxRows={5}
                        endDecorator={
                            <IconButton type="submit" disabled={!newMessage.trim() || !isConnected || isInputDisabled}>
                                <SendIcon />
                            </IconButton>
                        }
                    />
                </FormControl>
            </Box>
        </Sheet>
    );
}

// --- –ò–ó–ú–ï–ù–ï–ù–û: –ö–æ–º–ø–æ–Ω–µ–Ω—Ç MessageBubble —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç isMobile ---
const MessageBubble = ({ message, isOwn, isHighlighted, onReplyLinkClick, onEdit, onDelete, onReply, isMobile }) => {
    const [isHovered, setIsHovered] = useState(false);
    const wasEdited = new Date(message.updated_at).getTime() - new Date(message.sent_at).getTime() > 1000;

    const messageContent = (
        <Sheet
            variant="solid"
            color={isOwn ? 'primary' : 'neutral'}
            sx={{
                p: 1.2,
                borderRadius: 'lg',
                maxWidth: { xs: '85%', sm: '75%', md: '60%' },
                // –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–Ω–æ—Å —Å–ª–æ–≤
                overflowWrap: 'break-word',
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É, —á—Ç–æ–±—ã –ø—É–∑—ã—Ä—å –Ω–µ —Å—Ö–ª–æ–ø—ã–≤–∞–ª—Å—è
                minWidth: 60, 
                // –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
                textAlign: 'left',
                transition: 'background-color 0.3s ease-in-out',
                ...(isHighlighted && { bgcolor: isOwn ? 'primary.600' : 'neutral.600' })
            }}
        >
            {message.parentMessage && !message.parentMessage.is_deleted && (
                <JoyLink
                    onClick={(e) => onReplyLinkClick(e, message.parentMessage.id)}
                    href={`#msg-${message.parentMessage.id}`}
                    sx={{ textDecoration: 'none', color: 'inherit' }}
                >
                    <Sheet variant="soft" sx={{ p: 1, borderRadius: 'sm', mb: 1, opacity: 0.9 }}>
                        <Stack>
                            <Typography level="title-sm">{message.parentMessage.sender.username}</Typography>
                            <Typography level="body-xs" sx={{ whiteSpace: 'normal', overflowWrap: 'break-word' }}>
                                {message.parentMessage.content}
                            </Typography>
                        </Stack>
                    </Sheet>
                </JoyLink>
            )}
            <Typography level="body-md" sx={{ fontStyle: message.is_deleted ? 'italic' : 'normal', opacity: message.is_deleted ? 0.7 : 1, whiteSpace: 'pre-wrap' }}>
                {message.content}
            </Typography>
            <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end', alignItems: 'center', mt: 0.5 }}>
                {wasEdited && !message.is_deleted && <Typography level="body-xs" sx={{ opacity: 0.7 }}>edited</Typography>}
                <Typography level="body-xs" sx={{ opacity: 0.7 }}>
                    {new Date(message.sent_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </Typography>
            </Box>
        </Sheet>
    );

    const menu = (
        <Box sx={{
            width: '32px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            opacity: (isMobile || isHovered) && !message.is_deleted ? 1 : 0,
            transition: 'opacity 0.2s',
            // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –º–µ–Ω—é –Ω–µ —Å–∂–∏–º–∞–µ—Ç—Å—è
            flexShrink: 0,
            }}>
            <Dropdown>
                <MenuButton slots={{ root: IconButton }} slotProps={{ root: { variant: 'plain', color: 'neutral', size: 'sm' } }}>
                    <MoreHorizIcon />
                </MenuButton>
                <Menu size="sm" placement={isOwn ? 'bottom-start' : 'bottom-end'}>
                    <MenuItem onClick={onReply}><ReplyIcon /> Reply</MenuItem>
                    {isOwn && <MenuItem onClick={onEdit}><EditIcon /> Edit</MenuItem>}
                    {isOwn && <MenuItem color="danger" onClick={onDelete}><DeleteIcon /> Delete</MenuItem>}
                </Menu>
            </Dropdown>
        </Box>
    );

    return (
        <Box
            id={`msg-${message.id}`}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            // –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å—Ç—Ä–æ–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–µ–º display: 'flex'
            sx={{
                display: 'flex',
                alignItems: 'flex-end', // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ –Ω–∏–∑—É –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞
                gap: { xs: 1, sm: 1.5 },
                justifyContent: isOwn ? 'flex-end' : 'flex-start'
            }}
        >
            {/* –î–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ */}
            {!isOwn && (
                <>
                    <Avatar src={constructImageUrl(message.sender?.pfp_url)} sx={{ width: { xs: 32, md: 40 }, height: { xs: 32, md: 40 }, flexShrink: 0 }} />
                    {messageContent}
                    {menu}
                </>
            )}

            {/* –î–ª—è –≤–∞—à–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π */}
            {isOwn && (
                <>
                    {menu}
                    {messageContent}
                    {/* –ê–≤–∞—Ç–∞—Ä –¥–ª—è —Å–≤–æ–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –º–æ–∂–Ω–æ —Å–∫—Ä—ã—Ç—å –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */}
                    {!isMobile && <Avatar src={constructImageUrl(message.sender?.pfp_url)} sx={{flexShrink: 0}} />}
                </>
            )}
        </Box>
    );
};

export default ConversationPage;
--- END FILE: frontend/src/pages/ConversationPage.js ---



--- START FILE: frontend/src/pages/CreateNewsPage.js ---

// frontend/src/pages/CreateNewsPage.js

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box,
    Typography,
    FormControl,
    FormLabel,
    Input,
    Textarea,
    Button,
    Alert,
    Breadcrumbs,
    Link as JoyLink,
} from '@mui/joy';
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';

function CreateNewsPage() {
    const navigate = useNavigate();
    const { authToken } = useAuth();
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');

        if (!title.trim() || !content.trim()) {
            setError('Title and content cannot be empty.');
            setLoading(false);
            return;
        }

        try {
            await axios.post(
                '/api/news', // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–∏–ª /api –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏ ---
                { name: title, desc: content },
                { headers: { Authorization: `Bearer ${authToken}` } }
            );
            navigate('/news');
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to create news article.');
            console.error('Error creating news:', err);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box
            component="form"
            onSubmit={handleSubmit}
            sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}
        >
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 1 }}>
                <JoyLink href="/"><HomeIcon /></JoyLink>
                <JoyLink href="/news">News</JoyLink>
                <Typography>Create</Typography>
            </Breadcrumbs>
            
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1">
                Create News Article
            </Typography>
            
            {error && <Alert color="danger" sx={{ mt: 1 }}>{error}</Alert>}

            <FormControl required sx={{ mt: 1 }}>
                <FormLabel>Title</FormLabel>
                <Input
                    placeholder="Enter the article title"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                />
            </FormControl>

            <FormControl required>
                <FormLabel>Content</FormLabel>
                <Textarea
                    placeholder="Write the news content here..."
                    minRows={12}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                />
            </FormControl>
                
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫—É –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π --- */}
            <Button 
                type="submit" 
                loading={loading} 
                sx={{ 
                    mt: 1, 
                    // –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö (xs) –∫–Ω–æ–ø–∫–∞ –±—É–¥–µ—Ç –Ω–∞ –≤—Å—é —à–∏—Ä–∏–Ω—É, –Ω–∞ —ç–∫—Ä–∞–Ω–∞—Ö –ø–æ–±–æ–ª—å—à–µ (sm) - –∞–≤—Ç–æ-—à–∏—Ä–∏–Ω–∞
                    width: { xs: '100%', sm: 'auto' },
                    // –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é
                    alignSelf: { xs: 'center', sm: 'flex-start' }
                }}
            >
                Publish Article
            </Button>
        </Box>
    );
}

export default CreateNewsPage;
--- END FILE: frontend/src/pages/CreateNewsPage.js ---



--- START FILE: frontend/src/pages/CreatePostPage.js ---

// frontend/src/pages/CreatePostPage.js

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Box,
    Typography,
    FormControl,
    FormLabel,
    Input,
    Textarea,
    Button,
    Alert,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è —Ö–ª–µ–±–Ω—ã—Ö –∫—Ä–æ—à–µ–∫ ---
    Breadcrumbs,
    Link as JoyLink,
} from '@mui/joy';
// --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ ---
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';


function CreatePostPage() {
    const navigate = useNavigate();
    const { authToken } = useAuth();
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');

        try {
            const response = await axios.post(
                `/api/posts`, // --- –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º –ø—É—Ç—å –∫ API ---
                { title, content },
                {
                    headers: {
                        Authorization: `Bearer ${authToken}`,
                    },
                }
            );
            // –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –Ω–æ–≤–æ–≥–æ –ø–æ—Å—Ç–∞
            navigate(`/posts/${response.data.id}`);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to create post.');
            console.error('Error creating post:', err);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box
            component="form"
            onSubmit={handleSubmit}
            sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}
        >
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö–ª–µ–±–Ω—ã–µ –∫—Ä–æ—à–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ --- */}
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 1 }}>
                <JoyLink href="/"><HomeIcon /></JoyLink>
                <JoyLink href="/posts">Posts</JoyLink>
                <Typography>Create</Typography>
            </Breadcrumbs>
            
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1">
                Create a New Post
            </Typography>
            
            {error && <Alert color="danger" sx={{ mt: 1 }}>{error}</Alert>}

            <FormControl required sx={{ mt: 1 }}>
                <FormLabel>Title</FormLabel>
                <Input
                    placeholder="Enter a title for your post"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                />
            </FormControl>

            <FormControl required>
                <FormLabel>Content</FormLabel>
                <Textarea
                    placeholder="Write your post content here..."
                    minRows={10}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                />
            </FormControl>
                
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫—É –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π --- */}
            <Button 
                type="submit" 
                loading={loading} 
                sx={{ 
                    mt: 1, 
                    width: { xs: '100%', sm: 'auto' },
                    alignSelf: { xs: 'center', sm: 'flex-start' }
                }}
            >
                Publish Post
            </Button>
        </Box>
    );
}

export default CreatePostPage;
--- END FILE: frontend/src/pages/CreatePostPage.js ---



--- START FILE: frontend/src/pages/CustomPageView.js ---

// frontend/src/pages/CustomPageView.js
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import axios from 'axios';
import { Box, Typography, CircularProgress, Alert, Divider } from '@mui/joy';

function CustomPageView() {
    const { slug } = useParams();
    const [page, setPage] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!slug) return;
        setLoading(true);
        axios.get(`/api/p/${slug}`)
            .then(response => {
                setPage(response.data);
                document.title = `${response.data.title} - FlameWall`;
            })
            .catch(() => {
                setError('Page not found.');
            })
            .finally(() => {
                setLoading(false);
            });

        return () => { document.title = 'FlameWall'; };
    }, [slug]);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
    if (error) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;
    if (!page) return null;

  return (
        <Box>
            <Typography level="h1">{page.title}</Typography>
            <Divider sx={{ my: 2 }} />

            <Box sx={{
                // –°—Ç–∏–ª–∏ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
                '& h1, & h2, & h3, & h4': {
                    fontFamily: 'var(--joy-font-family-display)',
                    color: 'var(--joy-palette-text-primary)',
                    margin: '1.5rem 0 1rem 0',
                    fontWeight: 'var(--joy-font-weight-lg)',
                    lineHeight: 1.3,
                },
                // –°–¢–†–û–ö–ò –° 'fontSize' –î–õ–Ø –ó–ê–ì–û–õ–û–í–ö–û–í –£–î–ê–õ–ï–ù–´
                
                // –°—Ç–∏–ª–∏ –¥–ª—è –ø–∞—Ä–∞–≥—Ä–∞—Ñ–æ–≤ –∏ —Å–ø–∏—Å–∫–æ–≤
                '& p, & li': {
                    fontFamily: 'var(--joy-font-family-body)',
                    // –°–¢–†–û–ö–ê –° 'fontSize' –î–õ–Ø –ü–ê–†–ê–ì–†–ê–§–û–í –£–î–ê–õ–ï–ù–ê
                    color: 'var(--joy-palette-text-secondary)',
                    lineHeight: 1.7,
                    marginBottom: '1rem',
                },

                // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ (–¥–ª—è —Å—Å—ã–ª–æ–∫, –∫–∞—Ä—Ç–∏–Ω–æ–∫ –∏ —Ç.–¥.) –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
            }}>
                <div dangerouslySetInnerHTML={{ __html: page.content }} />
            </Box>
        </Box>
    );
} 

export default CustomPageView;
--- END FILE: frontend/src/pages/CustomPageView.js ---



--- START FILE: frontend/src/pages/EditPostPage.js ---

// frontend/src/pages/EditPostPage.js

import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { 
    Box, 
    Typography, 
    FormControl, 
    FormLabel, 
    Input, 
    Textarea, 
    Button, 
    Alert, 
    CircularProgress,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è —Ö–ª–µ–±–Ω—ã—Ö –∫—Ä–æ—à–µ–∫ ---
    Breadcrumbs,
    Link as JoyLink
} from '@mui/joy';
// --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ ---
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';

function EditPostPage() {
    const { postId } = useParams();
    const navigate = useNavigate();
    const { authToken, user: currentUser } = useAuth();
    
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(true);
    const [isForbidden, setIsForbidden] = useState(false);
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –•—Ä–∞–Ω–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è —Ö–ª–µ–±–Ω—ã—Ö –∫—Ä–æ—à–µ–∫ ---
    const [originalTitle, setOriginalTitle] = useState('');


    useEffect(() => {
        const fetchPost = async () => {
            try {
                const response = await axios.get(`/api/posts/${postId}`, {
                    headers: { Authorization: `Bearer ${authToken}` },
                });
                const post = response.data;

                const isAdmin = currentUser && ['ADMIN', 'MODERATOR', 'OWNER'].includes(currentUser.rank);
                const isAuthor = currentUser?.id === post.author?.id;

                if (!isAuthor && !isAdmin) {
                    setIsForbidden(true);
                    setError('You are not authorized to edit this post.');
                    return;
                }
                
                setTitle(post.title);
                setContent(post.content);
                setOriginalTitle(post.title); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è —Ö–ª–µ–±–Ω—ã—Ö –∫—Ä–æ—à–µ–∫

            } catch (err) {
                setError('Failed to load post data.');
            } finally {
                setLoading(false);
            }
        };

        if (postId && authToken && currentUser) {
            fetchPost();
        }
    }, [postId, authToken, currentUser]);

    const handleSubmit = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');
        try {
            await axios.patch(
                // --- –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º –ø—É—Ç—å –∫ API ---
                `/api/posts/${postId}`,
                { title, content },
                { headers: { Authorization: `Bearer ${authToken}` } }
            );
            navigate(`/posts/${postId}`);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to update post.');
        } finally {
            setLoading(false);
        }
    };

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
    
    if (isForbidden) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;

    return (
        <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö–ª–µ–±–Ω—ã–µ –∫—Ä–æ—à–∫–∏ --- */}
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 1 }}>
                <JoyLink href="/"><HomeIcon /></JoyLink>
                <JoyLink href="/posts">Posts</JoyLink>
                <JoyLink href={`/posts/${postId}`}>{originalTitle || '...'}</JoyLink>
                <Typography>Edit</Typography>
            </Breadcrumbs>

            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ --- */}
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1">Edit Post</Typography>
            
            {error && <Alert color="danger">{error}</Alert>}
            
            <FormControl required sx={{ mt: 1 }}>
                <FormLabel>Title</FormLabel>
                <Input placeholder="Enter a title for your post" value={title} onChange={(e) => setTitle(e.target.value)} />
            </FormControl>

            <FormControl required>
                <FormLabel>Content</FormLabel>
                <Textarea placeholder="Write your post content here..." minRows={10} value={content} onChange={(e) => setContent(e.target.value)} />
            </FormControl>

            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∫–Ω–æ–ø–∫–∞ --- */}
            <Button 
                type="submit" 
                loading={loading} 
                sx={{ 
                    mt: 1,
                    width: { xs: '100%', sm: 'auto' },
                    alignSelf: { xs: 'center', sm: 'flex-start' }
                }}
            >
                Save Changes
            </Button>
        </Box>
    );
}

export default EditPostPage;
--- END FILE: frontend/src/pages/EditPostPage.js ---



--- START FILE: frontend/src/pages/FriendsPage.js ---

// frontend/src/pages/FriendsPage.js

import React, { useState, useEffect, useCallback } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { useNotifications } from '../context/NotificationsContext';
import {
    Typography, CircularProgress, Alert, Box, List, ListItem, ListItemDecorator, ListItemContent, ListItemButton,
    Avatar, IconButton, Tabs, TabList, Tab, TabPanel, Chip, Button,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö—É–∫–∏, –∏–∫–æ–Ω–∫–∏ –∏ –Ω–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã ---
    useTheme, Tooltip, Badge
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import CancelIcon from '@mui/icons-material/Cancel';
import PersonRemoveIcon from '@mui/icons-material/PersonRemove';
import UnsubscribeIcon from '@mui/icons-material/Unsubscribe';
import LockOpenIcon from '@mui/icons-material/LockOpen';
import { constructImageUrl } from '../utils/url';
// --- –ò–ó–ú–ï–ù–ï–ù–û: –ò–∫–æ–Ω–∫–∏ –¥–ª—è –≤–∫–ª–∞–¥–æ–∫ ---
import PeopleIcon from '@mui/icons-material/People';
import MoveToInboxIcon from '@mui/icons-material/MoveToInbox';
import SendIcon from '@mui/icons-material/Send';
import BlockIcon from '@mui/icons-material/Block';


function FriendsPage() {
    const { authToken } = useAuth();
    const { friendshipUpdateTrigger, markNotificationsAsReadByLink } = useNotifications();

    // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ ---
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    const [activeTab, setActiveTab] = useState(0);
    const [friends, setFriends] = useState([]);
    const [pendingRequests, setPendingRequests] = useState([]);
    const [outgoingRequests, setOutgoingRequests] = useState([]);
    const [blockedUsers, setBlockedUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchData = useCallback(async () => {
        // ... (–ª–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
        if (!authToken) return;
        setLoading(true);
        setError(null);
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            const [friendsRes, pendingRes, outgoingRes, blockedRes] = await Promise.all([
                axios.get(`/api/friendships`, config),
                axios.get(`/api/friendships/requests/pending`, config),
                axios.get(`/api/friendships/requests/outgoing`, config),
                axios.get(`/api/friendships/blocked`, config),
            ]);
            setFriends(friendsRes.data);
            setPendingRequests(pendingRes.data);
            setOutgoingRequests(outgoingRes.data);
            setBlockedUsers(blockedRes.data);
        } catch (err) {
            setError('Failed to load friends data.');
            console.error('Error fetching friends data:', err);
        } finally {
            setLoading(false);
        }
    }, [authToken]);

    useEffect(() => {
        fetchData();
    }, [fetchData, friendshipUpdateTrigger]);

    useEffect(() => {
        if (activeTab === 1) {
            markNotificationsAsReadByLink('/friends');
        }
    }, [activeTab, friendshipUpdateTrigger, markNotificationsAsReadByLink]);

    const handleRequestAction = async (action, requestId) => {
        // ... (–ª–æ–≥–∏–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            if (action === 'accept') {
                await axios.patch(`/api/friendships/requests/${requestId}/accept`, {}, config);
            } else if (action === 'reject' || action === 'cancel') {
                await axios.delete(`/api/friendships/requests/${requestId}`, config);
            }
            fetchData();
        } catch (err) { console.error(`Failed to ${action} request:`, err); }
    };

    const handleRemoveFriend = async (friendshipId) => {
        // ... (–ª–æ–≥–∏–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
        try {
            await axios.delete(`/api/friendships/${friendshipId}`, { headers: { Authorization: `Bearer ${authToken}` } });
            fetchData();
        } catch (err) { console.error('Failed to remove friend:', err); }
    };

    const handleUnblock = async (userIdToUnblock) => {
        // ... (–ª–æ–≥–∏–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
        try {
            await axios.delete(`/api/friendships/block/${userIdToUnblock}`, { headers: { Authorization: `Bearer ${authToken}` } });
            fetchData();
        } catch(err) { console.error('Failed to unblock user:', err); }
    };

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;

    const renderListItem = (user, endAction, subtext = null) => (
        <ListItem key={user.id || user.friendshipId} endAction={endAction}>
            <ListItemButton component={RouterLink} to={`/users/${user.profile_slug || user.id}`}>
                <ListItemDecorator>
                    <Avatar src={constructImageUrl(user.pfp_url)} />
                </ListItemDecorator>
                <ListItemContent>
                    <Typography>{user.username}</Typography>
                    {subtext && <Typography level="body-xs">{subtext}</Typography>}
                </ListItemContent>
            </ListItemButton>
        </ListItem>
    );

    return (
        <Box>
            <Typography level={{xs: 'h2', sm: 'h1'}} component="h1" sx={{ mb: 3 }}>Manage Friendships</Typography>
            <Tabs 
                aria-label="Friendship management tabs" 
                value={activeTab}
                onChange={(event, newValue) => setActiveTab(newValue)}
                // --- –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ–Ω—å—à–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö ---
                sx={{ p: { xs: 0, sm: 1 } }}
            >
                <TabList variant="plain">
                    <Tab>{isMobile ? <PeopleIcon /> : `Friends (${friends.length})`}</Tab>
                    <Tab>
                        {isMobile ? (
                            <Badge badgeContent={pendingRequests.length} color="danger" size="sm">
                                <MoveToInboxIcon />
                            </Badge>
                        ) : (
                            <div>
                                Incoming Requests
                                {pendingRequests.length > 0 && <Chip size="sm" color="danger" sx={{ ml: 1 }}>{pendingRequests.length}</Chip>}
                            </div>
                        )}
                    </Tab>
                    <Tab>{isMobile ? <SendIcon /> : `Outgoing Requests (${outgoingRequests.length})`}</Tab>
                    <Tab>{isMobile ? <BlockIcon /> : `Blocked (${blockedUsers.length})`}</Tab>
                </TabList>

                <TabPanel value={0}> {/* Friends */}
                    <List>{friends.length > 0 ? friends.map(item => renderListItem(item.user, 
                        <Tooltip title="Remove Friend" variant="outlined" size="sm">
                            <IconButton variant="plain" color="danger" onClick={() => handleRemoveFriend(item.friendshipId)}>
                                <PersonRemoveIcon />
                            </IconButton>
                        </Tooltip>
                    )) : <Typography sx={{mt: 2}}>Your friends list is empty.</Typography>}</List>
                </TabPanel>

                <TabPanel value={1}> {/* Incoming Requests */}
                    <List>{pendingRequests.length > 0 ? pendingRequests.map(req => renderListItem(req.requester, 
                        <Box sx={{ display: 'flex', gap: 1 }}>
                            <Tooltip title="Accept" variant="outlined" size="sm">
                                <IconButton variant="solid" color="success" onClick={() => handleRequestAction('accept', req.id)}>
                                    <CheckCircleIcon />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Reject" variant="outlined" size="sm">
                                <IconButton variant="solid" color="danger" onClick={() => handleRequestAction('reject', req.id)}>
                                    <CancelIcon />
                                </IconButton>
                            </Tooltip>
                        </Box>,
                        "Wants to be your friend"
                    )) : <Typography sx={{mt: 2}}>No pending friend requests.</Typography>}</List>
                </TabPanel>
                
                <TabPanel value={2}> {/* Outgoing Requests */}
                    <List>{outgoingRequests.length > 0 ? outgoingRequests.map(req => renderListItem(req.receiver, 
                        isMobile ? (
                            <Tooltip title="Cancel Request" variant="outlined" size="sm">
                                <IconButton variant="plain" color="neutral" size="sm" onClick={() => handleRequestAction('cancel', req.id)}><UnsubscribeIcon /></IconButton>
                            </Tooltip>
                        ) : (
                            <Button variant="outlined" color="neutral" size="sm" startDecorator={<UnsubscribeIcon />} onClick={() => handleRequestAction('cancel', req.id)}>Cancel</Button>
                        ),
                        "Request sent"
                    )) : <Typography sx={{mt: 2}}>You have no outgoing friend requests.</Typography>}</List>
                </TabPanel>

                <TabPanel value={3}> {/* Blocked Users */}
                    <List>{blockedUsers.length > 0 ? blockedUsers.map(item => renderListItem(item.receiver,
                         isMobile ? (
                            <Tooltip title="Unblock" variant="outlined" size="sm">
                                <IconButton variant="soft" color="warning" size="sm" onClick={() => handleUnblock(item.receiver.id)}><LockOpenIcon /></IconButton>
                            </Tooltip>
                        ) : (
                            <Button variant="soft" color="warning" size="sm" startDecorator={<LockOpenIcon />} onClick={() => handleUnblock(item.receiver.id)}>Unblock</Button>
                        )
                    )) : <Typography sx={{mt: 2}}>You have not blocked any users.</Typography>}</List>
                </TabPanel>
            </Tabs>
        </Box>
    );
}

export default FriendsPage;
--- END FILE: frontend/src/pages/FriendsPage.js ---



--- START FILE: frontend/src/pages/LandingPage.js ---

// frontend/src/pages/LandingPage.js

import React from 'react';
import { Box, Button, Typography, Sheet, Grid, Card, CardContent, Link as JoyLink } from '@mui/joy';
import { Link as RouterLink } from 'react-router-dom';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import GroupsIcon from '@mui/icons-material/Groups';
import ChatIcon from '@mui/icons-material/Chat';
import ExtensionIcon from '@mui/icons-material/Extension';

// This component doesn't need translation, it's universal
const FeatureCard = ({ icon, title, description }) => (
  <Card variant="outlined" sx={{ height: '100%', borderColor: 'background.level2' }}>
    <CardContent sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', textAlign: 'center' }}>
      <Sheet variant="soft" sx={{ borderRadius: '50%', p: 2, mb: 2 }}>
        {icon}
      </Sheet>
      <Typography level="title-lg" component="h3" sx={{ mb: 1 }}>{title}</Typography>
      <Typography level="body-md">{description}</Typography>
    </CardContent>
  </Card>
);

function LandingPage() {
  return (
    <Box sx={{ px: { xs: 2, md: 4 } }}>

      {/* --- 1. HERO SECTION --- */}
      <Box
        sx={{
          minHeight: { xs: '70vh', md: '80vh' },
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          textAlign: 'center',
          py: 4,
        }}
      >
        <Typography
          level="h1"
          component="h1"
          sx={{
            fontSize: { xs: '3rem', sm: '4rem', md: '5rem' },
            fontWeight: 'xl',
            mb: 2,
            background: 'linear-gradient(45deg, #FF8E53 30%, #FE6B8B 90%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
          }}
        >
          FlameWall
        </Typography>
        <Typography level="h4" component="p" sx={{ mb: 4, maxWidth: '600px', color: 'text.secondary' }}>
          Your ultimate gaming community. Chat with friends, share moments, and always stay connected with the server.
        </Typography>
        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', justifyContent: 'center' }}>
          <Button
            component={RouterLink}
            to="/register"
            size="lg"
            endDecorator={<ArrowForwardIcon />}
            sx={{ boxShadow: 'md' }}
          >
            Join Now
          </Button>
          <Button
            component={RouterLink}
            to="/posts"
            size="lg"
            variant="outlined"
            color="neutral"
          >
            Explore Posts
          </Button>
        </Box>
      </Box>

      {/* --- 2. FEATURES SECTION --- */}
      <Box sx={{ py: { xs: 4, md: 8 } }}>
        <Typography level="h2" component="h2" sx={{ textAlign: 'center', mb: 4 }}>
          Everything You Need to Play
        </Typography>
        <Grid container spacing={4} sx={{ flexGrow: 1 }}>
          <Grid xs={12} md={4}>
            <FeatureCard
              icon={<GroupsIcon sx={{ fontSize: 40 }} color="primary" />}
              title="Unified Community"
              description="Create posts, comment, and cast your vote. Stay at the center of your server's community."
            />
          </Grid>
          <Grid xs={12} md={4}>
            <FeatureCard
              icon={<ChatIcon sx={{ fontSize: 40 }} color="success" />}
              title="Integrated Chat"
              description="Chat with friends in private messages both on the website and directly from in-game."
            />
          </Grid>
          <Grid xs={12} md={4}>
            <FeatureCard
              icon={<ExtensionIcon sx={{ fontSize: 40 }} color="warning" />}
              title="Minecraft Integration"
              description="Link your game account to sync your friends and online status, and chat without boundaries."
            />
          </Grid>
        </Grid>
      </Box>

      {/* --- 3. FINAL CALL TO ACTION (CTA) --- */}
      <Sheet variant="soft" sx={{ my: { xs: 4, md: 8 }, p: 4, borderRadius: 'md', textAlign: 'center' }}>
        <Typography level="h2" component="h2" sx={{ mb: 1 }}>Ready to get started?</Typography>
        <Typography sx={{ mb: 3, color: 'text.secondary' }}>
          Create an account in a minute and become a part of our community.
        </Typography>
        <Button component={RouterLink} to="/register" size="lg" sx={{ boxShadow: 'md' }}>
          Sign Up for Free
        </Button>
      </Sheet>

      {/* --- 4. FOOTER --- */}
      <Box component="footer" sx={{ py: 3, textAlign: 'center' }}>
        <Typography level="body-sm">
          ¬© {new Date().getFullYear()} FlameWall. All rights reserved.
        </Typography>
        <Typography level="body-xs" sx={{ mt: 0.5 }}>
          Crafted with ‚ù§Ô∏è and by <JoyLink component={RouterLink} to="/profile/me">you</JoyLink>.
        </Typography>
      </Box>

    </Box>
  );
}

export default LandingPage;
--- END FILE: frontend/src/pages/LandingPage.js ---



--- START FILE: frontend/src/pages/LinkMinecraftPage.js ---

// frontend/src/pages/LinkMinecraftPage.js

import React, { useState } from 'react';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import toast from 'react-hot-toast'; // <-- –£–±–µ–¥–∏—Å—å, —á—Ç–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
import {
    Box, Typography, Sheet, Button, CircularProgress, Alert, Input, Link as JoyLink, Breadcrumbs,
    useTheme, IconButton,
    // --- –ù–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ ---
    Modal, ModalDialog, ModalClose, Divider, Stack
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import LinkIcon from '@mui/icons-material/Link';
import LinkOffIcon from '@mui/icons-material/LinkOff'; // <-- –ò–∫–æ–Ω–∫–∞ –¥–ª—è –æ—Ç–≤—è–∑–∫–∏
import HomeIcon from '@mui/icons-material/Home';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';

function LinkMinecraftPage() {
    const { user, authToken, updateAuthToken } = useAuth(); // <-- –î–æ—Å—Ç–∞–µ–º authToken –∏ updateAuthToken
    const [code, setCode] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [copied, setCopied] = useState(false);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
    
    // --- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ ---
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [isUnlinking, setIsUnlinking] = useState(false);

    const handleGenerateCode = async () => {
        setLoading(true);
        setError('');
        try {
            const response = await axios.post('/api/linking/generate-code');
            setCode(response.data.code);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to generate code.');
        } finally {
            setLoading(false);
        }
    };

    const handleCopy = () => {
        const command = `/link ${code}`;
        navigator.clipboard.writeText(command);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    // --- –õ–æ–≥–∏–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –æ—Ç–≤—è–∑–∫–∏ ---
    const handleUnlink = async () => {
        setIsUnlinking(true);
        try {
            const response = await axios.post(
                '/api/users/me/unlink-minecraft',
                {}, // –ü—É—Å—Ç–æ–µ —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞
                { headers: { Authorization: `Bearer ${authToken}` } }
            );
            updateAuthToken(response.data.access_token);
            toast.success('Minecraft account unlinked successfully!');
            setIsModalOpen(false); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
        } catch (err) {
            toast.error(err.response?.data?.message || 'Failed to unlink account.');
        } finally {
            setIsUnlinking(false);
        }
    };

    if (user && user.minecraft_username) {
        return (
            <Box>
                <Typography level={{xs: 'h2', sm: 'h1'}} component="h1" sx={{ mb: 2 }}>Minecraft Account</Typography>
                <Sheet variant="soft" color="success" sx={{ p: {xs: 2, sm: 3}, borderRadius: 'md', textAlign: 'center' }}>
                    <CheckCircleIcon color="success" sx={{ fontSize: 'xl4', mb: 1 }}/>
                    <Typography level="title-lg">Account Linked!</Typography>
                    <Typography>Your website account is linked to the Minecraft account: <strong>{user.minecraft_username}</strong></Typography>
                    
                    {/* --- –ö–Ω–æ–ø–∫–∞ –¥–ª—è –æ—Ç–≤—è–∑–∫–∏ --- */}
                    <Button 
                        variant="outlined" 
                        color="danger" 
                        startDecorator={<LinkOffIcon />} 
                        onClick={() => setIsModalOpen(true)}
                        sx={{ mt: 2 }}
                    >
                        Unlink Account
                    </Button>
                </Sheet>

                {/* --- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è --- */}
                <Modal open={isModalOpen} onClose={() => setIsModalOpen(false)}>
                    <ModalDialog variant="outlined" role="alertdialog">
                        <ModalClose />
                        <Typography level="h4" component="h2">Confirm Unlink</Typography>
                        <Divider sx={{ my: 2 }} />
                        <Typography>Are you sure you want to unlink your Minecraft account? You will need to generate a new code to link it again.</Typography>
                        <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end', mt: 3 }}>
                            <Button variant="plain" color="neutral" onClick={() => setIsModalOpen(false)}>
                                Cancel
                            </Button>
                            <Button variant="solid" color="danger" loading={isUnlinking} onClick={handleUnlink}>
                                Unlink
                            </Button>
                        </Box>
                    </ModalDialog>
                </Modal>
            </Box>
        );
    }

    // ... (–æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å JSX –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    return (
        <Box>
            <Breadcrumbs separator={<ChevronRightIcon />} sx={{ mb: 2 }}>
                <JoyLink href="/"><HomeIcon /></JoyLink>
                <JoyLink href="/profile/settings">Settings</JoyLink>
                <Typography>Link Minecraft Account</Typography>
            </Breadcrumbs>
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1" sx={{ mb: 1 }}>Link your Minecraft Account</Typography>
            <Typography sx={{ mb: 3 }}>
                Link your website profile to your in-game account to sync your status, friends, and more.
            </Typography>
            {error && <Alert color="danger" sx={{ mb: 2 }}>{error}</Alert>}
            <Sheet variant="outlined" sx={{ p: { xs: 2, sm: 3 }, borderRadius: 'md', display: 'flex', justifyContent: 'center' }}>
                {code ? (
                     <Box sx={{ textAlign: 'center', width: '100%', maxWidth: '500px' }}>
                        <Typography level="body-md">1. Log in to our Minecraft server.</Typography>
                        <Typography level="body-md" sx={{mb: 2}}>2. Type this command in the in-game chat:</Typography>
                        <Input
                            readOnly
                            value={`/link ${code}`}
                            endDecorator={
                                isMobile ? (
                                    <IconButton onClick={handleCopy} variant="soft" color="primary">
                                        {copied ? <CheckCircleIcon /> : <ContentCopyIcon />}
                                     </IconButton>
                                ) : (
                                    <Button onClick={handleCopy} variant="soft" startDecorator={copied ? <CheckCircleIcon /> : <ContentCopyIcon />}>
                                        {copied ? 'Copied!' : 'Copy'}
                                    </Button>
                             )
                            }
                            sx={{ '--Input-decoratorChildHeight': '32px', fontSize: 'lg', fontFamily: 'monospace' }}
                        />
                         <Typography level="body-xs" sx={{mt: 1}}>This code will expire in 5 minutes.</Typography>
                    </Box>
                ) : (
                    <Button
                        size="lg"
                        startDecorator={<LinkIcon />}
                        loading={loading}
                        onClick={handleGenerateCode}
                    >
                        Generate one-time code
                    </Button>
                )}
            </Sheet>
        </Box>
    );
}

export default LinkMinecraftPage;
--- END FILE: frontend/src/pages/LinkMinecraftPage.js ---



--- START FILE: frontend/src/pages/LoginPage.js ---

// frontend/src/pages/LoginPage.js

import React, { useState, useEffect } from 'react';
import { useNavigate, NavLink, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import {
    Sheet,
    Typography,
    FormControl,
    FormLabel,
    Input,
    Button,
    Link,
    Alert,
    Stack,
    Box, // <-- –î–æ–±–∞–≤–ª—è–µ–º Box
    Link as JoyLink // <-- –î–æ–±–∞–≤–ª—è–µ–º JoyLink
} from '@mui/joy';
import { useAuth } from '../context/AuthContext';
import AdbIcon from '@mui/icons-material/Adb'; // <-- –ò–∫–æ–Ω–∫–∞ –¥–ª—è –ª–æ–≥–æ—Ç–∏–ø–∞

function LoginPage() {
    const navigate = useNavigate();
    const { login, isLoggedIn } = useAuth();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (isLoggedIn) {
            navigate('/');
        }
    }, [isLoggedIn, navigate]);

    const handleLogin = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');
        try {
            const response = await axios.post(`/api/auth/login`, { email, password });
            login(response.data.access_token);
        } catch (err) {
            setError(err.response?.data?.message || 'Login failed. Please check your credentials.');
            setLoading(false);
        }
    };

    return (
        <Sheet sx={{
            display: 'flex',
            flexFlow: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            minHeight: '100dvh',
            p: 2,
        }}>
            <Sheet
                sx={{
                    width: '100%',
                    maxWidth: '400px',
                    mx: 'auto',
                    py: { xs: 2, sm: 3 },
                    px: { xs: 2, sm: 4 },
                    display: 'flex',
                    flexDirection: 'column',
                    gap: 2,
                    borderRadius: 'sm',
                    boxShadow: 'md'
                }}
                variant="outlined"
            >
                {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ1: –ö–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–π –ª–æ–≥–æ—Ç–∏–ø –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ --- */}
                <Box sx={{ display: 'flex', justifyContent: 'center', mb: 1 }}>
                    <JoyLink component={RouterLink} to="/" sx={{ textDecoration: 'none' }}>
                        <Box sx={{
                            flexGrow: 1,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: 1
                        }}>
                            <img src="/logo.png" alt="FlameWall Logo" style={{ width: '40px', height: '40px' }} />
                            <Typography fontWeight="lg" level="h2" component="div">FlameWall</Typography>
                        </Box>
                    </JoyLink>
                </Box>

                <div>
                    <Typography level="h4" component="h1"><b>Welcome back!</b></Typography>
                    <Typography level="body-sm">Sign in to continue.</Typography>
                </div>

                {error && <Alert color="danger">{error}</Alert>}

                <form onSubmit={handleLogin}>
                    <Stack spacing={2}>
                        <FormControl required>
                            <FormLabel>Email</FormLabel>
                            {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ2: –ê—Ç—Ä–∏–±—É—Ç autoComplete --- */}
                            <Input type="email" name="email" value={email} onChange={(e) => setEmail(e.target.value)} disabled={loading} autoComplete="email" />
                        </FormControl>
                        <FormControl required>
                            <FormLabel>Password</FormLabel>
                            {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ2: –ê—Ç—Ä–∏–±—É—Ç autoComplete --- */}
                            <Input type="password" name="password" value={password} onChange={(e) => setPassword(e.target.value)} disabled={loading} autoComplete="current-password" />
                        </FormControl>
                        <Button type="submit" loading={loading} fullWidth>Log in</Button>
                    </Stack>
                </form>

                <Typography endDecorator={<Link component={NavLink} to="/register">Sign up</Link>} fontSize="sm" sx={{ alignSelf: 'center' }}>
                    Don&apos;t have an account?
                </Typography>
            </Sheet>
        </Sheet>
    );
}

export default LoginPage;
--- END FILE: frontend/src/pages/LoginPage.js ---



--- START FILE: frontend/src/pages/MessagesPage.js ---

// frontend/src/pages/MessagesPage.js

import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Typography,
    CircularProgress,
    Alert,
    Box,
    List,
    ListItem,
    ListItemDecorator,
    ListItemContent,
    ListItemButton,
    Avatar,
    Stack,
} from '@mui/joy';
import { constructImageUrl } from '../utils/url';
import CircleIcon from '@mui/icons-material/Circle';

function MessagesPage() {
    const { authToken, socket } = useAuth();
    const [friends, setFriends] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!authToken) return;

        const fetchFriends = async () => {
            try {
                const config = { headers: { Authorization: `Bearer ${authToken}` } };
                // --- –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º –ø—É—Ç—å –∫ API ---
                const response = await axios.get(`/api/friendships`, config);
                setFriends(response.data);
            } catch (err) {
                setError('Failed to load contacts.');
            } finally {
                setLoading(false);
            }
        };
        fetchFriends();
    }, [authToken]);

    useEffect(() => {
        if (!socket) return;

        const handleStatusUpdate = (data) => {
            setFriends(prevFriends =>
                prevFriends.map(friend =>
                    friend.user.id === data.userId
                        ? { ...friend, user: { ...friend.user, is_minecraft_online: data.is_minecraft_online } }
                        : friend
                )
            );
        };

        socket.on('userStatusUpdate', handleStatusUpdate);

        return () => {
            socket.off('userStatusUpdate', handleStatusUpdate);
        };
    }, [socket]);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;

    return (
        <Box>
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –î–µ–ª–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1" sx={{ mb: 3 }}>Messages</Typography>
            <Typography level="body-lg" sx={{ mb: 2 }}>Select a friend to start a conversation.</Typography>
            <List variant="outlined" sx={{ borderRadius: 'sm', p: 0 }}>
                {friends.length > 0 ? (
                    friends.map(item => (
                        <ListItem key={item.friendshipId}>
                            <ListItemButton component={RouterLink} to={`/messages/${item.user.id}`} sx={{ p: 1.5 }}>
                                <ListItemDecorator>
                                    <Avatar src={constructImageUrl(item.user.pfp_url)} />
                                </ListItemDecorator>
                                <ListItemContent>
                                    <Stack>
                                        <Typography sx={{ color: item.user.rank?.display_color }}>
                                            {item.user.username}
                                        </Typography>                                        
                                        {item.user.minecraft_username && (
                                            <Typography
                                                level="body-xs"
                                                startDecorator={<CircleIcon sx={{ fontSize: '8px' }} />}
                                                sx={{ color: item.user.is_minecraft_online ? 'success.400' : 'text.tertiary' }}
                                            >
                                                {item.user.is_minecraft_online ? 'Online' : 'Offline'}
                                            </Typography>
                                        )}
                                    </Stack>
                                </ListItemContent>
                            </ListItemButton>
                        </ListItem>
                    ))
                ) : (
                    <Typography sx={{ p: 2 }}>You need to add friends to start a conversation.</Typography>
                )}
            </List>
        </Box>
    );
}

export default MessagesPage;
--- END FILE: frontend/src/pages/MessagesPage.js ---



--- START FILE: frontend/src/pages/MyProfilePage.js ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import {
    Box, Typography, Sheet, Avatar, CircularProgress, Alert, Divider, Button, Chip, Stack,
    useTheme,
    Grid, AspectRatio
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import AddIcon from '@mui/icons-material/Add';
import { Link as RouterLink } from 'react-router-dom';
import ThumbUpOffAltIcon from '@mui/icons-material/ThumbUpOffAlt';
import { constructImageUrl } from '../utils/url';
import CircleIcon from '@mui/icons-material/Circle';

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞
function isColorLight(hexColor) {
    if (!hexColor) return false;
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155;
}

function MyProfilePage() {
    const { user: profile, loading: authLoading, error: authError, socket, updateAuthToken } = useAuth();
    const [error, setError] = useState(authError);
    const loading = authLoading;
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    useEffect(() => {
        if (!socket) return;
        const handleStatusUpdate = (data) => {
            if (profile && data.userId === profile.id) {
                const newToken = localStorage.getItem('authToken');
                if (newToken) {
                    updateAuthToken(newToken);
                }
            }
        };
        socket.on('userStatusUpdate', handleStatusUpdate);
        return () => {
            socket.off('userStatusUpdate', handleStatusUpdate);
        };
    }, [socket, profile, updateAuthToken]);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;
    if (!profile) return <Typography>Could not load profile.</Typography>;

    return (
        <Box>
            {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –û—Ç—Å—Ç—É–ø—ã (p) —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ –≥–ª–∞–≤–Ω–æ–º—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É --- */}
            <Sheet variant="outlined" sx={{ borderRadius: 'md', p: { xs: 2, sm: 3, md: 4 } }}>

                {/* –ë–∞–Ω–Ω–µ—Ä —Ç–µ–ø–µ—Ä—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å –æ—Ç—Å—Ç—É–ø–∞–º–∏ */}
                <Box sx={{ position: 'relative' }}>
                    <AspectRatio ratio="16/5" sx={{ width: '100%', borderRadius: 'sm', bgcolor: 'background.level1' }}>
                        {profile.banner_url ? (
                            <img
                                src={constructImageUrl(profile.banner_url)}
                                alt={`${profile.username}'s banner`}
                                style={{ objectFit: 'cover' }}
                            />
                        ) : (
                            <Box sx={{ background: 'linear-gradient(180deg, var(--joy-palette-neutral-700), var(--joy-palette-neutral-800))' }} />
                        )}
                    </AspectRatio>
                    <Box
                        sx={{
                            position: 'absolute', bottom: 0, left: 0, right: 0, height: '20%',
                            background: 'linear-gradient(to top, var(--joy-palette-background-level1), transparent)',
                        }}
                    />
                </Box>

                {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –í—Å—è —à–∞–ø–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–¥–Ω–∏–º–∞–µ—Ç—Å—è –Ω–∞–≤–µ—Ä—Ö --- */}
                <Box sx={{
                    display: 'flex',
                    flexDirection: { xs: 'column', sm: 'row' },
                    alignItems: { xs: 'center', sm: 'flex-end' },
                    gap: 3,
                    mt: { xs: -4, sm: -6 }, // –ü—Ä–∏–ø–æ–¥–Ω–∏–º–∞–µ–º –≤–µ—Å—å –±–ª–æ–∫
                    position: 'relative', // –î–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –Ω–∞–ª–æ–∂–µ–Ω–∏—è
                    paddingLeft: 4,
                    paddingRight: 4
                }}>
                    <Avatar
                        src={constructImageUrl(profile.pfp_url)}
                        sx={{
                            '--Avatar-size': { xs: '80px', sm: '128px' },
                            border: '2px solid',
                            borderColor: 'background.body', // –†–∞–º–∫–∞ –≤ —Ü–≤–µ—Ç —Ñ–æ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                            boxShadow: 'sm',
                            mx: { xs: 'auto', sm: 0 },
                        }}
                    />
                    <Box sx={{ textAlign: { xs: 'center', sm: 'left' }, flexGrow: 1 }}>
                        <Typography level="h2" component="h1">{profile.username}</Typography>
                        {profile.profile_slug && (<Typography level="body-md" textColor="text.tertiary">@{profile.profile_slug}</Typography>)}

                        <Stack direction="row" spacing={1} sx={{ mt: 0.5, justifyContent: { xs: 'center', sm: 'flex-start' }, flexWrap: 'wrap', gap: 1 }}>
                            {profile.rank && <Chip sx={{ backgroundColor: profile.rank.display_color, color: isColorLight(profile.rank.display_color) ? '#000' : '#FFF' }}>{profile.rank.name}</Chip>}
                            <Chip color="neutral" variant="outlined" startDecorator={<ThumbUpOffAltIcon />}>Reputation: {profile.reputation_count}</Chip>
                            {profile.minecraft_username && <Chip variant="soft" color={profile.is_minecraft_online ? 'success' : 'neutral'} startDecorator={<CircleIcon sx={{ fontSize: '10px' }} />}>{profile.minecraft_username} ({profile.is_minecraft_online ? 'Online' : 'Offline'})</Chip>}
                        </Stack>
                    </Box>

                    <Stack
                        direction="row"
                        spacing={1}
                        sx={{
                            width: { xs: '100%', sm: 'auto' },
                            flexShrink: 0
                        }}
                    >
                        <Button component={RouterLink} to="/posts/new" variant="solid" color="primary" startDecorator={<AddIcon />} sx={{ flexGrow: 1 }}>
                            New Post
                        </Button>
                        <Button component={RouterLink} to="/profile/settings" variant="outlined" color="neutral" startDecorator={<EditIcon />} sx={{ flexGrow: 1 }}>
                            Edit Profile
                        </Button>
                    </Stack>
                </Box>

                <Divider sx={{ my: 3 }} />

                <Typography level="body-lg" sx={{ whiteSpace: 'pre-wrap' }}>
                    {profile.description || 'No description provided.'}
                </Typography>
            </Sheet>
        </Box>
    );
}

export default MyProfilePage;
--- END FILE: frontend/src/pages/MyProfilePage.js ---



--- START FILE: frontend/src/pages/NewsPage.js ---

// frontend/src/pages/NewsPage.js

import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Typography, List, ListItem, CircularProgress, Alert, Box, Sheet, Divider, Button,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö—É–∫–∏ –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ ---
    useTheme
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import PersonIcon from '@mui/icons-material/Person';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import AddIcon from '@mui/icons-material/Add';

function NewsPage() {
    const [news, setNews] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const { user: currentUser } = useAuth();
    const isAdmin = currentUser && ['ADMIN', 'MODERATOR', 'OWNER'].includes(currentUser.rank);
    
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ ---
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    useEffect(() => {
        const fetchNews = async () => {
            try {
                setLoading(true);
                setError(null);
                const response = await axios.get('/api/news');
                setNews(response.data);
            } catch (err) {
                setError('Failed to load news. The server might be down.');
                console.error('Error fetching news:', err);
            } finally {
                setLoading(false);
            }
        };
        fetchNews();
    }, []);

    if (loading) {
        return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    }

    if (error) {
        return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;
    }

    return (
        <Box>
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç–∞–ª –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º --- */}
            <Box sx={{ 
                display: 'flex', 
                flexDirection: { xs: 'column', sm: 'row' },
                justifyContent: 'space-between', 
                alignItems: { xs: 'flex-start', sm: 'center' }, 
                mb: 2,
                gap: 2
            }}>
                <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1">
                    Server News
                </Typography>
                
                {isAdmin && (
                    <Button 
                        component={RouterLink} 
                        to="/admin/news/create" 
                        startDecorator={<AddIcon />}
                        // --- –ò–ó–ú–ï–ù–ï–ù–û: –ö–Ω–æ–ø–∫–∞ —Å—Ç–∞–ª–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π ---
                        sx={{ width: { xs: '100%', sm: 'auto' } }}
                    >
                        Create News
                    </Button>
                )}
            </Box>

            <List variant="outlined" sx={{ borderRadius: 'sm', bgcolor: 'background.body', p: 0 }}>
                {news.length > 0 ? (
                    news.map((article, index) => (
                        <React.Fragment key={article.id}>
                            <ListItem>
                                <Sheet sx={{ p: {xs: 1.5, sm: 2}, flexGrow: 1, bgcolor: 'transparent' }}>
                                    <Typography level="title-lg" component="h2" gutterBottom>
                                        {article.name}
                                    </Typography>
                                    <Typography level="body-md" sx={{ mb: 2, whiteSpace: 'pre-wrap' }}>
                                        {article.desc}
                                    </Typography>
                                    {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å—Ç–∞–ª–∏ –±–æ–ª–µ–µ "–≥–∏–±–∫–∏–º–∏" --- */}
                                    <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', alignItems: 'center', color: 'text.tertiary' }}>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                            <PersonIcon fontSize="sm" />
                                            <Typography level="body-sm">
                                                {article.author ? article.author.username : 'System'}
                                            </Typography>
                                        </Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                            <CalendarTodayIcon fontSize="sm" />
                                            <Typography level="body-sm">
                                                {new Date(article.created_at).toLocaleDateString()}
                                            </Typography>
                                        </Box>
                                    </Box>
                                </Sheet>
                            </ListItem>
                            {index < news.length - 1 && <Divider component="li" />}
                        </React.Fragment>
                    ))
                ) : (
                    <ListItem>
                        <Typography sx={{ p: 2 }}>No news articles found.</Typography>
                    </ListItem>
                )}
            </List>
        </Box>
    );
}

export default NewsPage;
--- END FILE: frontend/src/pages/NewsPage.js ---



--- START FILE: frontend/src/pages/PlayersPage.js ---

import React, { useState, useEffect, useCallback } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import {
    Typography, CircularProgress, Alert, Box, Grid, Card, CardContent, Avatar, Chip, AspectRatio,
    FormControl, FormLabel, Select, Option, Stack,
} from '@mui/joy';
import { constructImageUrl } from '../utils/url';
import { useAuth } from '../context/AuthContext';
import CircleIcon from '@mui/icons-material/Circle';
import JoyPagination from '../components/JoyPagination';

// --- –î–û–ë–ê–í–õ–ï–ù–û: –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ü–≤–µ—Ç–∞ ---
function isColorLight(hexColor) {
    if (!hexColor) return false;
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155;
}


function PlayersPage() {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [sortBy, setSortBy] = useState('first_login');
    const [order, setOrder] = useState('DESC');
    const { socket } = useAuth();

    const [page, setPage] = useState(1);
    const [limit, setLimit] = useState(12); // 12 –∫–∞—Ä—Ç–æ—á–µ–∫ —Ö–æ—Ä–æ—à–æ —Å–º–æ—Ç—Ä—è—Ç—Å—è –≤ —Å–µ—Ç–∫–µ
    const [totalPages, setTotalPages] = useState(0);

    const fetchUsers = useCallback(async () => {
        try {
            setError(null);
            setLoading(true); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –≤ –Ω–∞—á–∞–ª–µ
            // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º page –∏ limit –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞ ---
            const response = await axios.get(`/api/users`, { params: { sortBy, order, page, limit } });

            // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ ---
            setUsers(response.data.data);
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü
            setTotalPages(Math.ceil(response.data.total / limit));

        } catch (err) {
            setError('Failed to load players list.');
        } finally {
            setLoading(false);
        }
        // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º page –∏ limit –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ ---
    }, [sortBy, order, page, limit]);

    useEffect(() => { setLoading(true); fetchUsers(); }, [fetchUsers]);

    useEffect(() => {
        if (!socket) return;
        const handleStatusUpdate = (data) => {
            setUsers(prevUsers =>
                prevUsers.map(user =>
                    user.id === data.userId
                        ? { ...user, is_minecraft_online: data.is_minecraft_online }
                        : user
                )
            );
        };
        socket.on('userStatusUpdate', handleStatusUpdate);
        return () => { socket.off('userStatusUpdate', handleStatusUpdate); };
    }, [socket]);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;

    return (
        <Box>
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1" sx={{ mb: 3 }}>Community Players</Typography>

            <Stack
                direction={{ xs: 'column', sm: 'row' }}
                spacing={2}
                sx={{ mb: 3, alignItems: { xs: 'stretch', sm: 'flex-end' } }}
            >
                <FormControl size="sm">
                    <FormLabel>Sort by</FormLabel>
                    <Select value={sortBy} onChange={(e, newValue) => setSortBy(newValue)}>
                        <Option value="first_login">Join Date</Option>
                        <Option value="reputation_count">Reputation</Option>
                        <Option value="username">Username</Option>
                    </Select>
                </FormControl>
                <FormControl size="sm">
                    <FormLabel>Order</FormLabel>
                    <Select value={order} onChange={(e, newValue) => setOrder(newValue)}>
                        <Option value="DESC">Descending</Option>
                        <Option value="ASC">Ascending</Option>
                    </Select>
                </FormControl>
            </Stack>
            {!loading && totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
            <Grid container spacing={2} sx={{ flexGrow: 1 }}>
                {users.map((user) => (
                    <Grid xs={6} sm={6} md={4} key={user.id}>
                        <Card
                            variant="outlined"
                            component={RouterLink}
                            to={`/users/${user.profile_slug || user.id}`}
                            sx={{ textDecoration: 'none', height: '100%', transition: 'transform 0.2s, box-shadow 0.2s', '&:hover': { transform: 'translateY(-4px)', boxShadow: 'md' } }}
                        >
                            <AspectRatio ratio="2" sx={{ mb: 1, bgcolor: 'background.level1', borderRadius: 'sm' }}>
                                {user.banner_url ? (
                                    <img src={constructImageUrl(user.banner_url)} alt={`${user.username}'s banner`} loading="lazy" />
                                ) : (
                                    <Box />
                                )}
                            </AspectRatio>

                            <CardContent sx={{
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                textAlign: 'center',
                                mt: { xs: -4.5, sm: -5 },
                            }}>
                                <Avatar
                                    src={constructImageUrl(user.pfp_url)}
                                    sx={{
                                        '--Avatar-size': { xs: '60px', sm: '70px' },
                                        border: '2px solid',
                                        borderColor: 'background.body',
                                    }}
                                />
                                <Typography level="title-md" sx={{ mt: 1 }}>{user.username}</Typography>
                                <Stack
                                    direction="row"
                                    spacing={1}
                                    sx={{ mt: 0.5, flexWrap: 'wrap', gap: 0.5, justifyContent: 'center' }}
                                >
                                    {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨ --- */}
                                    {user.rank ? (
                                        <Chip
                                            size="sm"
                                            sx={{
                                                backgroundColor: user.rank.display_color,
                                                color: isColorLight(user.rank.display_color) ? '#000' : '#FFF',
                                            }}
                                        >
                                            {user.rank.name}
                                        </Chip>
                                    ) : null}

                                    {user.minecraft_username && (
                                        <Chip
                                            size="sm"
                                            variant="soft"
                                            color={user.is_minecraft_online ? 'success' : 'neutral'}
                                            startDecorator={<CircleIcon sx={{ fontSize: '10px' }} />}
                                        >
                                            {user.is_minecraft_online ? 'Online' : 'Offline'}
                                        </Chip>
                                    )}
                                </Stack>
                            </CardContent>
                        </Card>
                    </Grid>
                ))}
            </Grid>
            {totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
                    {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ó–∞–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–∞ –Ω–∞—à --- */}
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
        </Box>
    );
}

export default PlayersPage;
--- END FILE: frontend/src/pages/PlayersPage.js ---



--- START FILE: frontend/src/pages/PostsPage.js ---

// frontend/src/pages/PostsPage.js

import React, { useState, useEffect, useCallback } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import {
    Typography, List, ListItem, Sheet, Avatar, Link as JoyLink, Button, IconButton, Dropdown, Menu, MenuButton, MenuItem, Stack, CircularProgress, Alert, Box,
    useTheme
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import BlockIcon from '@mui/icons-material/Block';
import JoyPagination from '../components/JoyPagination';
import VoteButtons from '../components/VoteButtons';
import { constructImageUrl } from '../utils/url';

function PostsPage() {
    const [posts, setPosts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const { isLoggedIn, authToken, user: currentUser } = useAuth();
    const navigate = useNavigate();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
    
    // –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const [page, setPage] = useState(1);
    const [limit, setLimit] = useState(10);
    const [totalPages, setTotalPages] = useState(0);

    const fetchPosts = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            const config = { 
                headers: authToken ? { Authorization: `Bearer ${authToken}` } : {},
                params: { page, limit }
            };
            const response = await axios.get('/api/posts', config);
            
            // --- –ì–õ–ê–í–ù–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨ ---
            setPosts(response.data.data); // –ë–µ—Ä–µ–º –º–∞—Å—Å–∏–≤ –∏–∑ –ø–æ–ª—è 'data'
            setTotalPages(Math.ceil(response.data.total / limit));

        } catch (err) {
            setError('Failed to load posts. Please try again later.');
        } finally {
            setLoading(false);
        }
    }, [authToken, page, limit]);

    useEffect(() => { 
        fetchPosts(); 
    }, [fetchPosts]);

    const handleVote = useCallback(async (postId, value) => {
        if (!isLoggedIn) { alert('Please log in to vote.'); return; }
        try {
            await axios.post(`/api/votes/posts/${postId}`, { value }, { headers: { Authorization: `Bearer ${authToken}` } });
            // –í–º–µ—Å—Ç–æ –ø–æ–ª–Ω–æ–π –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏, –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –æ–±–Ω–æ–≤–ª—è—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ,
            // –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º fetchPosts()
            fetchPosts(); 
        } catch (error) {
            alert(error.response?.data?.message || 'Failed to vote.');
            fetchPosts();
        }
    }, [isLoggedIn, authToken, fetchPosts]);

    const handleDeletePost = useCallback(async (postIdToDelete) => {
        if (!window.confirm('Are you sure you want to permanently delete this post?')) return;
        try {
            await axios.delete(`/api/posts/${postIdToDelete}`, { headers: { Authorization: `Bearer ${authToken}` } });
            fetchPosts(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å—Ç—ã –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è
        } catch (err) { 
            alert(err.response?.data?.message || 'Failed to delete post.'); 
        }
    }, [authToken, fetchPosts]);

    const handleBanUser = useCallback(async (author) => {
        if (!author || !window.confirm(`Are you sure you want to ban ${author.username}?`)) return;
        try {
            await axios.post(`/api/admin/users/${author.id}/ban`, {}, { headers: { Authorization: `Bearer ${authToken}` } });
            alert(`User ${author.username} has been banned.`);
        } catch (err) { 
            alert(err.response?.data?.message || 'Failed to ban user.'); 
        }
    }, [authToken]);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger" sx={{ mt: 2 }}>{error}</Alert>;

    const isAdmin = currentUser && ['ADMIN', 'MODERATOR', 'OWNER'].includes(currentUser.rank.name);

    return (
        <Box>
            <Box sx={{ display: 'flex', flexDirection: { xs: 'column', sm: 'row' }, justifyContent: 'space-between', alignItems: { xs: 'flex-start', sm: 'center' }, mb: 2, gap: 2 }}>
                <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1">Community Posts</Typography>
                {isLoggedIn && (
                    <Button component={RouterLink} to="/posts/new" startDecorator={<AddIcon />} sx={{ width: { xs: '100%', sm: 'auto' }}}>
                        Create Post
                    </Button>
                )}
            </Box>

            {!loading && totalPages > 1 && (
                 <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
            <List sx={{ borderRadius: 'sm', p: 0, bgcolor: 'background.body', border: '1px solid', borderColor: 'divider' }}>
                {posts.map((post) => {
                    const canManagePost = isLoggedIn && (currentUser?.id === post.author?.id || isAdmin);
                    
                    return (
                        <ListItem key={post.id} sx={{ '&:not(:last-of-type)': { borderBottom: '1px solid', borderColor: 'divider' }, p: 0 }}>
                            <Sheet sx={{ p: {xs: 1.5, sm: 2}, flexGrow: 1, bgcolor: 'transparent' }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, minWidth: 0 }}>
                                        {post.author ? (<JoyLink component={RouterLink} to={`/users/${post.author.profile_slug || post.author.id}`}><Avatar src={constructImageUrl(post.author.pfp_url)}>{post.author.username.charAt(0)}</Avatar></JoyLink>) : ( <Avatar>?</Avatar> )}
                                        <Typography level="title-md" sx={{ textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }}>
                                            {post.author ? (
                                                <JoyLink 
                                                    level="title-lg" 
                                                    component={RouterLink} 
                                                    to={`/users/${post.author.profile_slug || post.author.id}`} 
                                                    overlay 
                                                    sx={{ color: post.author.rank?.display_color }}
                                                >
                                                    {post.author.username}
                                                </JoyLink>
                                            ) : ( 'Anonymous' )}
                                        </Typography>
                                    </Box>
                                    {canManagePost && (
                                        <Box sx={{ flexShrink: 0 }}>
                                            <Dropdown>
                                                <MenuButton slots={{ root: IconButton }} slotProps={{ root: { variant: 'plain', color: 'neutral', size: 'sm' } }}><MoreVertIcon /></MenuButton>
                                                <Menu size="sm">
                                                    <MenuItem onClick={() => navigate(`/posts/${post.id}/edit`)}><EditIcon /> Edit</MenuItem>
                                                    <MenuItem color="danger" onClick={() => handleDeletePost(post.id)}><DeleteForeverIcon /> Delete</MenuItem>
                                                    {isAdmin && currentUser?.id !== post.author?.id && (<MenuItem color="danger" onClick={() => handleBanUser(post.author)}><BlockIcon /> Ban Author</MenuItem>)}
                                                </Menu>
                                            </Dropdown>
                                        </Box>
                                    )}
                                </Box>
                                
                                <JoyLink component={RouterLink} to={`/posts/${post.id}`} level="h4" fontWeight="lg" sx={{ '&:hover': { textDecoration: 'underline' }, mb: 1, color: 'text.primary', wordBreak: 'break-word' }}>
                                    {post.title}
                                </JoyLink>

                                <Typography level="body-md" sx={{ mb: 2, display: '-webkit-box', WebkitLineClamp: 3, WebkitBoxOrient: 'vertical', overflow: 'hidden', textOverflow: 'ellipsis', wordBreak: 'break-word' }}>
                                    {post.content}
                                </Typography>

                                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: 'text.tertiary' }}>
                                    <VoteButtons initialScore={post.score} currentUserVote={post.currentUserVote} onVote={(value) => handleVote(post.id, value)} disabled={!isLoggedIn} />
                                    <Typography level="body-xs">{new Date(post.created_at).toLocaleDateString()}</Typography>
                                </Box>
                            </Sheet>
                        </ListItem>
                    );
                })}
            </List>

            {totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                    <JoyPagination
                        count={totalPages}
                        page={page}
                        onChange={(event, value) => setPage(value)}
                    />
                </Box>
            )}
        </Box>
    );
}

export default PostsPage;
--- END FILE: frontend/src/pages/PostsPage.js ---



--- START FILE: frontend/src/pages/PublicProfilePage.js ---

// frontend/src/pages/PublicProfilePage.js

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import { Box, Typography, Sheet, Avatar, CircularProgress, Alert, Divider, Button, Chip, Dropdown, Menu, MenuButton, MenuItem, Stack, useTheme, IconButton, Tooltip, AspectRatio } from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import PersonAddIcon from '@mui/icons-material/PersonAdd';
import HowToRegIcon from '@mui/icons-material/HowToReg';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import BlockIcon from '@mui/icons-material/Block';
import PersonRemoveIcon from '@mui/icons-material/PersonRemove';
import ThumbUpOffAltIcon from '@mui/icons-material/ThumbUpOffAlt';
import MailIcon from '@mui/icons-material/Mail';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import { constructImageUrl } from '../utils/url';
import CircleIcon from '@mui/icons-material/Circle';


function isColorLight(hexColor) {
    if (!hexColor) return false;
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155;
}

function PublicProfilePage() {
    // –í—Å—è –ª–æ–≥–∏–∫–∞ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    const { userId } = useParams();
    const navigate = useNavigate();
    const { isLoggedIn, user: currentUser, authToken, socket } = useAuth();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
    const [profile, setProfile] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [friendship, setFriendship] = useState({ status: 'loading' });
    const isAdmin = currentUser && ['ADMIN', 'MODERATOR', 'OWNER'].includes(currentUser.rank);
    const fetchProfileAndStatus = useCallback(async () => {
        setLoading(true); setError(null);
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            const idAsNumber = parseInt(userId, 10);
            const identifier = isNaN(idAsNumber) ? userId : idAsNumber;
            const profileResponse = await axios.get(`/api/users/${identifier}`);
            setProfile(profileResponse.data);
            if (isLoggedIn && currentUser?.id !== profileResponse.data.id) {
                const statusResponse = await axios.get(`/api/friendships/status/${profileResponse.data.id}`, config);
                setFriendship(statusResponse.data);
            } else if (currentUser?.id === profileResponse.data.id) {
                setFriendship({ status: 'self' });
            } else {
                setFriendship({ status: 'guest' });
            }
        } catch (err) { setError('Failed to load user profile.'); } finally { setLoading(false); }
    }, [userId, authToken, isLoggedIn, currentUser?.id]);
    useEffect(() => { fetchProfileAndStatus(); }, [fetchProfileAndStatus]);
    const handleAction = async (action) => {
        const config = { headers: { Authorization: `Bearer ${authToken}` } };
        try {
            switch (action) {
                case 'add': await axios.post(`/api/friendships/requests`, { receiverId: profile.id }, config); break;
                case 'accept': await axios.patch(`/api/friendships/requests/${friendship.requestId}/accept`, {}, config); break;
                case 'reject': case 'cancel': await axios.delete(`/api/friendships/requests/${friendship.requestId}`, config); break;
                case 'remove': await axios.delete(`/api/friendships/${friendship.friendshipId}`, config); break;
                case 'block': await axios.post(`/api/friendships/block/${profile.id}`, {}, config); break;
                case 'unblock': await axios.delete(`/api/friendships/block/${profile.id}`, config); break;
                default: break;
            }
            fetchProfileAndStatus();
        } catch (err) { alert(err.response?.data?.message || 'An error occurred.'); }
    };
    const handleToggleBanStatus = async () => {
        if (!profile) return;
        const action = profile.is_banned ? 'unban' : 'ban';
        if (!window.confirm(`Are you sure you want to ${action} ${profile.username}?`)) return;
        try {
            const config = { headers: { Authorization: `Bearer ${authToken}` } };
            await axios.post(`/api/admin/users/${profile.id}/${action}`, {}, config);
            fetchProfileAndStatus();
        } catch (err) { alert(`Failed to ${action} user.`); }
    };
    useEffect(() => {
        if (!socket || !profile) return;
        const handleStatusUpdate = (data) => {
            if (data.userId === profile.id) {
                setProfile(prevProfile => ({ ...prevProfile, is_minecraft_online: data.is_minecraft_online }));
            }
        };
        socket.on('userStatusUpdate', handleStatusUpdate);
        return () => { socket.off('userStatusUpdate', handleStatusUpdate); };
    }, [socket, profile]);

    const renderActionButtons = () => {
        if (!isLoggedIn || friendship.status === 'self' || friendship.status === 'guest') return null;
        switch (friendship.status) {
            case 'ACCEPTED':
                return (<Dropdown>
                    <MenuButton endDecorator={<MoreVertIcon />} slots={{ root: Button }} slotProps={{ root: { variant: 'soft', color: 'neutral', startDecorator: <HowToRegIcon /> } }}>Friends</MenuButton>
                    <Menu>
                        <MenuItem onClick={() => handleAction('remove')}><PersonRemoveIcon /> Remove Friend</MenuItem>
                        <MenuItem onClick={() => handleAction('block')} sx={{ color: 'danger.500' }}><BlockIcon /> Block User</MenuItem>
                    </Menu>
                </Dropdown>);
            case 'PENDING_INCOMING': // –î–ª—è —ç—Ç–æ–≥–æ —Å–ª—É—á–∞—è –æ—Å—Ç–∞–≤–ª—è–µ–º Stack, —Ç–∞–∫ –∫–∞–∫ 2 –∫–Ω–æ–ø–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–º–µ—Å—Ç–µ
                return (<Stack direction="row" spacing={1}><Button color="success" onClick={() => handleAction('accept')}>Accept</Button><Button color="danger" variant="outlined" onClick={() => handleAction('reject')}>Decline</Button></Stack>);
            case 'PENDING_OUTGOING':
                return <Button disabled startDecorator={<AccessTimeIcon />} onClick={() => handleAction('cancel')}>Request Sent</Button>;
            case 'BLOCKED':
                return <Button color="warning" onClick={() => handleAction('unblock')}>Unblock</Button>;
            case 'NONE': default:
                return <Button variant="solid" color="primary" startDecorator={<PersonAddIcon />} onClick={() => handleAction('add')}>Add Friend</Button>;
        }
    };

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;
    if (!profile) return <Typography>User not found.</Typography>;

    return (
        <Box>
            <Sheet variant="outlined" sx={{ borderRadius: 'md', p: { xs: 2, sm: 3, md: 4 } }}>
                <Box sx={{ position: 'relative' }}>
                    <AspectRatio ratio="16/5" sx={{ width: '100%', borderRadius: 'sm', bgcolor: 'background.level1' }}>
                        {profile.banner_url ? (
                            <img
                                src={constructImageUrl(profile.banner_url)}
                                alt={`${profile.username}'s banner`}
                                style={{ objectFit: 'cover' }}
                            />
                        ) : (
                            <Box sx={{ background: 'linear-gradient(180deg, var(--joy-palette-neutral-700), var(--joy-palette-neutral-800))' }} />
                        )}
                    </AspectRatio>
                    <Box
                        sx={{
                            position: 'absolute', bottom: 0, left: 0, right: 0, height: '50%',
                            background: 'linear-gradient(to top, var(--joy-palette-background-level1), transparent)',
                        }}
                    />
                </Box>

                <Box sx={{
                    display: 'flex',
                    flexDirection: { xs: 'column', sm: 'row' },
                    alignItems: { xs: 'center', sm: 'flex-end' },
                    gap: 3,
                    mt: { xs: -4, sm: -6 },
                    position: 'relative',
                    paddingLeft: 4,
                    paddingRight: 4
                }}>
                    <Avatar
                        src={constructImageUrl(profile.pfp_url)}
                        sx={{
                            '--Avatar-size': { xs: '80px', sm: '128px' },
                            border: '4px solid',
                            borderColor: 'background.body',
                            boxShadow: 'sm',
                            mx: { xs: 'auto', sm: 0 },
                        }}
                    />
                    <Box sx={{ textAlign: { xs: 'center', sm: 'left' }, flexGrow: 1 }}>
                        <Typography level="h2" component="h1">{profile.username}</Typography>
                        {profile.profile_slug && (<Typography level="body-md" textColor="text.tertiary">@{profile.profile_slug}</Typography>)}

                        <Stack direction="row" spacing={1} sx={{ mt: 0.5, justifyContent: { xs: 'center', sm: 'flex-start' }, flexWrap: 'wrap', gap: 1 }}>
                            {profile.rank && <Chip sx={{ backgroundColor: profile.rank.display_color, color: isColorLight(profile.rank.display_color) ? '#000' : '#FFF' }}>{profile.rank.name}</Chip>}
                            <Chip color="neutral" variant="outlined" startDecorator={<ThumbUpOffAltIcon />}>Reputation: {profile.reputation_count}</Chip>
                            {profile.minecraft_username && <Chip variant="soft" color={profile.is_minecraft_online ? 'success' : 'neutral'} startDecorator={<CircleIcon sx={{ fontSize: '10px' }} />}>{profile.minecraft_username} ({profile.is_minecraft_online ? 'Online' : 'Offline'})</Chip>}
                        </Stack>
                    </Box>

                    {/* –õ–æ–≥–∏–∫–∞ –∫–Ω–æ–ø–æ–∫, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã */}
                    <Stack
                        direction="row"
                        spacing={1}
                        sx={{
                            width: { xs: '100%', sm: 'auto' },
                            flexShrink: 0,
                            justifyContent: 'center'
                        }}
                    >
                        {isLoggedIn && friendship.status !== 'self' && friendship.status !== 'BLOCKED' && (
                            <Button variant="solid" color="primary" startDecorator={<MailIcon />} onClick={() => navigate(`/messages/${profile.id}`)}>Message</Button>
                        )}
                        {renderActionButtons()}
                        {isAdmin && friendship.status !== 'self' && (
                            profile.is_banned
                                ? <Button variant="soft" color="success" startDecorator={<CheckCircleOutlineIcon />} onClick={handleToggleBanStatus}>Unban</Button>
                                : <Button variant="soft" color="danger" startDecorator={<BlockIcon />} onClick={handleToggleBanStatus}>Ban</Button>
                        )}
                    </Stack>
                </Box>

                <Divider sx={{ my: 3 }} />

                <Typography level="body-lg" sx={{ whiteSpace: 'pre-wrap' }}>
                    {profile.description || 'No description provided.'}
                </Typography>
            </Sheet>
        </Box>
    );
}

export default PublicProfilePage;
--- END FILE: frontend/src/pages/PublicProfilePage.js ---



--- START FILE: frontend/src/pages/RegisterPage.js ---

// frontend/src/pages/RegisterPage.js

import React, { useState } from 'react';
import { useNavigate, Link as RouterLink, NavLink } from 'react-router-dom';
import axios from 'axios';
import {
    Sheet,
    Typography,
    FormControl,
    FormLabel,
    Input,
    Button,
    Link,
    Alert,
    Stack,
    Box, // <-- –î–æ–±–∞–≤–ª—è–µ–º Box
    Link as JoyLink // <-- –î–æ–±–∞–≤–ª—è–µ–º JoyLink
} from '@mui/joy';
import AdbIcon from '@mui/icons-material/Adb'; // <-- –ò–∫–æ–Ω–∫–∞ –¥–ª—è –ª–æ–≥–æ—Ç–∏–ø–∞

function RegisterPage() {
    const navigate = useNavigate();
    const [formData, setFormData] = useState({
        username: '',
        email: '',
        password: '',
    });
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleRegister = async (event) => {
        event.preventDefault();
        setLoading(true);
        setError('');
        try {
            await axios.post(`/api/auth/register`, formData);
            navigate('/login');
        } catch (err) {
            setError(err.response?.data?.message || 'Registration failed. Please try again.');
            console.error('Registration error:', err);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Sheet sx={{
            display: 'flex',
            flexFlow: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            minHeight: '100dvh',
            p: 2,
        }}>
            <Sheet
                variant="outlined"
                sx={{
                    width: '100%',
                    maxWidth: '400px',
                    mx: 'auto',
                    py: { xs: 2, sm: 3 },
                    px: { xs: 2, sm: 4 },
                    display: 'flex',
                    flexDirection: 'column',
                    gap: 2,
                    borderRadius: 'sm',
                    boxShadow: 'md',
                }}
            >
                {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ1: –ö–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–π –ª–æ–≥–æ—Ç–∏–ø –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ --- */}
                <Box sx={{ display: 'flex', justifyContent: 'center', mb: 1 }}>
                    <JoyLink component={RouterLink} to="/" sx={{ textDecoration: 'none' }}>
                        <Box sx={{
                            flexGrow: 1,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: 1
                        }}>
                            <img src="/logo.png" alt="FlameWall Logo" style={{ width: '40px', height: '40px' }} />
                            <Typography fontWeight="lg" level="h2" component="div">FlameWall</Typography>
                        </Box>
                    </JoyLink>
                </Box>

                <div>
                    <Typography level="h4" component="h1"><b>Create an account</b></Typography>
                    <Typography level="body-sm">Join our community!</Typography>
                </div>

                {error && <Alert color="danger">{error}</Alert>}

                <form onSubmit={handleRegister}>
                    <Stack spacing={1.5}>
                        <FormControl required>
                            <FormLabel>Username</FormLabel>
                            {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ2: –ê—Ç—Ä–∏–±—É—Ç autoComplete --- */}
                            <Input name="username" value={formData.username} onChange={handleChange} disabled={loading} autoComplete="username" />
                        </FormControl>
                        <FormControl required>
                            <FormLabel>Email</FormLabel>
                            {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ2: –ê—Ç—Ä–∏–±—É—Ç autoComplete --- */}
                            <Input type="email" name="email" value={formData.email} onChange={handleChange} disabled={loading} autoComplete="email" />
                        </FormControl>
                        <FormControl required>
                            <FormLabel>Password</FormLabel>
                            {/* --- –†–ï–®–ï–ù–ò–ï –ü–†–û–ë–õ–ï–ú–´ ‚Ññ2: –ê—Ç—Ä–∏–±—É—Ç autoComplete --- */}
                            <Input type="password" name="password" value={formData.password} onChange={handleChange} disabled={loading} autoComplete="new-password" />
                        </FormControl>
                        <Button type="submit" loading={loading} fullWidth sx={{ mt: 1 }}>
                            Sign up
                        </Button>
                    </Stack>
                </form>

                <Typography
                    endDecorator={<Link component={RouterLink} to="/login">Log in</Link>}
                    fontSize="sm"
                    sx={{ alignSelf: 'center' }}
                >
                    Already have an account?
                </Typography>
            </Sheet>
        </Sheet>
    );
}

export default RegisterPage;
--- END FILE: frontend/src/pages/RegisterPage.js ---



--- START FILE: frontend/src/pages/SearchPage.js ---

// frontend/src/pages/SearchPage.js

import React, { useState, useEffect, useCallback } from 'react';
import { useSearchParams, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import {
    Box,
    Typography,
    CircularProgress,
    Alert,
    Grid,
    Card,
    CardContent,
    Avatar,
    Chip,
    List,
    ListItem,
    ListItemButton,
    ListItemContent as JoyListItemContent,
    Link as JoyLink,
    Divider,
} from '@mui/joy';
import { constructImageUrl } from '../utils/url';

function SearchPage() {
    const [searchParams] = useSearchParams();
    const query = searchParams.get('query');
    const [results, setResults] = useState({ users: [], posts: [] });
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchResults = useCallback(async () => {
        if (!query) {
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            // –ó–∞–ø—Ä–æ—Å—ã –æ—Å—Ç–∞—é—Ç—Å—è —Ç–µ–º–∏ –∂–µ
            const [usersRes, postsRes] = await Promise.all([
                axios.get(`/api/users`, { params: { search: query } }),
                axios.get(`/api/posts`, { params: { search: query } })
            ]);
            
            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨ ---
            // –ú—ã –¥–æ–ª–∂–Ω—ã –±—Ä–∞—Ç—å –º–∞—Å—Å–∏–≤—ã –∏–∑ –ø–æ–ª—è .data –≤ –∫–∞–∂–¥–æ–º –æ—Ç–≤–µ—Ç–µ
            setResults({ 
                users: usersRes.data.data, 
                posts: postsRes.data.data 
            });

        } catch (err) {
            setError('Failed to fetch search results.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [query]);

    useEffect(() => {
        fetchResults();
    }, [fetchResults]);

    if (loading) {
        return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
    }

    if (error) {
        return <Alert color="danger">{error}</Alert>;
    }

    const noResults = results.users.length === 0 && results.posts.length === 0;

    return (
        <Box>
            <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1" sx={{ mb: 3 }}>
                Search Results for: "{query}"
            </Typography>

            {noResults ? (
                <Typography>No results found.</Typography>
            ) : (
                <Grid container spacing={4}>
                    {results.posts.length > 0 && (
                        <Grid xs={12}>
                            <Typography level={{ xs: 'h3', sm: 'h2' }} component="h2" sx={{ mb: 2 }}>Found Posts</Typography>
                            <List variant="outlined" sx={{ borderRadius: 'sm', p: 0 }}>
                                {results.posts.map((post, index) => (
                                    <React.Fragment key={post.id}>
                                        <ListItem>
                                            <ListItemButton component={RouterLink} to={`/posts/${post.id}`}>
                                                <JoyListItemContent>
                                                    <JoyLink component="span" level="title-md">{post.title}</JoyLink>
                                                    <Typography level="body-sm" sx={{
                                                        display: '-webkit-box', WebkitLineClamp: 2, WebkitBoxOrient: 'vertical', overflow: 'hidden', textOverflow: 'ellipsis'
                                                    }}>
                                                        {post.content}
                                                    </Typography>
                                                </JoyListItemContent>
                                            </ListItemButton>
                                        </ListItem>
                                        {index < results.posts.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        </Grid>
                    )}

                    {results.users.length > 0 && (
                        <Grid xs={12}>
                            <Typography level={{ xs: 'h3', sm: 'h2' }} component="h2" sx={{ mt: results.posts.length > 0 ? 4 : 0, mb: 2 }}>Found Players</Typography>
                            <Grid container spacing={2}>
                                {results.users.map((user) => (
                                    <Grid xs={12} sm={6} md={4} lg={3} key={user.id}>
                                        <Card component={RouterLink} to={`/users/${user.profile_slug || user.id}`} sx={{ textDecoration: 'none', height: '100%' }}>
                                            <CardContent sx={{ alignItems: 'center', textAlign: 'center' }}>
                                                <Avatar src={constructImageUrl(user.pfp_url)} sx={{ '--Avatar-size': '80px', mb: 1 }} />
                                                <Typography level="title-lg">{user.username}</Typography>
                                                <Chip size="sm" color="primary" sx={{ mt: 0.5 }}>{user.rank.name}</Chip>
                                            </CardContent>
                                        </Card>
                                    </Grid>
                                ))}
                            </Grid>
                        </Grid>
                    )}
                </Grid>
            )}
        </Box>
    );
}

export default SearchPage;
--- END FILE: frontend/src/pages/SearchPage.js ---



--- START FILE: frontend/src/pages/SettingsPage.js ---

// frontend/src/pages/SettingsPage.js

import React, { useState, useEffect, useRef } from 'react';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import {
    Box, Typography, FormControl, FormLabel, Input, Button, Alert,
    CircularProgress, Sheet, Divider, Textarea, Stack, Avatar, AspectRatio,
} from '@mui/joy';
import EditIcon from '@mui/icons-material/Edit';
import LinkIcon from '@mui/icons-material/Link';
import { useNavigate } from 'react-router-dom';
import { constructImageUrl } from '../utils/url';


function SettingsPage() {
    const { authToken, updateAuthToken, user } = useAuth();
    const navigate = useNavigate();

    const [profileData, setProfileData] = useState({ username: '', profile_slug: '', description: '' });
    const [passwordData, setPasswordData] = useState({ currentPassword: '', newPassword: '', confirmPassword: '' });
    const [avatarFile, setAvatarFile] = useState(null);
    const [avatarPreview, setAvatarPreview] = useState(null);
    const [bannerFile, setBannerFile] = useState(null);
    const [bannerPreview, setBannerPreview] = useState(null);
    const avatarInputRef = useRef(null);
    const bannerInputRef = useRef(null);
    
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [passwordError, setPasswordError] = useState('');
    const [passwordSuccess, setPasswordSuccess] = useState('');

    useEffect(() => {
        const fetchProfile = async () => {
            if (!authToken) return;
            try {
                setLoading(true);
                if (user) {
                    setProfileData({
                        username: user.username || '',
                        profile_slug: user.profile_slug || '',
                        description: user.description || '',
                    });
                    setAvatarPreview(user.pfp_url);
                    setBannerPreview(user.banner_url);
                }
            } catch (err) {
                setError('Failed to load profile data.');
            } finally {
                setLoading(false);
            }
        };
        fetchProfile();
    }, [authToken, user]);

    const handleProfileChange = (e) => setProfileData({ ...profileData, [e.target.name]: e.target.value });
    const handlePasswordChange = (e) => setPasswordData({ ...passwordData, [e.target.name]: e.target.value });

    const handleFileChange = (event, type) => {
        const file = event.target.files[0];
        if (!file) return;
        const previewUrl = URL.createObjectURL(file);
        if (type === 'avatar') {
            setAvatarFile(file);
            setAvatarPreview(previewUrl);
        } else {
            setBannerFile(file);
            setBannerPreview(previewUrl);
        }
    };

    const handleProfileSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        setSuccess('');
        try {
            const promises = [];
            // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω –ø—Ä–µ—Ñ–∏–∫—Å /api ---
            promises.push(axios.patch('/api/users/me', profileData, { headers: { Authorization: `Bearer ${authToken}` } }));

            if (avatarFile) {
                const formData = new FormData();
                formData.append('file', avatarFile);
                // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω –ø—Ä–µ—Ñ–∏–∫—Å /api ---
                promises.push(axios.post('/api/users/me/avatar', formData, { headers: { Authorization: `Bearer ${authToken}` } }));
            }
            if (bannerFile) {
                const formData = new FormData();
                formData.append('file', bannerFile);
                // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω –ø—Ä–µ—Ñ–∏–∫—Å /api ---
                promises.push(axios.post('/api/users/me/banner', formData, { headers: { Authorization: `Bearer ${authToken}` } }));
            }

            const results = await Promise.all(promises);
            const profileUpdateResponse = results[0];
            if (profileUpdateResponse && profileUpdateResponse.data.access_token) {
                updateAuthToken(profileUpdateResponse.data.access_token);
            }
            setSuccess('Profile saved successfully!');
            setAvatarFile(null);
            setBannerFile(null);
        } catch (err) {
            const message = err.response?.data?.message;
            const errorMessage = Array.isArray(message) ? message.join(', ') : message;
            setError(errorMessage || 'Failed to update profile.');
        } finally {
            setLoading(false);
        }
    };

    const handlePasswordSubmit = async (e) => {
        e.preventDefault();
        if (passwordData.newPassword !== passwordData.confirmPassword) {
            setPasswordError('New passwords do not match.'); return;
        }
        setLoading(true);
        setPasswordError('');
        setPasswordSuccess('');
        try {
            // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω –ø—Ä–µ—Ñ–∏–∫—Å /api ---
            await axios.post('/api/auth/change-password', 
                { currentPassword: passwordData.currentPassword, newPassword: passwordData.newPassword },
                { headers: { Authorization: `Bearer ${authToken}` } }
            );
            setPasswordSuccess('Password changed successfully!');
            setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' });
        } catch (err) {
            setPasswordError(err.response?.data?.message || 'Failed to change password.');
        } finally {
            setLoading(false);
        }
    };

    if (loading && !profileData.username) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;

    return (
        <Stack spacing={4}>
            <Typography level={{ xs: 'h2', sm: 'h1' }}>Account Settings</Typography>
            
            <Sheet variant="outlined" sx={{ p: { xs: 2, sm: 3, md: 4 }, borderRadius: 'md' }}>
                <form onSubmit={handleProfileSubmit}>
                    <Typography level={{ xs: 'h4', sm: 'h3' }} component="h2" sx={{ mb: 2 }}>Edit Profile</Typography>
                    {error && <Alert color="danger" sx={{ mb: 2 }}>{error}</Alert>}
                    {success && <Alert color="success" sx={{ mb: 2 }}>{success}</Alert>}
                    <Stack spacing={3}>
                        <FormControl>
                            <FormLabel>Profile Picture</FormLabel>
                            <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2} alignItems="center">
                                <Avatar src={avatarPreview?.startsWith('blob:') ? avatarPreview : (avatarPreview ? constructImageUrl(avatarPreview): undefined)} sx={{ '--Avatar-size': '80px' }} />
                                <Button startDecorator={<EditIcon />} variant="outlined" onClick={() => avatarInputRef.current.click()} sx={{ width: { xs: '100%', sm: 'auto' } }}>Upload</Button>
                                <input type="file" accept="image/*" hidden ref={avatarInputRef} onChange={(e) => handleFileChange(e, 'avatar')} />
                            </Stack>
                        </FormControl>
                        <FormControl>
                            <FormLabel>Profile Banner</FormLabel>
                            <AspectRatio ratio="16/5" sx={{ width: '100%', borderRadius: 'md', mb: 1, bgcolor: 'background.level1' }}>
                                {bannerPreview ? <img src={bannerPreview?.startsWith('blob:') ? bannerPreview : constructImageUrl(bannerPreview)} alt="Banner"/> : <Box component="div" />}
                            </AspectRatio>
                            <Button startDecorator={<EditIcon />} variant="outlined" onClick={() => bannerInputRef.current.click()} sx={{ alignSelf: 'flex-start', width: { xs: '100%', sm: 'auto' } }}>Upload Banner</Button>
                            <input type="file" accept="image/*" hidden ref={bannerInputRef} onChange={(e) => handleFileChange(e, 'banner')} />
                        </FormControl>
                        <Divider />
                        <FormControl>
                            <FormLabel>Username</FormLabel>
                            <Input name="username" value={profileData.username} onChange={handleProfileChange} />
                        </FormControl>
                        <FormControl>
                            <FormLabel>Profile Slug (@your-name)</FormLabel>
                            <Input name="profile_slug" value={profileData.profile_slug} onChange={handleProfileChange} />
                        </FormControl>
                        <FormControl>
                            <FormLabel>Description</FormLabel>
                            <Textarea name="description" value={profileData.description} onChange={handleProfileChange} minRows={3} />
                        </FormControl>
                        <Button type="submit" loading={loading} sx={{ mt: 1, alignSelf: { xs: 'center', sm: 'flex-start' }, width: { xs: '100%', sm: 'auto' } }}>Save All Changes</Button>
                    </Stack>
                </form>
            </Sheet>

            <Sheet variant="outlined" sx={{ p: { xs: 2, sm: 3, md: 4 }, borderRadius: 'md' }}>
                <Typography level={{ xs: 'h4', sm: 'h3' }} component="h2" sx={{ mb: 2 }}>Minecraft Integration</Typography>
                {user?.minecraft_uuid ? (
                    <Box>
                        <Typography>Your account is linked to Minecraft account: <strong>{user.minecraft_username}</strong></Typography>
                        <Button sx={{mt: 2, width: { xs: '100%', sm: 'auto' } }} variant="outlined" color="neutral" onClick={() => navigate('/profile/link-minecraft')}>Manage</Button>
                    </Box>
                ) : (
                    <Box>
                        <Typography>Link your Minecraft account to sync your status and more.</Typography>
                        <Button sx={{mt: 2, width: { xs: '100%', sm: 'auto' } }} startDecorator={<LinkIcon />} onClick={() => navigate('/profile/link-minecraft')}>Link Account</Button>
                    </Box>
                )}
            </Sheet>

            <Sheet variant="outlined" sx={{ p: { xs: 2, sm: 3, md: 4 }, borderRadius: 'md' }}>
                <Typography level={{ xs: 'h4', sm: 'h3' }} component="h2" sx={{ mb: 2 }}>Change Password</Typography>
                <form onSubmit={handlePasswordSubmit}>
                    <Stack spacing={2}>
                        {passwordError && <Alert color="danger">{passwordError}</Alert>}
                        {passwordSuccess && <Alert color="success">{passwordSuccess}</Alert>}
                        <FormControl required><FormLabel>Current Password</FormLabel><Input type="password" name="currentPassword" value={passwordData.currentPassword} onChange={handlePasswordChange} /></FormControl>
                        <FormControl required><FormLabel>New Password</FormLabel><Input type="password" name="newPassword" value={passwordData.newPassword} onChange={handlePasswordChange} /></FormControl>
                        <FormControl required><FormLabel>Confirm New Password</FormLabel><Input type="password" name="confirmPassword" value={passwordData.confirmPassword} onChange={handlePasswordChange} /></FormControl>
                        <Button type="submit" loading={loading} sx={{ mt: 1, alignSelf: { xs: 'center', sm: 'flex-start' }, width: { xs: '100%', sm: 'auto' } }}>Change Password</Button>
                    </Stack>
                </form>
            </Sheet>
        </Stack>
    );
}

export default SettingsPage;
--- END FILE: frontend/src/pages/SettingsPage.js ---



--- START FILE: frontend/src/pages/ShopPage.js ---

// frontend/src/pages/ShopPage.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Box, Typography, CircularProgress, Alert, Grid, Card, CardContent, Button, AspectRatio } from '@mui/joy';
import { constructImageUrl } from '../utils/url';
import PurchaseModal from '../components/PurchaseModal'; // <-- 1. –ò–ú–ü–û–†–¢–ò–†–£–ï–ú

function ShopPage() {
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    // --- 2. –î–û–ë–ê–í–õ–Ø–ï–ú –°–û–°–¢–û–Ø–ù–ò–Ø –î–õ–Ø –ú–û–î–ê–õ–¨–ù–û–ì–û –û–ö–ù–ê ---
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [selectedItem, setSelectedItem] = useState(null);

    const handlePurchaseClick = (item) => {
        // --- 3. –û–ë–ù–û–í–õ–Ø–ï–ú –õ–û–ì–ò–ö–£ –ö–õ–ò–ö–ê ---
        setSelectedItem(item);
        setIsModalOpen(true);
    };

    useEffect(() => {
        const fetchItems = async () => {
            try {
                setLoading(true);
                const response = await axios.get('/api/shop');
                setItems(response.data);
            } catch (err) {
                setError('Failed to load items. The shop might be temporarily unavailable.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchItems();
    }, []);

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;

    return (
        <Box>
            <Typography level="h1" component="h1" sx={{ mb: 3 }}>
                Shop
            </Typography>
            <Grid container spacing={3}>
                {items.length > 0 ? items.map((item) => (
                    <Grid xs={12} sm={6} md={4} key={item.item_id}>
                        <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                            <AspectRatio sx={{ minHeight: '120px', minWidth: '160px' }}>
                                <img
                                    src={constructImageUrl(item.image_url) || 'https://via.placeholder.com/300x150'}
                                    alt={item.name}
                                    loading="lazy"
                                />
                            </AspectRatio>
                            <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
                                <Typography level="title-lg">{item.name}</Typography>
                                <Typography level="body-sm" sx={{ mb: 1, flexGrow: 1 }}>{item.description}</Typography>
                                <Typography level="h4" sx={{ mb: 2 }}>
                                    Price: {item.price} coins
                                </Typography>
                                <Button
                                    variant="solid"
                                    size="md"
                                    color="primary"
                                    onClick={() => handlePurchaseClick(item)}
                                >
                                    Purchase
                                </Button>
                            </CardContent>
                        </Card>
                    </Grid>
                )) : (
                    <Typography sx={{ p: 2 }}>There are no items in the shop yet.</Typography>
                )}
            </Grid>
            
            {/* --- 4. –î–û–ë–ê–í–õ–Ø–ï–ú –ö–û–ú–ü–û–ù–ï–ù–¢ –ú–û–î–ê–õ–¨–ù–û–ì–û –û–ö–ù–ê --- */}
            <PurchaseModal
                open={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                item={selectedItem}
            />
        </Box>
    );
}

export default ShopPage;
--- END FILE: frontend/src/pages/ShopPage.js ---



--- START FILE: frontend/src/pages/SinglePostPage.js ---

// frontend/src/pages/SinglePostPage.js

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, NavLink, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import {
    Typography, CircularProgress, Alert, Box, Sheet, Divider, Avatar, List, ListItem, ListItemDecorator, ListItemContent, Textarea, Button, Link as JoyLink, IconButton, Dropdown, Menu, MenuButton, MenuItem,
    // --- –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º —Ö—É–∫–∏ –∏ Stack ---
    useTheme, Stack
} from '@mui/joy';
import { useMediaQuery } from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import EditIcon from '@mui/icons-material/Edit';
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import BlockIcon from '@mui/icons-material/Block';
import { useAuth } from '../context/AuthContext';
import VoteButtons from '../components/VoteButtons';
import { constructImageUrl } from '../utils/url';

function SinglePostPage() {
    const { postId } = useParams();
    const navigate = useNavigate();
    const { isLoggedIn, user: currentUser, authToken } = useAuth();

    // --- –ò–ó–ú–ï–ù–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ ---
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const [post, setPost] = useState(null);
    const [loading, setLoading] = useState(true);
    // ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    const [error, setError] = useState(null);
    const [newCommentContent, setNewCommentContent] = useState('');
    const [isSubmittingComment, setIsSubmittingComment] = useState(false);
    const [editingCommentId, setEditingCommentId] = useState(null);
    const [editedContent, setEditedContent] = useState('');


    const fetchPost = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            const config = authToken ? { headers: { Authorization: `Bearer ${authToken}` } } : {};
            const response = await axios.get(`/api/posts/${postId}`, config);
            setPost(response.data);
        } catch (err) {
            setError('Failed to load post. It may have been deleted or the link is incorrect.');
        } finally {
            setLoading(false);
        }
    }, [postId, authToken]);

    useEffect(() => { if (postId) fetchPost(); }, [postId, fetchPost]);

    // --- –ò–ó–ú–ï–ù–ï–ù–û: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω –ø—É—Ç—å –∫ API ---
    const handleBanUser = async (userToBan) => {
        if (!userToBan || !window.confirm(`Are you sure you want to ban ${userToBan.username}?`)) return;
        try {
            await axios.post(`/api/admin/users/${userToBan.id}/ban`, {}, { headers: { Authorization: `Bearer ${authToken}` } });
            alert(`${userToBan.username} has been banned.`);
        } catch (err) {
            alert('Failed to ban user.');
        }
    };

    // ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    const handleVote = useCallback(async (targetType, targetId, value) => {
        if (!isLoggedIn) { alert('Please log in to vote.'); return; }
        try {
            await axios.post(`/api/votes/${targetType}s/${targetId}`, { value }, { headers: { Authorization: `Bearer ${authToken}` } });
            fetchPost();
        } catch (error) {
            alert(error.response?.data?.message || 'Failed to vote.'); fetchPost();
        }
    }, [isLoggedIn, authToken, fetchPost]);

    const handleDeletePost = async () => {
        if (!window.confirm('Are you sure you want to permanently delete this post?')) return;
        try {
            await axios.delete(`/api/posts/${postId}`, { headers: { Authorization: `Bearer ${authToken}` } });
            navigate('/posts');
        } catch (error) {
            alert(error.response?.data?.message || 'Failed to delete the post.');
        }
    };

    const handleCommentSubmit = async (event) => {
        event.preventDefault();
        if (!newCommentContent.trim()) return;
        setIsSubmittingComment(true);
        try {
            const response = await axios.post(`/api/posts/${postId}/comments`, { content: newCommentContent }, { headers: { Authorization: `Bearer ${authToken}` } });
            setPost(prev => ({ ...prev, comments: [...prev.comments, response.data] }));
            setNewCommentContent('');
        } catch (err) {
            alert(err.response?.data?.message || 'Failed to submit comment.');
        } finally {
            setIsSubmittingComment(false);
        }
    };

    const handleEditClick = (comment) => { setEditingCommentId(comment.id); setEditedContent(comment.content); };
    const handleCancelEdit = () => { setEditingCommentId(null); setEditedContent(''); };

    const handleUpdateSubmit = async (event) => {
        event.preventDefault();
        try {
            const response = await axios.patch(`/api/comments/${editingCommentId}`, { content: editedContent }, { headers: { Authorization: `Bearer ${authToken}` } });
            setPost(prev => ({ ...prev, comments: prev.comments.map(c => c.id === editingCommentId ? response.data : c) }));
            handleCancelEdit();
        } catch (err) {
            alert(err.response?.data?.message || 'Failed to update comment.');
        }
    };

    const handleDeleteComment = async (commentId) => {
        if (!window.confirm('Are you sure you want to delete this comment?')) return;
        try {
            await axios.delete(`/api/comments/${commentId}`, { headers: { Authorization: `Bearer ${authToken}` } });
            setPost(prev => ({ ...prev, comments: prev.comments.filter(c => c.id !== commentId) }));
        } catch (err) {
            alert(err.response?.data?.message || 'Failed to delete comment.');
        }
    };

    if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress size="lg" /></Box>;
    if (error) return <Alert color="danger">{error}</Alert>;
    if (!post) return <Typography>Post not found.</Typography>;

    const canManagePost = isLoggedIn && currentUser?.id === post?.author?.id;
    const isAdmin = currentUser && ['ADMIN', 'MODERATOR', 'OWNER'].includes(currentUser.rank);

    return (
        <Box>
            {/* --- –ò–ó–ú–ï–ù–ï–ù–û: –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∫–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥" --- */}
            <Button variant="plain" startDecorator={<ArrowBackIcon />} onClick={() => navigate('/posts')} sx={{ mb: 2, ml: -1 }}>
                {!isMobile && 'Back to All Posts'}
            </Button>

            <Sheet variant="outlined" sx={{ p: { xs: 2, sm: 3 }, borderRadius: 'md', mb: 4 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
                    {post.author ? <JoyLink component={RouterLink} to={`/users/${post.author.profile_slug || post.author.id}`}><Avatar src={constructImageUrl(post.author?.pfp_url)}>{post.author.username.charAt(0)}</Avatar></JoyLink> : <Avatar>?</Avatar>}
                    <Box sx={{ flexGrow: 1 }}>
                        <Typography level="title-md">
                            {post.author ? (
                                // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –¶–≤–µ—Ç –Ω–∏–∫–∞ –∞–≤—Ç–æ—Ä–∞ –ø–æ—Å—Ç–∞ ---
                                <JoyLink component={RouterLink} to={`/users/${post.author.profile_slug || post.author.id}`} sx={{ color: post.author.rank?.display_color }}>
                                    {post.author.username}
                                </JoyLink>
                            ) : 'Anonymous'}
                        </Typography>
                        <Typography level="body-xs">Posted on {new Date(post.created_at).toLocaleDateString()}</Typography>
                    </Box>
                    {(canManagePost || isAdmin) && (
                        <Box sx={{ ml: 'auto' }}>
                            <Dropdown>
                                <MenuButton slots={{ root: IconButton }} slotProps={{ root: { variant: 'plain', color: 'neutral' } }}><MoreVertIcon /></MenuButton>
                                <Menu>
                                    {canManagePost && <MenuItem onClick={() => navigate(`/posts/${post.id}/edit`)}><EditIcon /> Edit Post</MenuItem>}
                                    {(canManagePost || isAdmin) && <MenuItem color="danger" onClick={handleDeletePost}><DeleteForeverIcon /> Delete Post</MenuItem>}
                                    {isAdmin && !canManagePost && <MenuItem color="danger" onClick={() => handleBanUser(post.author)}><BlockIcon /> Ban Author</MenuItem>}
                                </Menu>
                            </Dropdown>
                        </Box>
                    )}
                </Box>

                {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ --- */}
                <Typography level={{ xs: 'h2', sm: 'h1' }} component="h1" sx={{ mb: 2, wordBreak: 'break-all' }}>
                    {post.title}
                </Typography>

                {/* --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å –¥–ª—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ --- */}
                <Typography level="body-lg" sx={{ whiteSpace: 'pre-wrap', mb: 3, wordBreak: 'break-all' }}>
                    {post.content}
                </Typography>

                <VoteButtons initialLikes={post.likes} initialDislikes={post.dislikes} currentUserVote={post.currentUserVote} onVote={(value) => handleVote('post', post.id, value)} disabled={!isLoggedIn} />
            </Sheet>

            <Box>
                <Typography level={{ xs: 'h3', sm: 'h2' }} component="h2" sx={{ mb: 2 }}>Comments ({post.comments?.length || 0})</Typography>
                {isLoggedIn ? (
                    <Box component="form" onSubmit={handleCommentSubmit} sx={{ mb: 3 }}>
                        <Textarea placeholder="Write a comment..." minRows={3} value={newCommentContent} onChange={(e) => setNewCommentContent(e.target.value)} sx={{ mb: 1 }} />
                        <Button type="submit" loading={isSubmittingComment} endDecorator={<SendIcon />} sx={{ width: { xs: '100%', sm: 'auto' } }}>Submit Comment</Button>
                    </Box>
                ) : (<Typography sx={{ mb: 3 }}>Please <JoyLink component={NavLink} to="/login">log in</JoyLink> to leave a comment.</Typography>)}

                <List sx={{ borderRadius: 'sm', p: 0, border: '1px solid', borderColor: 'divider' }}>
                    {post.comments?.sort((a, b) => new Date(a.created_at) - new Date(b.created_at)).map((comment, index) => {
                        const canManageComment = isLoggedIn && (currentUser?.id === comment?.author?.id || isAdmin);
                        const isEditing = editingCommentId === comment.id;
                        return (
                            <ListItem key={comment.id} sx={{ alignItems: 'flex-start', p: { xs: 1.5, sm: 2 }, '&:not(:last-of-type)': { borderBottom: '1px solid', borderColor: 'divider' } }}>
                                <ListItemDecorator sx={{ mr: { xs: 1, sm: 2 } }}>{comment.author ? <JoyLink component={RouterLink} to={`/users/${comment.author.profile_slug || comment.author.id}`}><Avatar src={constructImageUrl(comment.author?.pfp_url)} /> </JoyLink> : <Avatar />}</ListItemDecorator>
                                <ListItemContent>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <Typography level="title-sm">
                                            {comment.author ? (
                                                // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –¶–≤–µ—Ç –Ω–∏–∫–∞ –∞–≤—Ç–æ—Ä–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è ---
                                                <JoyLink component={RouterLink} to={`/users/${comment.author.profile_slug || comment.author.id}`} sx={{ color: comment.author.rank?.display_color }}>
                                                    {comment.author.username}
                                                </JoyLink>
                                            ) : 'Anonymous'}
                                        </Typography> 
                                        {canManageComment && !isEditing && (
                                            <Dropdown><MenuButton slots={{ root: IconButton }} slotProps={{ root: { variant: 'plain', color: 'neutral', size: 'sm' } }}><MoreVertIcon /></MenuButton>
                                                <Menu size="sm">
                                                    {currentUser?.id === comment?.author?.id && <MenuItem onClick={() => handleEditClick(comment)}><EditIcon /> Edit</MenuItem>}
                                                    <MenuItem onClick={() => handleDeleteComment(comment.id)} color="danger"><DeleteForeverIcon /> Delete</MenuItem>
                                                    {isAdmin && currentUser?.id !== comment?.author?.id && <MenuItem color="danger" onClick={() => handleBanUser(comment.author)}><BlockIcon /> Ban Author</MenuItem>}
                                                </Menu>
                                            </Dropdown>
                                        )}
                                    </Box>
                                    {isEditing ? (
                                        <Box component="form" onSubmit={handleUpdateSubmit} sx={{ mt: 1 }}>
                                            <Textarea minRows={2} value={editedContent} onChange={(e) => setEditedContent(e.target.value)} sx={{ mb: 1 }} />
                                            <Stack direction="row" spacing={1}><Button type="submit" size="sm">Save</Button><Button size="sm" variant="outlined" color="neutral" onClick={handleCancelEdit}>Cancel</Button></Stack>
                                        </Box>
                                    ) : (<Typography level="body-md" sx={{ mt: 0.5, mb: 1.5, whiteSpace: 'pre-wrap' }}>{comment.content}</Typography>)}
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <VoteButtons initialScore={comment.score} currentUserVote={comment.currentUserVote} onVote={(value) => handleVote('comment', comment.id, value)} disabled={!isLoggedIn} />
                                        <Typography level="body-xs" sx={{ color: 'text.tertiary' }}>{new Date(comment.created_at).toLocaleString([], { dateStyle: 'short', timeStyle: 'short' })}</Typography>
                                    </Box>
                                </ListItemContent>
                            </ListItem>
                        );
                    })}
                </List>
            </Box>
        </Box>
    );
}

export default SinglePostPage;
--- END FILE: frontend/src/pages/SinglePostPage.js ---



--- START FILE: frontend/src/theme.js ---

// src/theme.js
import { extendTheme } from '@mui/joy/styles';
import joyColors from '@mui/joy/colors';

const monochromeDarkTheme = extendTheme({
  colorSchemes: {
    light: {
      palette: {
        // ...
      },
    },
    dark: {
      palette: {
        primary: {
          50: joyColors.grey[50],
          100: joyColors.grey[100],
          200: joyColors.grey[200],
          300: joyColors.grey[300],
          400: joyColors.grey[400],
          500: joyColors.grey[500],
          600: joyColors.grey[600],
          700: joyColors.grey[700],
          800: joyColors.grey[800],
          900: joyColors.grey[900],
          solidBg: 'var(--joy-palette-primary-700)',
          solidHoverBg: 'var(--joy-palette-primary-600)',
          solidActiveBg: 'var(--joy-palette-primary-500)',
          solidColor: 'var(--joy-palette-primary-200)',

          outlinedBorder: 'var(--joy-palette-primary-500)',
          outlinedColor: 'var(--joy-palette-primary-200)',
          outlinedHoverBg: 'var(--joy-palette-neutral-800)',
          outlinedActiveBg: 'var(--joy-palette-neutral-700)',

          plainColor: 'var(--joy-palette-primary-300)',
          plainHoverBg: 'var(--joy-palette-neutral-800)',
          plainActiveBg: 'var(--joy-palette-neutral-700)',

          softColor: 'var(--joy-palette-primary-200)',
          softBg: 'var(--joy-palette-primary-800)',
          softHoverBg: 'var(--joy-palette-primary-700)',
          softActiveBg: 'var(--joy-palette-primary-600)',
        },
        neutral: {
          ...joyColors.grey, 
          plainColor: 'var(--joy-palette-neutral-200)',
          plainHoverBg: 'var(--joy-palette-neutral-800)',
          plainActiveBg: 'var(--joy-palette-neutral-700)',
        },
        background: {
          body: 'var(--joy-palette-neutral-900)',
          surface: 'var(--joy-palette-neutral-800)',
          level1: 'var(--joy-palette-neutral-800)',
          level2: 'var(--joy-palette-neutral-700)',
          level3: 'var(--joy-palette-neutral-600)',
          tooltip: 'var(--joy-palette-neutral-600)',
        },
        text: {
          primary: 'var(--joy-palette-neutral-100)',
          secondary: 'var(--joy-palette-neutral-300)',
          tertiary: 'var(--joy-palette-neutral-400)',
          icon: 'var(--joy-palette-neutral-300)',
        },
        divider: 'var(--joy-palette-neutral-700)',
        focusVisible: 'var(--joy-palette-primary-500)',
      },
    },
  },
});

export default monochromeDarkTheme;
--- END FILE: frontend/src/theme.js ---



--- START FILE: frontend/src/utils/url.js ---

// frontend/src/utils/url.js

// URL –Ω–∞—à–µ–≥–æ –±—ç–∫–µ–Ω–¥–∞ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
const FULL_API_URL = process.env.REACT_APP_FULL_API_URL || 'http://localhost:3001';

/**
 * –°–æ–∑–¥–∞–µ—Ç –ø–æ–ª–Ω—ã–π URL –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏.
 * @param {string | null} relativePath - –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, /uploads/avatars/123.jpg).
 * @returns {string | null} –ü–æ–ª–Ω—ã–π URL –∏–ª–∏ null, –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω.
 */
export const constructImageUrl = (relativePath) => {
  // –ï—Å–ª–∏ –ø—É—Ç–∏ –Ω–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null (–∏–ª–∏ –º–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –ø—É—Ç—å –∫ –∑–∞–≥–ª—É—à–∫–µ)
  if (!relativePath) {
    return null;
  }

  // –ï—Å–ª–∏ —ç—Ç–æ 'blob:' URL (–¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞), –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –∫–∞–∫ –µ—Å—Ç—å.
  if (relativePath.startsWith('blob:')) {
    return relativePath;
  }

  // –í –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö —Å—Ç—Ä–æ–∏–º –ø–æ–ª–Ω—ã–π URL
  return `${FULL_API_URL}${relativePath}`;
};
--- END FILE: frontend/src/utils/url.js ---



--- START FILE: frontend/public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>FlameWall</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

--- END FILE: frontend/public/index.html ---



--- START FILE: frontend/public/manifest.json ---

{
  "short_name": "FlameWall",
  "name": "FlameWall Community",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#0D1117",
  "background_color": "#0D1117"
}
--- END FILE: frontend/public/manifest.json ---



--- START FILE: frontend/public/robots.txt ---

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

--- END FILE: frontend/public/robots.txt ---



--- START FILE: frontend/public/service-worker-prod.js ---

// ServiceWorker-Worker.js
// –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–µ—Ä—Å–∏—é –∫–µ—à–∞. –≠—Ç–æ –°–ò–ì–ù–ê–õ –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–∞, —á—Ç–æ SW –æ–±–Ω–æ–≤–∏–ª—Å—è.
const CACHE_NAME = 'flamewall-cache-v4'; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–µ—Ä—Å–∏—é!
const urlsToCache = [
  '/',
  '/index.html',
  '/manifest.json'
];

// –£—Å—Ç–∞–Ω–æ–≤–∫–∞: –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º—Å—è
self.addEventListener('install', event => {
  self.skipWaiting();
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
  );
});

// –ê–∫—Ç–∏–≤–∞—Ü–∏—è: —á–∏—Å—Ç–∏–º —Å—Ç–∞—Ä—ã–π –∫–µ—à –∏ –±–µ—Ä–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      ).then(() => {
        // --- –ì–õ–ê–í–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï ---
        // –ü–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ –∫–µ—à–∞, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –≤–∫–ª–∞–¥–∫–∏ —Å–∞–π—Ç–∞.
        // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–∏–¥–∏—Ç –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é.
        return self.clients.claim().then(() => {
            self.clients.matchAll().then(clients => {
                clients.forEach(client => client.navigate(client.url));
            });
        });
      });
    })
  );
});

// –ü–µ—Ä–µ—Ö–≤–∞—Ç –∑–∞–ø—Ä–æ—Å–æ–≤: –æ—Ç–¥–∞–µ–º –∏–∑ –∫–µ—à–∞, –µ—Å–ª–∏ –µ—Å—Ç—å.
// API –∑–∞–ø—Ä–æ—Å—ã –Ω–µ –∫–µ—à–∏—Ä—É–µ–º.
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/') || event.request.url.includes('/socket.io/')) {
    return;
  }
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–µ—à–µ, –æ—Ç–¥–∞–µ–º –∏–∑ –∫–µ—à–∞
        if (response) {
          return response;
        }
        // –ò–Ω–∞—á–µ –∏–¥–µ–º –≤ —Å–µ—Ç—å, –ø–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç, –∫–ª–∞–¥–µ–º –≤ –∫–µ—à –∏ –æ—Ç–¥–∞–µ–º
        return fetch(event.request).then(
          networkResponse => {
            if(!networkResponse || networkResponse.status !== 200 || networkResponse.type !== 'basic') {
              return networkResponse;
            }
            const responseToCache = networkResponse.clone();
            caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, responseToCache);
              });
            return networkResponse;
          }
        );
      })
  );
});
--- END FILE: frontend/public/service-worker-prod.js ---



--- START FILE: frontend/nginx/nginx.conf ---

# root Flamewall/frontend/nginx/nginx.conf
server {
    listen 80;
    server_name flamewall.online;

    # –Ø–≤–Ω–æ –≤–∫–ª—é—á–∞–µ–º ETag –¥–ª—è –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤
    etag on;

    # –ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—á–Ω—ã—Ö –∞—Å—Å–µ—Ç–æ–≤ (JS, CSS, –∫–∞—Ä—Ç–∏–Ω–∫–∏)
    # –£ –Ω–∏—Ö –µ—Å—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ö—ç—à –≤ –∏–º–µ–Ω–∏, –ø–æ—ç—Ç–æ–º—É –∏—Ö –º–æ–∂–Ω–æ –∫–µ—à–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞.
    location ~* \.(?:css|js|jpg|jpeg|png|gif|svg|ico|webp|ttf|woff|woff2)$ {
        root /usr/share/nginx/html;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # –ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –≤—Å–µ—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤ React
    location / {
        root   /usr/share/nginx/html;
        index  index.html;
        try_files $uri $uri/ /index.html;

        # --- –°–ê–ú–´–ï –ê–ì–†–ï–°–°–ò–í–ù–´–ï –ó–ê–ì–û–õ–û–í–ö–ò –î–õ–Ø –ó–ê–ü–†–ï–¢–ê –ö–ï–®–ê ---
        # –ì–æ–≤–æ—Ä–∏–º "–Ω–µ —Ö—Ä–∞–Ω–∏—Ç—å –Ω–∏–≥–¥–µ –∏ –Ω–∏–∫–æ–≥–¥–∞"
        add_header Cache-Control 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0';
        # –î–ª—è —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
        add_header Pragma 'no-cache';
        # –ì–æ–≤–æ—Ä–∏–º, —á—Ç–æ —Å—Ä–æ–∫ –≥–æ–¥–Ω–æ—Å—Ç–∏ —É–∂–µ –∏—Å—Ç–µ–∫
        expires 0;
        # –ó–∞–ø—Ä–µ—â–∞–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä–∞—Ö
        add_header 'Vary' 'Accept-Encoding';
    }
}
--- END FILE: frontend/nginx/nginx.conf ---



--- START FILE: nginx/nginx.conf ---

# root Flamewall//nginx/nginx.conf
events {}

http {
    server {
        listen 80;
        server_name your_domain.com; # –í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –±—É–¥–µ—Ç —Ç–≤–æ–π –¥–æ–º–µ–Ω

        # –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –∫ API (/api/...) –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –±—ç–∫–µ–Ω–¥
        location /api/ {
            proxy_pass http://backend:3000; # 'backend' - –∏–º—è —Å–µ—Ä–≤–∏—Å–∞ –∏–∑ docker-compose
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            # –î–ª—è —Ä–∞–±–æ—Ç—ã WebSocket
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
        location / {
            proxy_pass http://frontend:5173; # 'frontend' - –∏–º—è —Å–µ—Ä–≤–∏—Å–∞ –∏–∑ docker-compose
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
--- END FILE: nginx/nginx.conf ---



--- START FILE: nginx/nginx.prod.conf ---

events {
    worker_connections 1024;
}

http {
    server {
        listen 80;
        listen [::]:80;
        server_name flamewall.xyz www.flamewall.xyz;
        location ~ /.well-known/acme-challenge/ { allow all; root /var/www/certbot; }
        location / { return 301 https://$host$request_uri; }
    }

    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name flamewall.xyz www.flamewall.xyz;
        
        resolver 127.0.0.11 valid=10s;
        ssl_certificate /etc/letsencrypt/live/flamewall.xyz/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/flamewall.xyz/privkey.pem;

        # –ë–ª–æ–∫ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö API –∑–∞–ø—Ä–æ—Å–æ–≤
        location /api/ {
            set $backend_upstream http://backend:3000;
            proxy_pass $backend_upstream; # –î–æ–±–∞–≤–ª—è–µ–º /api/ –≤ –∫–æ–Ω–µ—Ü
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # –ë–ª–æ–∫ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        location /socket.io/ {
            set $backend_upstream http://backend:3000;
            proxy_pass $backend_upstream;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # –ë–ª–æ–∫ –¥–ª—è –≤—Å–µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ (—Ñ—Ä–æ–Ω—Ç–µ–Ω–¥)
        location / {
            set $frontend_upstream http://frontend:80;
            proxy_pass $frontend_upstream;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        location /uploads/ {
            alias /usr/share/nginx/html/uploads/;
            access_log off;
            expires 7d;
            add_header Cache-Control "public";
        }
    }
}
--- END FILE: nginx/nginx.prod.conf ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/ApiClient.java ---

package com.flamewall.bridge;

import okhttp3.*;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import org.jetbrains.annotations.NotNull;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class ApiClient {

    private final BridgePlugin plugin;
    private final OkHttpClient httpClient;
    private final String baseUrl;
    private final String apiKey;

    public ApiClient(BridgePlugin plugin) {
        this.plugin = plugin;
        this.httpClient = new OkHttpClient();
        this.baseUrl = plugin.getConfig().getString("api-base-url", "http://localhost:3000");
        this.apiKey = plugin.getConfig().getString("plugin-secret-key");
    }

    // --- –ú–ï–¢–û–î–´ –î–õ–Ø –°–ò–°–¢–ï–ú–´ –î–†–£–ó–ï–ô ---

    public void sendFriendRequest(Player sender, String receiverName) {
        try {
            JSONObject jsonBody = new JSONObject();
            jsonBody.put("requesterUuid", sender.getUniqueId().toString());
            jsonBody.put("receiverName", receiverName);
            RequestBody body = RequestBody.create(jsonBody.toString(), MediaType.get("application/json; charset=utf-8"));
            Request request = new Request.Builder()
                    .url(baseUrl + "/api/friendships/from-plugin/add")
                    .header("x-api-key", apiKey)
                    .post(body)
                    .build();
            httpClient.newCall(request).enqueue(new HttpCallback(sender, "Friend request sent to " + receiverName + "!"));
        } catch (JSONException e) {
            handlePluginError(sender, "Could not create JSON body for friend request", e);
        }
    }

    public void removeFriend(Player sender, String friendToRemoveName) {
        try {
            JSONObject jsonBody = new JSONObject();
            jsonBody.put("removerUuid", sender.getUniqueId().toString());
            jsonBody.put("friendToRemoveName", friendToRemoveName);
            RequestBody body = RequestBody.create(jsonBody.toString(), MediaType.get("application/json; charset=utf-8"));
            Request request = new Request.Builder()
                    .url(baseUrl + "/api/friendships/from-plugin/remove")
                    .header("x-api-key", apiKey)
                    .delete(body)
                    .build();
            httpClient.newCall(request).enqueue(new HttpCallback(sender, friendToRemoveName + " has been removed from your friends list."));
        } catch (JSONException e) {
            handlePluginError(sender, "Could not create JSON body for friend removal", e);
        }
    }

    public void getFriendsList(Player sender) {
        Request request = new Request.Builder()
                .url(baseUrl + "/api/friendships/from-plugin/list/" + sender.getUniqueId().toString())
                .header("x-api-key", apiKey)
                .get()
                .build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                handleApiFailure(sender, e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                if (!response.isSuccessful()) {
                    handleApiError(sender, response);
                    return;
                }
                try (ResponseBody responseBody = response.body()) {
                    String responseString = responseBody.string();
                    JSONArray friendsArray = new JSONArray(responseString);
                    runOnMainThread(() -> {
                        sender.sendMessage(ChatColor.GOLD + "--- Your Friends (" + friendsArray.length() + ") ---");
                        if (friendsArray.length() == 0) {
                            sender.sendMessage(ChatColor.GRAY + "Your friends list is empty. Use /flame friend add <player>");
                        } else {
                            for (int i = 0; i < friendsArray.length(); i++) {
                                try {
                                    sender.sendMessage(ChatColor.AQUA + "- " + friendsArray.getString(i));
                                } catch (JSONException e) {
                                    plugin.getLogger().warning("Could not get friend name at index " + i + ": " + e.getMessage());
                                }
                            }
                        }
                    });
                } catch (IOException | JSONException e) {
                    plugin.getLogger().severe("Failed to parse friends list JSON from API: " + e.getMessage());
                    runOnMainThread(() -> sender.sendMessage(ChatColor.RED + "Error: Could not read response from the website."));
                } finally {
                    response.close();
                }
            }
        });
    }

    // --- –ú–ï–¢–û–î–´ –î–õ–Ø –ú–ê–ì–ê–ó–ò–ù–ê ---

    public void fetchAndExecutePendingCommands() {
        if (apiKey == null || apiKey.isEmpty()) {
            plugin.getLogger().warning("Cannot fetch pending commands: plugin-secret-key is not set.");
            return;
        }

        Request request = new Request.Builder()
                .url(baseUrl + "/api/shop/pending-commands")
                .header("x-api-key", apiKey)
                .get()
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                plugin.getLogger().warning("Could not fetch pending commands from website: " + e.getMessage());
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                if (!response.isSuccessful()) {
                    plugin.getLogger().warning("Failed to fetch pending commands, API response code: " + response.code());
                    response.close();
                    return;
                }
                try (ResponseBody responseBody = response.body()) {
                    String responseString = responseBody.string();
                    JSONArray commands = new JSONArray(responseString);
                    if (commands.length() == 0) return;

                    plugin.getLogger().info("Found " + commands.length() + " pending command(s) from website. Executing...");
                    List<Integer> executedIds = new ArrayList<>();

                    for (int i = 0; i < commands.length(); i++) {
                        JSONObject cmdObj = commands.getJSONObject(i);
                        final String commandStr = cmdObj.getString("command");
                        final int commandId = cmdObj.getInt("id");

                        Bukkit.getScheduler().runTask(plugin, () -> {
                            plugin.getLogger().info("Executing command ID " + commandId + ": " + commandStr);
                            Bukkit.dispatchCommand(Bukkit.getConsoleSender(), commandStr);
                            Pattern pattern = Pattern.compile("user\\s+(\\S+)");
                            Matcher matcher = pattern.matcher(commandStr);
                            if (matcher.find()) {
                                String playerName = matcher.group(1);
                                // –ò—Å–ø–æ–ª—å–∑—É–µ–º getOfflinePlayer, —Ç–∞–∫ –∫–∞–∫ –∏–≥—Ä–æ–∫ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ –≤ —Å–µ—Ç–∏
                                OfflinePlayer targetPlayer = Bukkit.getOfflinePlayer(playerName);

                                // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –¥–ª—è —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Å –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π,
                                // —á—Ç–æ–±—ã –¥–∞—Ç—å –≤—Ä–µ–º—è –∫–æ–º–∞–Ω–¥–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–∏–º–µ–Ω–∏—Ç—å—Å—è.
                                new BukkitRunnable() {
                                    @Override
                                    public void run() {
                                        plugin.getLogger().info("Triggering immediate rank sync for " + playerName + " after command execution.");
                                        plugin.getPlayerListener().syncSinglePlayer(targetPlayer);
                                    }
                                }.runTaskLater(plugin, 20L); // 20 —Ç–∏–∫–æ–≤ = 1 —Å–µ–∫—É–Ω–¥–∞
                            }
                        });
                        executedIds.add(commandId);
                    }

                    if (!executedIds.isEmpty()) {
                        clearExecutedCommands(executedIds);
                    }
                } catch (Exception e) {
                    plugin.getLogger().severe("Failed to process pending commands: " + e.getMessage());
                } finally {
                    response.close();
                }
            }
        });
    }

    private void clearExecutedCommands(List<Integer> ids) {
        try {
            JSONObject jsonBody = new JSONObject();
            jsonBody.put("commandIds", new JSONArray(ids));
            RequestBody body = RequestBody.create(jsonBody.toString(), MediaType.get("application/json; charset=utf-8"));

            Request request = new Request.Builder()
                    .url(baseUrl + "/api/shop/clear-pending-commands")
                    .header("x-api-key", apiKey)
                    .post(body)
                    .build();

            httpClient.newCall(request).enqueue(new Callback() {
                @Override public void onFailure(@NotNull Call call, @NotNull IOException e) {
                    plugin.getLogger().warning("Failed to confirm executed commands to website: " + e.getMessage());
                }
                @Override public void onResponse(@NotNull Call call, @NotNull Response response) {
                    if (response.isSuccessful()) {
                        plugin.getLogger().info("Successfully confirmed execution of " + ids.size() + " command(s).");
                    }
                    response.close();
                }
            });
        } catch (Exception e) {
            plugin.getLogger().severe("Failed to build request for clearing executed commands: " + e.getMessage());
        }
    }


    // --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ---

    private void runOnMainThread(Runnable task) {
        Bukkit.getScheduler().runTask(plugin, task);
    }

    private void handlePluginError(Player sender, String logMessage, Exception e) {
        plugin.getLogger().severe(logMessage + ": " + e.getMessage());
        runOnMainThread(() -> sender.sendMessage(ChatColor.RED + "An internal plugin error occurred."));
    }

    private void handleApiFailure(Player player, IOException e) {
        plugin.getLogger().severe("Failed to send API request: " + e.getMessage());
        runOnMainThread(() -> player.sendMessage(ChatColor.RED + "Error: Could not connect to the website API."));
    }

    private void handleApiError(Player player, Response response) {
        try (ResponseBody responseBody = response.body()) {
            String errorBody = responseBody.string();
            JSONObject errorJson = new JSONObject(errorBody);
            String message = errorJson.optString("message", "An unknown error occurred (" + response.code() + ")");
            runOnMainThread(() -> player.sendMessage(ChatColor.RED + "Error: " + message));
        } catch (IOException | JSONException e) {
            plugin.getLogger().warning("Could not parse error response from API. Body was not valid JSON or network error occurred.");
            runOnMainThread(() -> player.sendMessage(ChatColor.RED + "An unknown error occurred while processing the server response."));
        } finally {
            if (response != null) response.close();
        }
    }

    private class HttpCallback implements Callback {
        private final Player sender;
        private final String successMessage;

        public HttpCallback(Player sender, String successMessage) {
            this.sender = sender;
            this.successMessage = successMessage;
        }

        @Override
        public void onFailure(@NotNull Call call, @NotNull IOException e) {
            handleApiFailure(sender, e);
        }

        @Override
        public void onResponse(@NotNull Call call, @NotNull Response response) {
            if (response.isSuccessful()) {
                runOnMainThread(() -> sender.sendMessage(ChatColor.GREEN + successMessage));
            } else {
                handleApiError(sender, response);
            }
        }
    }

    public void acceptFriendRequest(Player player, int requestId) {
        try {
            JSONObject jsonBody = new JSONObject();
            jsonBody.put("responderUuid", player.getUniqueId().toString());
            jsonBody.put("requestId", requestId);
            RequestBody body = RequestBody.create(jsonBody.toString(), MediaType.get("application/json; charset=utf-8"));

            Request request = new Request.Builder()
                    .url(baseUrl + "/api/friendships/from-plugin/accept")
                    .header("x-api-key", apiKey)
                    .post(body)
                    .build();

            httpClient.newCall(request).enqueue(new HttpCallback(player, "Friend request accepted!"));
        } catch (JSONException e) {
            handlePluginError(player, "Could not create JSON for accepting friend request", e);
        }
    }

    // --- –ù–û–í–´–ô –ú–ï–¢–û–î ---
    public void denyFriendRequest(Player player, int requestId) {
        try {
            JSONObject jsonBody = new JSONObject();
            jsonBody.put("responderUuid", player.getUniqueId().toString());
            jsonBody.put("requestId", requestId);
            RequestBody body = RequestBody.create(jsonBody.toString(), MediaType.get("application/json; charset=utf-8"));

            Request request = new Request.Builder()
                    .url(baseUrl + "/api/friendships/from-plugin/deny")
                    .header("x-api-key", apiKey)
                    .post(body)
                    .build();

            httpClient.newCall(request).enqueue(new HttpCallback(player, "Friend request denied."));
        } catch (JSONException e) {
            handlePluginError(player, "Could not create JSON for denying friend request", e);
        }
    }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/ApiClient.java ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/BridgePlugin.java ---

package com.flamewall.bridge;

import io.socket.client.IO;
import io.socket.client.Socket;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.api.chat.hover.content.Text;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.json.JSONException;
import org.json.JSONObject;

import java.net.URI;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.Map; // <-- –î–û–ë–ê–í–õ–ï–ù–û
import java.util.concurrent.ConcurrentHashMap; // <-- –î–û–ë–ê–í–õ–ï–ù–û
public final class BridgePlugin extends JavaPlugin {

    private Socket socket;
    private ApiClient apiClient;
    private PrivateMessageManager messageManager;
    private List<String> commandPatterns; // <-- –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π List<String>
    private PlayerConnectionListener playerListener; // –•—Ä–∞–Ω–∏–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–ª—É—à–∞—Ç–µ–ª—è
    private final Map<UUID, Map<String, Integer>> pendingRequests = new ConcurrentHashMap<>();

    @Override
    public void onEnable() {
        getLogger().info("FlameWallBridge is enabling...");
        this.saveDefaultConfig();
        this.reloadConfig();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        this.messageManager = new PrivateMessageManager();
        this.apiClient = new ApiClient(this);
        this.playerListener = new PlayerConnectionListener(this);

        // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∞–≤–∏–ª—å–Ω–æ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ –ø–æ–ª–µ –∫–ª–∞—Å—Å–∞ ---
        this.commandPatterns = getConfig().getStringList("intercept-commands");
        getLogger().info("Loaded " + this.commandPatterns.size() + " command patterns to intercept.");

        // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥
        FlameCommand flameCommand = new FlameCommand(this);
        getCommand("flame").setExecutor(flameCommand);
        getCommand("flame").setTabCompleter(flameCommand);
        getCommand("link").setExecutor(new LinkCommand(this));

        // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å–ª—É—à–∞—Ç–µ–ª—è —Å–æ–±—ã—Ç–∏–π
        Bukkit.getPluginManager().registerEvents(this.playerListener, this);

        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä—É –∏ –∑–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
        connectToWebSocket();
        // startPendingCommandScheduler();
    }


    @Override
    public void onDisable() {
        if (socket != null && socket.connected()) {
            socket.disconnect();
        }
        getLogger().info("FlameWallBridge has been disabled.");
    }

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è –∑–∞–¥–∞—á—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫ –≤ –º–∞–≥–∞–∑–∏–Ω–µ.
     */
    private void startPendingCommandScheduler() {
        long interval = getConfig().getLong("shop.check-interval-seconds", 300) * 20L;
        new BukkitRunnable() {
            @Override
            public void run() {
                if (socket != null && socket.connected()) {
                    apiClient.fetchAndExecutePendingCommands();
                }
            }
        }.runTaskTimerAsynchronously(this, 200L, interval); // –ù–∞—á–∞—Ç—å —á–µ—Ä–µ–∑ 10 —Å–µ–∫, –ø–æ–≤—Ç–æ—Ä—è—Ç—å –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω
    }

    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å WebSocket-—Å–µ—Ä–≤–µ—Ä–æ–º.
     */
    private void connectToWebSocket() {
        try {
            // --- –®–ê–ì 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞–¥—Ä–µ—Å–∞ –∏ –∫–ª—é—á–∞ ---
            String url = getConfig().getString("api-base-url", "http://localhost:3001");
            URI serverUri = URI.create(url);

            String apiKey = getConfig().getString("plugin-secret-key");
            if (apiKey == null || apiKey.isEmpty()) {
                getLogger().severe("CRITICAL: plugin-secret-key is not set in config.yml! Plugin will not work correctly.");
                return;
            }

            // --- –®–ê–ì 2: –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ü–∏–π –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ ---
            Map<String, List<String>> headers = new HashMap<>();
            headers.put("x-api-key", Collections.singletonList(apiKey));
            IO.Options options = IO.Options.builder()
                    .setExtraHeaders(headers)
                    .build();

            // --- –®–êG 3: –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–∫–µ—Ç–∞ —Å –≥–æ—Ç–æ–≤—ã–º–∏ –æ–ø—Ü–∏—è–º–∏ ---
            socket = IO.socket(serverUri, options);

            // --- –®–ê–ì 4: –ù–∞–≤–µ—à–∏–≤–∞–µ–º –≤—Å–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ---
            socket.on(Socket.EVENT_CONNECT, args -> {
                getLogger().info("Successfully connected to the website backend!");
                // –°—Ä–∞–∑—É –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–æ–∫—É–ø–æ–∫
                apiClient.fetchAndExecutePendingCommands();
            });

            socket.on(Socket.EVENT_DISCONNECT, args -> getLogger().warning("Disconnected from website backend. Reason: " + (args.length > 0 ? args[0] : "N/A")));
            socket.on(Socket.EVENT_CONNECT_ERROR, args -> getLogger().severe("Connection error: " + (args.length > 0 ? args[0] : "Unknown error")));

            socket.on("incomingFriendRequest", args -> handleEvent("incomingFriendRequest", args, this::handleIncomingFriendRequest));
            socket.on("linkStatus", args -> handleEvent("linkStatus", args, this::handleBackendMessage));
            socket.on("webPrivateMessage", args -> handleEvent("webPrivateMessage", args, this::handleWebMessage));
            socket.on("executeShopCommand", args -> handleEvent("executeShopCommand", args, this::handleShopCommand));

            socket.on("shop:new-command", args -> {
                getLogger().info("<<<<<<<<<<<<<<<<<<< SIGNAL RECEIVED! WebSocket IS WORKING! >>>>>>>>>>>>>>>>>>>>");
                apiClient.fetchAndExecutePendingCommands();
            });
            // --- –®–ê–ì 5: –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è ---
            socket.connect();
            getLogger().info("Attempting to connect to website backend at " + url + "...");

        } catch (Exception e) {
            getLogger().severe("Failed to initialize WebSocket connection: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π –æ—Ç —Å–æ–∫–µ—Ç–∞.
     */
    private void handleEvent(String eventName, Object[] args, java.util.function.Consumer<JSONObject> handler) {
        if (args.length > 0 && args[0] instanceof JSONObject) {
            handler.accept((JSONObject) args[0]);
        } else {
            getLogger().warning("Received malformed '" + eventName + "' event from backend.");
        }
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –ø—Ä–∏—à–µ–¥—à–∏–µ —Å —Å–∞–π—Ç–∞.
     */
    private void handleWebMessage(JSONObject data) {
        Bukkit.getScheduler().runTask(this, () -> {
            if (!getConfig().getBoolean("display-web-messages-in-game", true)) return;
            try {
                Player recipientPlayer = Bukkit.getPlayer(UUID.fromString(data.getString("recipientUuid")));
                if (recipientPlayer != null && recipientPlayer.isOnline()) {
                    String senderUsername = data.getString("senderUsername");
                    String content = data.getString("content");

                    TextComponent messageComponent = new TextComponent(ChatColor.GRAY + "[WEB] " + senderUsername + " ¬ª " + content);
                    messageComponent.setClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/flame msg " + senderUsername + " "));
                    messageComponent.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text(ChatColor.AQUA + "Click to reply to " + senderUsername)));
                    recipientPlayer.spigot().sendMessage(messageComponent);
                }
            } catch (Exception e) {
                getLogger().warning("Could not parse webPrivateMessage: " + e.getMessage());
            }
        });
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç —Å–∞–π—Ç–∞ –æ —Å—Ç–∞—Ç—É—Å–µ –ø—Ä–∏–≤—è–∑–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞.
     */
    private void handleBackendMessage(JSONObject data) {
        Bukkit.getScheduler().runTask(this, () -> {
            try {
                Player player = Bukkit.getPlayer(UUID.fromString(data.getString("minecraftUuid")));
                if (player != null && player.isOnline()) {
                    if (data.getBoolean("success")) {
                        player.sendMessage(ChatColor.GREEN + "Success! Your account is now linked to the website profile: " + data.getString("websiteUsername"));
                        // –°—Ä–∞–∑—É –ø–æ—Å–ª–µ –ø—Ä–∏–≤—è–∑–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Ä–∞–Ω–≥
                        playerListener.syncSinglePlayer(player);
                    } else {
                        player.sendMessage(ChatColor.RED + "Linking failed: " + data.getString("error"));
                    }
                }
            } catch (JSONException e) {
                getLogger().warning("Could not parse linkStatus message: " + e.getMessage());
            }
        });
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –Ω–∞ –≤—ã–¥–∞—á—É —Ç–æ–≤–∞—Ä–∞ –∏–∑ –º–∞–≥–∞–∑–∏–Ω–∞ (–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –ø–æ–∫—É–ø–∫–∞).
     */
    private void handleShopCommand(JSONObject data) {
        try {
            String command = data.getString("command");
            getLogger().info("Executing immediate shop command from website: " + command);
            Bukkit.getScheduler().runTask(this, () -> Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command));
        } catch (Exception e) {
            getLogger().warning("Could not parse executeShopCommand: " + e.getMessage());
        }
    }

    /**
     * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –Ω–∞ –±—ç–∫–µ–Ω–¥ —á–µ—Ä–µ–∑ WebSocket.
     */
    public void sendJsonPayload(String eventName, JSONObject payload) {
        if (socket != null && socket.connected()) {
            socket.emit(eventName, payload);
        } else {
            getLogger().warning("WebSocket is not connected. Cannot send data for event: " + eventName);
        }
    }

    private void handleIncomingFriendRequest(JSONObject data) {
        Bukkit.getScheduler().runTask(this, () -> {
            try {
                String requesterName = data.getString("requesterName");
                UUID receiverUuid = UUID.fromString(data.getString("receiverUuid"));
                int requestId = data.getInt("requestId"); // <-- –ü–æ–ª—É—á–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞

                Player receiverPlayer = Bukkit.getPlayer(receiverUuid);
                if (receiverPlayer != null && receiverPlayer.isOnline()) {

                    // --- –ü–ï–†–ï–í–ï–î–ï–ù–û –ù–ê –ê–ù–ì–õ–ò–ô–°–ö–ò–ô ---
                    pendingRequests.computeIfAbsent(receiverUuid, k -> new HashMap<>()).put(requesterName.toLowerCase(), requestId);

                    receiverPlayer.sendMessage("¬ße------------------------------------------");
                    receiverPlayer.sendMessage("¬ß6[!] ¬ßePlayer ¬ßf" + requesterName + "¬ße wants to add you as a friend!");

                    // –°–æ–∑–¥–∞–µ–º –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
                    TextComponent acceptButton = new TextComponent("¬ßa[ACCEPT]");
                    acceptButton.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/flame friend accept " + requesterName));
                    acceptButton.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text("¬ßaClick to accept the friend request")));

                    TextComponent denyButton = new TextComponent("¬ßc[DENY]");
                    denyButton.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/flame friend deny " + requesterName));
                    denyButton.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text("¬ßcClick to deny the friend request")));

                    TextComponent message = new TextComponent("    ");
                    message.addExtra(acceptButton);
                    message.addExtra("    "); // –ü—Ä–æ–±–µ–ª –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏
                    message.addExtra(denyButton);

                    receiverPlayer.spigot().sendMessage(message);
                    receiverPlayer.sendMessage("¬ße------------------------------------------");
                }

            } catch(Exception e) {
                getLogger().warning("Could not parse incomingFriendRequest: " + e.getMessage());
            }
        });
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ –¥—Ä—É–≥–∏—Ö –∫–ª–∞—Å—Å–æ–≤
    public ApiClient getApiClient() { return apiClient; }
    public PrivateMessageManager getMessageManager() { return messageManager; }
    public List<String> getCommandPatterns() { return commandPatterns; }
    public Map<UUID, Map<String, Integer>> getPendingRequests() {
        return pendingRequests;
    }
    public PlayerConnectionListener getPlayerListener() { return playerListener; }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/BridgePlugin.java ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/FlameCommand.java ---

package com.flamewall.bridge;

import me.clip.placeholderapi.PlaceholderAPI;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.OfflinePlayer;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabCompleter;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.json.JSONObject;
import org.bukkit.scheduler.BukkitRunnable; // <-- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï

import java.util.*; // <-- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

public class FlameCommand implements CommandExecutor, TabCompleter {

    private final BridgePlugin plugin;

    public FlameCommand(BridgePlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("This command can only be used by a player.");
            return true;
        }
        Player player = (Player) sender;

        if (args.length == 0) {
            sendHelpMessage(player);
            return true;
        }

        String subCommand = args[0].toLowerCase();
        String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

        if (subCommand.equals("sync-ranks")) {
            handleSyncRanksCommand(sender, subArgs);
            return true;
        }

        if (!(sender instanceof Player)) {
            sender.sendMessage("This command can only be used by a player.");
            return true;
        }

        switch (subCommand) {
            case "msg":
                handleMessageCommand(player, subArgs);
                break;
            case "r":
            case "reply":
                handleReplyCommand(player, subArgs);
                break;
            case "friend":
                handleFriendCommand(player, subArgs);
                break;
            default:
                sendHelpMessage(player);
                break;
        }
        return true;
    }

    private void handleSyncRanksCommand(CommandSender sender, String[] args) {
        if (!sender.hasPermission("flamewall.admin.sync")) {
            sender.sendMessage(ChatColor.RED + "You do not have permission to use this command.");
            return;
        }
        if (args.length == 0) {
            sender.sendMessage(ChatColor.RED + "Usage: /flame sync-ranks <online|all>");
            return;
        }
        String mode = args[0].toLowerCase();
        if ("online".equals(mode)) {
            syncOnlinePlayers(sender);
        } else if ("all".equals(mode)) {
            syncAllPlayers(sender);
        } else {
            sender.sendMessage(ChatColor.RED + "Unknown mode. Use 'online' or 'all'.");
        }
    }

    private void syncOnlinePlayers(CommandSender sender) {
        sender.sendMessage(ChatColor.YELLOW + "Starting rank synchronization for all ONLINE players...");
        int syncedCount = 0;
        for (Player player : Bukkit.getOnlinePlayers()) {
            syncSinglePlayer(player);
            syncedCount++;
        }
        sender.sendMessage(ChatColor.GREEN + "Synchronization complete! Sent data for " + syncedCount + " players.");
    }

    private void syncAllPlayers(CommandSender sender) {
        sender.sendMessage(ChatColor.GOLD + "Starting FULL rank synchronization. This may take a while. Check the console for progress...");

        final Queue<OfflinePlayer> playerQueue = new LinkedList<>(Arrays.asList(Bukkit.getOfflinePlayers()));
        final int totalPlayers = playerQueue.size();
        final int batchSize = plugin.getConfig().getInt("sync-settings.batch-size", 50);
        final long delayTicks = plugin.getConfig().getLong("sync-settings.delay-ticks", 10);

        new BukkitRunnable() {
            private int processedCount = 0;
            @Override
            public void run() {
                if (playerQueue.isEmpty()) {
                    sender.sendMessage(ChatColor.GREEN + "Full synchronization complete! Processed " + totalPlayers + " players.");
                    plugin.getLogger().info("Full rank synchronization finished.");
                    this.cancel();
                    return;
                }

                if (processedCount > 0 && processedCount % 500 == 0) { // –õ–æ–≥ –∫–∞–∂–¥—ã–µ 500 –∏–≥—Ä–æ–∫–æ–≤
                    plugin.getLogger().info("Sync progress: " + processedCount + " / " + totalPlayers);
                }

                for (int i = 0; i < batchSize && !playerQueue.isEmpty(); i++) {
                    OfflinePlayer offlinePlayer = playerQueue.poll();
                    if (offlinePlayer != null) {
                        syncSinglePlayer(offlinePlayer);
                        processedCount++;
                    }
                }
            }
        }.runTaskTimerAsynchronously(plugin, 0L, delayTicks);
    }

    public void syncSinglePlayer(OfflinePlayer player) {
        if (Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null) {
            String rankPlaceholder = plugin.getConfig().getString("rank-sync.placeholder");
            if (rankPlaceholder == null || rankPlaceholder.isEmpty()) return;

            String rankName = PlaceholderAPI.setPlaceholders(player, rankPlaceholder);
            try {
                JSONObject payload = new JSONObject();
                payload.put("minecraftUuid", player.getUniqueId().toString());
                payload.put("rankName", rankName);
                plugin.sendJsonPayload("player:sync-rank", payload);
            } catch (Exception e) {
                plugin.getLogger().warning("Error syncing rank for " + player.getName() + ": " + e.getMessage());
            }
        }
    }

    private void handleMessageCommand(Player sender, String[] args) {
        if (args.length < 2) {
            sender.sendMessage(ChatColor.RED + "Usage: /flame msg <player> <message>");
            return;
        }
        String recipientName = args[0];
        String message = String.join(" ", Arrays.copyOfRange(args, 1, args.length));

        if (sender.getName().equalsIgnoreCase(recipientName)) {
            sender.sendMessage(ChatColor.RED + "You cannot send a message to yourself.");
            return;
        }
        sendMessage(sender, recipientName, message);
    }

    private void handleReplyCommand(Player sender, String[] args) {
        if (args.length < 1) {
            sender.sendMessage(ChatColor.RED + "Usage: /flame reply <message>");
            return;
        }
        UUID recipientUuid = plugin.getMessageManager().getReplyTarget(sender);
        if (recipientUuid == null) {
            sender.sendMessage(ChatColor.RED + "There is no one to reply to.");
            return;
        }
        Player recipientPlayer = Bukkit.getPlayer(recipientUuid);
        if (recipientPlayer == null || !recipientPlayer.isOnline()) {
            sender.sendMessage(ChatColor.RED + "The player you are replying to has gone offline.");
            return;
        }
        String message = String.join(" ", args);
        sendMessage(sender, recipientPlayer.getName(), message);
    }

    private void handleFriendCommand(Player player, String[] args) {
        if (args.length == 0) {
            player.sendMessage(ChatColor.RED + "Usage: /flame friend <add|remove|list>");
            return;
        }
        String action = args[0].toLowerCase();
        String[] actionArgs = Arrays.copyOfRange(args, 1, args.length);

        switch(action) {
            case "add":
                if (actionArgs.length < 1) {
                    player.sendMessage(ChatColor.RED + "Usage: /flame friend add <player>");
                    return;
                }
                String targetName = actionArgs[0];
                if (player.getName().equalsIgnoreCase(targetName)) {
                    player.sendMessage(ChatColor.RED + "You cannot add yourself as a friend.");
                    return;
                }
                plugin.getApiClient().sendFriendRequest(player, targetName);
                break;

            case "remove":
                if (actionArgs.length < 1) {
                    player.sendMessage(ChatColor.RED + "Usage: /flame friend remove <player>");
                    return;
                }
                plugin.getApiClient().removeFriend(player, actionArgs[0]);
                break;

            case "list":
                plugin.getApiClient().getFriendsList(player);
                break;

            case "accept": {
                if (actionArgs.length < 1) {
                    player.sendMessage(ChatColor.RED + "Usage: /flame friend accept <player>");
                    return;
                }
                String requesterName = actionArgs[0].toLowerCase();
                Map<String, Integer> playerRequests = plugin.getPendingRequests().get(player.getUniqueId());

                if (playerRequests == null || !playerRequests.containsKey(requesterName)) {
                    player.sendMessage(ChatColor.RED + "You don't have a friend request from " + actionArgs[0] + ".");
                    return;
                }
                int requestId = playerRequests.remove(requesterName);
                plugin.getApiClient().acceptFriendRequest(player, requestId);
                break;
            }
            case "deny": {
                if (actionArgs.length < 1) {
                    player.sendMessage(ChatColor.RED + "Usage: /flame friend deny <player>");
                    return;
                }
                String requesterName = actionArgs[0].toLowerCase();
                Map<String, Integer> playerRequests = plugin.getPendingRequests().get(player.getUniqueId());

                if (playerRequests == null || !playerRequests.containsKey(requesterName)) {
                    player.sendMessage(ChatColor.RED + "You don't have a friend request from " + actionArgs[0] + ".");
                    return;
                }
                int requestId = playerRequests.remove(requesterName);
                plugin.getApiClient().denyFriendRequest(player, requestId);
                break;
            }

            // TODO: –í –±—É–¥—É—â–µ–º –¥–æ–±–∞–≤–∏—Ç—å accept, deny
            default:
                player.sendMessage(ChatColor.RED + "Unknown friend command. Use: add, remove, list.");
                break;
        }
    }

    private void sendMessage(Player sender, String recipientName, String content) {
        try {
            JSONObject payload = new JSONObject();
            payload.put("senderUuid", sender.getUniqueId().toString());
            payload.put("recipientUsername", recipientName);
            payload.put("content", content);
            plugin.sendJsonPayload("inGamePrivateMessage", payload);
            sender.sendMessage(ChatColor.GRAY + "To " + recipientName + ": " + ChatColor.WHITE + content);

            Player recipientPlayer = Bukkit.getPlayer(recipientName);
            if (recipientPlayer != null) {
                plugin.getMessageManager().setLastPartner(sender, recipientPlayer);
            }
        } catch (Exception e) {
            sender.sendMessage(ChatColor.RED + "An error occurred while sending the message.");
            plugin.getLogger().severe("Could not send PM to backend for " + sender.getName());
            e.printStackTrace();
        }
    }


    private void sendHelpMessage(CommandSender sender) {
        sender.sendMessage(ChatColor.GOLD + "--- FlameWall Bridge Help ---");
        sender.sendMessage(ChatColor.AQUA + "/flame msg <player> <message>" + ChatColor.WHITE + " - Send a private message");
        sender.sendMessage(ChatColor.AQUA + "/flame reply <message>" + ChatColor.WHITE + " - Reply to the last message");
        sender.sendMessage(ChatColor.AQUA + "/flame friend <add|remove|list>" + ChatColor.WHITE + " - Manage your friends");
        sender.sendMessage(ChatColor.AQUA + "/flame sync-ranks <online|all>" + ChatColor.WHITE + " - Force sync ranks with the website");
    }

    @Override
    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
        if (args.length == 1) {
            return Arrays.asList("msg", "reply", "friend", "sync-ranks").stream()
                    .filter(a -> a.startsWith(args[0].toLowerCase())).collect(Collectors.toList());
        }
        if (args.length == 2 && args[0].equalsIgnoreCase("sync-ranks")) {
            return Arrays.asList("online", "all").stream()
                    .filter(a -> a.startsWith(args[1].toLowerCase())).collect(Collectors.toList());
        }

        if (args.length == 2) {
            String subCommand = args[0].toLowerCase();
            if (subCommand.equals("msg")) {
                return null; // –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∏–∫–æ–≤ –∏–≥—Ä–æ–∫–æ–≤
            }
            if (subCommand.equals("friend")) {
                return List.of("add", "remove", "list").stream()
                        .filter(s -> s.startsWith(args[1].toLowerCase()))
                        .collect(Collectors.toList());
            }
        }
        if (args.length == 3 && args[0].equalsIgnoreCase("friend") &&
                (args[1].equalsIgnoreCase("add") || args[1].equalsIgnoreCase("remove"))) {
            return null; // –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∏–∫–æ–≤ –∏–≥—Ä–æ–∫–æ–≤
        }
        return new ArrayList<>();
    }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/FlameCommand.java ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/LinkCommand.java ---

package com.flamewall.bridge;

import org.bukkit.ChatColor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.json.JSONException;
import org.json.JSONObject;

public class LinkCommand implements CommandExecutor {

    private final BridgePlugin plugin;

    public LinkCommand(BridgePlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("This command can only be run by a player.");
            return true;
        }

        if (args.length != 1) {
            sender.sendMessage(ChatColor.RED + "Usage: /link <code>");
            return false;
        }

        Player player = (Player) sender;
        String code = args[0];

        try {
            // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ JSON –≤ try-catch ---
            JSONObject payload = new JSONObject();
            payload.put("code", code);
            payload.put("minecraftUuid", player.getUniqueId().toString());
            payload.put("minecraftUsername", player.getName());

            // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º –¥–≤–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –∫–∞–∫ –∏ —Ç—Ä–µ–±—É–µ—Ç –º–µ—Ç–æ–¥ ---
            plugin.sendJsonPayload("linkAccount", payload);

            player.sendMessage(ChatColor.YELLOW + "Sent link request to the website. Please check the website for confirmation.");

        } catch (JSONException e) {
            player.sendMessage(ChatColor.RED + "An internal error occurred while creating the request.");
            e.printStackTrace();
        }

        return true;
    }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/LinkCommand.java ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/PlayerConnectionListener.java ---

// FlameWallBridge/src/main/java/com/flamewall/bridge/PlayerConnectionListener.java
package com.flamewall.bridge;

import me.clip.placeholderapi.PlaceholderAPI;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.server.ServerCommandEvent;
import org.bukkit.scheduler.BukkitRunnable;
import org.json.JSONObject;

import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PlayerConnectionListener implements Listener {

    private final BridgePlugin plugin;
    private final boolean papiEnabled;

    public PlayerConnectionListener(BridgePlugin plugin) {
        this.plugin = plugin;
        this.papiEnabled = Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null;
        if (papiEnabled) {
            plugin.getLogger().info("PlaceholderAPI found! Rank synchronization will be used.");
        } else {
            plugin.getLogger().warning("PlaceholderAPI not found. Rank synchronization will be disabled.");
        }
    }

    // --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ---

    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        sendStatusUpdate(player, true);
        if (papiEnabled && plugin.getConfig().getBoolean("rank-sync.enabled", true)) {
            syncSinglePlayer(player);
        }
        // –ë–õ–û–ö –£–î–ê–õ–Å–ù. –¢–ï–ü–ï–†–¨ –ú–´ –¢–û–õ–¨–ö–û –°–ò–ù–•–†–û–ù–ò–ó–ò–†–£–ï–ú.
    }

    @EventHandler
    public void onPlayerQuit(PlayerQuitEvent event) {
        sendStatusUpdate(event.getPlayer(), false);
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onPlayerCommand(PlayerCommandPreprocessEvent event) {
        String command = event.getMessage().startsWith("/") ? event.getMessage().substring(1) : event.getMessage();
        checkCommandAndSync(command);
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onServerCommand(ServerCommandEvent event) {
        checkCommandAndSync(event.getCommand());
    }


    // --- –ü–£–ë–õ–ò–ß–ù–´–ô –ú–ï–¢–û–î –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò ---

    public void syncSinglePlayer(OfflinePlayer player) {
        if (player == null) return;
        if (!papiEnabled) return;

        String rankPlaceholder = plugin.getConfig().getString("rank-sync.placeholder");
        if (rankPlaceholder == null || rankPlaceholder.isEmpty()) return;

        String rankName = PlaceholderAPI.setPlaceholders(player, rankPlaceholder);
        try {
            JSONObject payload = new JSONObject();
            payload.put("minecraftUuid", player.getUniqueId().toString());
            payload.put("rankName", rankName);
            plugin.sendJsonPayload("player:sync-rank", payload);
        } catch (Exception e) {
            plugin.getLogger().warning("Error syncing rank for " + player.getName() + ": " + e.getMessage());
        }
    }

    // --- –ü–†–ò–í–ê–¢–ù–´–ï –ú–ï–¢–û–î–´ ---

    private void sendStatusUpdate(Player player, boolean isOnline) {
        try {
            JSONObject payload = new JSONObject();
            payload.put("minecraftUuid", player.getUniqueId().toString());
            payload.put("isOnline", isOnline);
            plugin.sendJsonPayload("minecraftPlayerStatus", payload);
        } catch (Exception e) {
            plugin.getLogger().severe("Could not send player status update for " + player.getName());
        }
    }

    private void checkCommandAndSync(String command) {
        List<String> patterns = plugin.getCommandPatterns();
        if (patterns.isEmpty()) return;

        for (String patternString : patterns) {
            String regex = patternString
                    .replace("{player}", "(?<player>\\S+)")
                    .replace("{rank}", "(?<rank>\\S+)");
            Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
            Matcher matcher = pattern.matcher(command);

            if (matcher.find()) {
                final String playerName = matcher.group("player");
                final OfflinePlayer targetPlayer = Bukkit.getOfflinePlayer(playerName);

                if (targetPlayer.hasPlayedBefore() || targetPlayer.isOnline()) {
                    plugin.getLogger().info("Intercepted a rank change command for player: " + playerName + ". Sending event to website...");
                    try {
                        // –ú—ã –Ω–µ –∑–Ω–∞–µ–º, –ø–æ–≤—ã—à–µ–Ω–∏–µ —ç—Ç–æ –∏–ª–∏ –ø–æ–Ω–∏–∂–µ–Ω–∏–µ, –º—ã –ø—Ä–æ—Å—Ç–æ —Å–æ–æ–±—â–∞–µ–º –æ —Ñ–∞–∫—Ç–µ
                        String changedRankName = matcher.group("rank");
                        JSONObject payload = new JSONObject();
                        payload.put("minecraftUuid", targetPlayer.getUniqueId().toString());
                        payload.put("newRankSystemName", changedRankName.toLowerCase());
                        plugin.sendJsonPayload("player:rank-changed-ingame", payload);
                    } catch (Exception e) {
                        plugin.getLogger().warning("Error sending rank change event: " + e.getMessage());
                    }
                }
                return;
            }
        }
    }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/PlayerConnectionListener.java ---



--- START FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/PrivateMessageManager.java ---

package com.flamewall.bridge;

import org.bukkit.entity.Player;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class PrivateMessageManager {
    // –•—Ä–∞–Ω–∏—Ç –ø–∞—Ä—É "–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ", –≥–¥–µ:
    // –ö–ª—é—á - UUID –∏–≥—Ä–æ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ
    // –ó–Ω–∞—á–µ–Ω–∏–µ - UUID –∏–≥—Ä–æ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–∏–ª —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
    private final Map<UUID, UUID> lastMessagePartners = new HashMap<>();

    public void setLastPartner(Player player1, Player player2) {
        lastMessagePartners.put(player1.getUniqueId(), player2.getUniqueId());
        lastMessagePartners.put(player2.getUniqueId(), player1.getUniqueId());
    }

    public UUID getReplyTarget(Player sender) {
        return lastMessagePartners.get(sender.getUniqueId());
    }
}
--- END FILE: FlameWallBridge/src/main/java/com/flamewall/bridge/PrivateMessageManager.java ---



--- START FILE: FlameWallBridge/src/main/resources/config.yml ---

# FlameWallBridge Configuration

# URL –∏ –∫–ª—é—á –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API –±—ç–∫–µ–Ω–¥–∞
api-base-url: "http://localhost:3001"
plugin-secret-key: "your_super_long_and_random_plugin_secret_key"

# --- Shop Settings ---
shop:
  # How often (in seconds) should the plugin check for pending purchases?
  check-interval-seconds: 300 # 5 minutes

# --- Rank Synchronization Settings ---
rank-sync:
  enabled: true
  placeholder: "%luckperms_primary_group_name%"

# --- Command Interception ---
intercept-commands:
  - "lp user {player} parent set {rank}"

# --- Full Synchronization Settings ---
sync-settings:
  batch-size: 50
  delay-ticks: 10
--- END FILE: FlameWallBridge/src/main/resources/config.yml ---



--- START FILE: FlameWallBridge/src/main/resources/plugin.yml ---

name: FlameWallBridge
version: 1.0-SNAPSHOT
main: com.flamewall.bridge.BridgePlugin
api-version: '1.20'
author: YourName
softdepend: [PlaceholderAPI]

commands:
  link:
    description: Links your website account to your Minecraft account.
    usage: "/link <code>"

  flame:
    description: Main command for FlameWall website integration.
    usage: /flame <msg|reply|friend|...>
    aliases: [fw]

permissions:
  flamewall.admin.sync:
    description: Allows usage of the /flame sync-ranks command.
    default: op
--- END FILE: FlameWallBridge/src/main/resources/plugin.yml ---



--- START FILE: .env ---

# ================================================================
# FLAMEWALL PRODUCTION .ENV
# –≠—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞ —Ç–≤–æ–µ–º VPS-—Å–µ—Ä–≤–µ—Ä–µ
# ================================================================

# --- DOCKER & DATABASE CONFIG ---
# –ó–∞–º–µ–Ω–∏ –ø–∞—Ä–æ–ª–∏ –Ω–∞ —Å–≤–æ–∏, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ –º–µ–Ω–µ–¥–∂–µ—Ä–µ –ø–∞—Ä–æ–ª–µ–π)
POSTGRES_USER=flamewall_user
POSTGRES_PASSWORD=your_strong_and_secret_db_password
POSTGRES_DB=flamewall
PGADMIN_DEFAULT_EMAIL=admin@your_domain.com
PGADMIN_DEFAULT_PASSWORD=your_strong_and_secret_pgadmin_password

# --- BACKEND (NESTJS) CONFIG ---
# –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–µ—Ä–≤–∏—Å–æ–º 'backend' –≤ docker-compose
API_PORT=3000 # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø–æ—Ä—Ç, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è NestJS
DB_HOST=db    # –ò–º—è —Å–µ—Ä–≤–∏—Å–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –≤ docker-compose.yml
DB_PORT=5432
DB_USERNAME=${POSTGRES_USER} # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —á—Ç–æ –∏ –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞ db
DB_PASSWORD=${POSTGRES_PASSWORD} # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —á—Ç–æ –∏ –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞ db
DB_DATABASE=${POSTGRES_DB} # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —á—Ç–æ –∏ –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞ db

# –ó–∞–º–µ–Ω–∏ —ç—Ç–∏ –∫–ª—é—á–∏ –Ω–∞ –¥–ª–∏–Ω–Ω—ã–µ, —Å–ª—É—á–∞–π–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
JWT_SECRET=your_super_long_and_random_jwt_secret_key
PLUGIN_SECRET_KEY=your_super_long_and_random_plugin_secret_key

# –ò–ó–ú–ï–ù–ï–ù–û: –§–æ—Ä–º–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–Ω–∏–º–∞–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ JWT
JWT_EXPIRATION_TIME=30d # –¢–æ–∫–µ–Ω –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 30 –¥–Ω–µ–π

# --- FRONTEND (REACT) CONFIG ---
# –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏ —Å–±–æ—Ä–∫–µ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
# –í–ê–ñ–ù–û: –ù–∞ VPS —ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏ Docker-–æ–±—Ä–∞–∑–∞.
# –í –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–µ—Ä–≤–µ—Ä–æ–º Vite/React.
PORT=5173 # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø–æ—Ä—Ç, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥-—Å–µ—Ä–≤–µ—Ä

REACT_APP_API_BASE_URL=http://localhost:3001
REACT_APP_FULL_API_URL=http://localhost:3001

--- END FILE: .env ---



--- START FILE: docker-compose.yml ---

# docker-compose.yml

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: flamewall_frontend_dev
    # –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Ä—Ç 3000 –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç 5173 –≤–∞—à–µ–≥–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
    # –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º –æ—Ç–∫—Ä—ã–≤–∞—Ç—å http://localhost:5173 –≤ –±—Ä–∞—É–∑–µ—Ä–µ
    ports:
      - "5173:3000"
    # –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ö–õ–Æ–ß–ï–í–´–ï –¥–ª—è —Ä–∞–±–æ—Ç—ã hot-reload –≤ Docker
    environment:
      - CHOKIDAR_USEPOLLING=true # <-- –î–û–ë–ê–í–õ–ï–ù–û: –ó–∞—Å—Ç–∞–≤–ª—è–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫—É —Å–ª–µ–∂–µ–Ω–∏—è –∑–∞ —Ñ–∞–π–ª–∞–º–∏ —Ä–∞–±–æ—Ç–∞—Ç—å –≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ
    # –°–≤—è–∑—ã–≤–∞–µ–º –ø–∞–ø–∫—É —Å –∫–æ–¥–æ–º –¥–ª—è live-reload
    # –í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ø–∞–ø–∫–µ frontend –±—É–¥—É—Ç —Å—Ä–∞–∑—É –≤–∏–¥–Ω—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
    volumes:
      - ./frontend:/app
      # –≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∑–∞—Ç–∏—Ä–∞–Ω–∏–µ node_modules –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
      # –ª–æ–∫–∞–ª—å–Ω–æ–π –ø—É—Å—Ç–æ–π –ø–∞–ø–∫–æ–π node_modules
      - /app/node_modules
    restart: unless-stopped
    networks:
      - flamewall_net

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: flamewall_backend_dev
    # –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Ä—Ç 3000 –±—ç–∫–µ–Ω–¥–∞ –Ω–∞ 3001 –≤–∞—à–µ–≥–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
    ports:
      - "3001:3000"
    environment:
      - FORCE_COLOR=1 # –î–ª—è —Ü–≤–µ—Ç–Ω—ã—Ö –ª–æ–≥–æ–≤ –≤ Docker
    volumes:
      - ./backend:/usr/src/app
      - /usr/src/app/node_modules
    env_file:
      - ./.env
    depends_on:
      - db
    restart: unless-stopped
    networks:
      - flamewall_net

  db:
    image: postgres:15
    container_name: flamewall_db_dev # –î–∞–¥–∏–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    restart: unless-stopped
    env_file:
      - ./.env
    volumes:
      - postgres_data_dev:/var/lib/postgresql/data # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π volume –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    networks:
      - flamewall_net

  pgadmin:
    image: dpage/pgadmin4
    container_name: flamewall_pgadmin_dev # –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è
    restart: unless-stopped
    logging:
      driver: "none"
    env_file:
      - ./.env
    ports:
      - "5050:80"
    depends_on:
      - db
    volumes:
      - pgadmin_data_dev:/var/lib/pgadmin # –û—Ç–¥–µ–ª—å–Ω—ã–π volume
    networks:
      - flamewall_net

volumes:
  postgres_data_dev: # –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è volume
  pgadmin_data_dev:  # –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è volume

networks:
  flamewall_net:
    driver: bridge
--- END FILE: docker-compose.yml ---



--- START FILE: docker-compose.prod.yml ---

version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile.prod
    image: flamewall-backend:latest # <-- –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
    container_name: flamewall_backend_prod
    restart: unless-stopped
    environment:
      - FORCE_COLOR=1 # –ó–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å 1, 2 –∏–ª–∏ 3. 1 - –±–∞–∑–æ–≤—ã–µ —Ü–≤–µ—Ç–∞.
    env_file: ./.env
    volumes:
      - ./uploads:/usr/src/app/uploads
    networks:
      - flamewall_net
    depends_on:
      - db

  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile.prod
      args:
        - REACT_APP_FULL_API_URL=${REACT_APP_FULL_API_URL}
    image: flamewall-frontend:latest # <-- –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
    container_name: flamewall_frontend_prod
    restart: unless-stopped
    networks:
      - flamewall_net

  db:
    image: postgres:15
    container_name: flamewall_db_prod
    restart: unless-stopped
    env_file: ./.env
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - flamewall_net

  nginx:
    image: nginx:alpine
    container_name: flamewall_nginx_proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.prod.conf:/etc/nginx/nginx.conf:ro
      - ./uploads:/usr/share/nginx/html/uploads:ro
      # –°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã (—á—Ç–æ–±—ã Nginx –∏—Ö –Ω–∞—à–µ–ª)
      - /etc/letsencrypt:/etc/letsencrypt:ro
      # –§–∞–π–ª—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Certbot (–¥–ª—è –∞–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
      - /var/www/certbot:/var/www/certbot:ro
    depends_on:
      - frontend
      - backend
    networks:
      - flamewall_net

volumes:
  postgres_data:

networks:
  flamewall_net:
    driver: bridge
--- END FILE: docker-compose.prod.yml ---



--- START FILE: backend/Dockerfile ---

FROM node:20-alpine

WORKDIR /usr/src/app

# –ö–æ–ø–∏—Ä—É–µ–º package.json –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –í–°–ï –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
COPY package.json ./
COPY package-lock.json ./
RUN npm install

# –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω–æ–π –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥
COPY . .

# –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
CMD ["npm", "run", "start:dev"]
--- END FILE: backend/Dockerfile ---



--- START FILE: backend/Dockerfile.prod ---

# --- –≠—Ç–∞–ø 1: "–°—Ç—Ä–æ–∏—Ç–µ–ª—å" (Builder) ---
FROM node:20-alpine AS builder
WORKDIR /usr/src/app

COPY backend/package*.json ./
RUN npm install
COPY backend/ .
RUN npm run build
RUN npm prune --production

# --- –≠—Ç–∞–ø 2: –§–∏–Ω–∞–ª—å–Ω—ã–π, "—á–∏—Å—Ç—ã–π" –æ–±—Ä–∞–∑ ---
FROM node:20-alpine
WORKDIR /usr/src/app

COPY --from=builder /usr/src/app/dist ./dist
COPY --from=builder /usr/src/app/node_modules ./node_modules
COPY --from=builder /usr/src/app/package.json .

CMD ["node", "dist/main"]
--- END FILE: backend/Dockerfile.prod ---



--- START FILE: frontend/Dockerfile ---

# frontend/Dockerfile

FROM node:20-alpine

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–±–æ—á—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
WORKDIR /app

# –ö–æ–ø–∏—Ä—É–µ–º package.json –∏ package-lock.json –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
# –≠—Ç–æ –∫–µ—à–∏—Ä—É–µ—Ç—Å—è, –µ—Å–ª–∏ —Ñ–∞–π–ª—ã –Ω–µ –º–µ–Ω—è–ª–∏—Å—å, —á—Ç–æ —É—Å–∫–æ—Ä—è–µ—Ç –ø–µ—Ä–µ—Å–±–æ—Ä–∫—É
COPY package*.json ./

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
RUN npm install

# –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
COPY . .

# React-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–∞ –ø–æ—Ä—Ç—É 3000
EXPOSE 3000

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
CMD ["npm", "start"]
--- END FILE: frontend/Dockerfile ---



--- START FILE: frontend/Dockerfile.prod ---

# --- –≠—Ç–∞–ø 1: –°–±–æ—Ä–∫–∞ —Å—Ç–∞—Ç–∏–∫–∏ ---
FROM node:20-alpine AS builder
# –û–±—ä—è–≤–ª—è–µ–º, —á—Ç–æ –º—ã –æ–∂–∏–¥–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç —Å–±–æ—Ä–∫–∏ —Å —ç—Ç–∏–º –∏–º–µ–Ω–µ–º
ARG REACT_APP_FULL_API_URL
# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ–≥–æ –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è, —á—Ç–æ–±—ã –∫–æ–º–∞–Ω–¥–∞ 'npm run build' –µ–µ —É–≤–∏–¥–µ–ª–∞
ENV REACT_APP_FULL_API_URL=$REACT_APP_FULL_API_URL
WORKDIR /app
COPY frontend/package*.json ./
RUN npm install
COPY frontend/ .
RUN npm run build

# --- –≠—Ç–∞–ø 2: –§–∏–Ω–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–∑ —Å Nginx ---
FROM nginx:alpine
COPY frontend/nginx/nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=builder /app/build /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
--- END FILE: frontend/Dockerfile.prod ---



--- START FILE: frontend/package.json ---

{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@fontsource/inter": "^5.2.5",
    "@mui/icons-material": "^7.1.0",
    "@mui/joy": "^5.0.0-beta.52",
    "@mui/material": "^7.1.2",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "@tiptap/extension-color": "^2.22.3",
    "@tiptap/extension-font-family": "^2.22.3",
    "@tiptap/extension-highlight": "^2.22.3",
    "@tiptap/extension-image": "^2.22.3",
    "@tiptap/extension-link": "^2.22.3",
    "@tiptap/extension-strike": "^2.22.3",
    "@tiptap/extension-subscript": "^2.22.3",
    "@tiptap/extension-superscript": "^2.22.3",
    "@tiptap/extension-text-align": "^2.22.3",
    "@tiptap/extension-text-style": "^2.22.3",
    "@tiptap/extension-underline": "^2.22.3",
    "@tiptap/react": "^2.22.3",
    "@tiptap/starter-kit": "^2.22.3",
    "axios": "^1.9.0",
    "jwt-decode": "^4.0.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^6.25.1",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.8.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "HOST=0.0.0.0 react-scripts start",
    "start:react": "react-scripts start",
    "build": "react-scripts build && npm run rename-sw",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "rename-sw": "mv build/service-worker-prod.js build/service-worker.js"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  },
  "overrides": {
    "nth-check": "2.0.1"
  }
}
--- END FILE: frontend/package.json ---



--- START FILE: FlameWallBridge/pom.xml ---

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.flamewall</groupId>
    <artifactId>FlameWallBridge</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <properties>
        <java.version>21</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <relocations>
                        <relocation>
                            <pattern>io.socket</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.io.socket</shadedPattern>
                        </relocation>
                        <relocation>
                            <pattern>io.engine</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.io.engine</shadedPattern>
                        </relocation>
                        <relocation>
                            <pattern>org.json</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.org.json</shadedPattern>
                        </relocation>
                        <relocation>
                            <pattern>io.netty</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.io.netty</shadedPattern>
                        </relocation>
                        <relocation>
                            <pattern>okhttp3</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.okhttp3</shadedPattern>
                        </relocation>
                        <relocation>
                            <pattern>okio</pattern>
                            <shadedPattern>com.flamewall.bridge.lib.okio</shadedPattern>
                        </relocation>
                    </relocations>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        <repository>
            <id>papermc-repo</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
        <repository>
            <id>placeholderapi</id>
            <url>https://repo.extendedclip.com/content/repositories/placeholderapi/</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>1.21-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>me.clip</groupId>
            <artifactId>placeholderapi</artifactId>
            <version>2.11.6</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>io.socket</groupId>
            <artifactId>socket.io-client</artifactId>
            <version>2.1.0</version>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.12.0</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
</project>
--- END FILE: FlameWallBridge/pom.xml ---

